/**
 * @file motor_lib.h
 * @date 2021-01-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * MOTOR_LIB v4.0.12 - Provides common motor control library API's.
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version
 *
 * 2015-06-20:
 *     - Vector magnitude calculation API's are added
 *
 * 2021-01-08:
 *     - Modified check for minimum XMCLib version
 *
 * @endcond
 *
 */

#ifndef MOTOR_LIB_H_
#define MOTOR_LIB_H_
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "xmc_common.h"
#include "DAVE_Common.h"
#include "motor_lib_conf.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#define MOTOR_LIB_XMC_LIB_MAJOR_VERSION 2
#define MOTOR_LIB_XMC_LIB_MINOR_VERSION 0
#define MOTOR_LIB_XMC_LIB_PATCH_VERSION 0

#if !((XMC_LIB_MAJOR_VERSION > MOTOR_LIB_XMC_LIB_MAJOR_VERSION) ||\
      ((XMC_LIB_MAJOR_VERSION == MOTOR_LIB_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > MOTOR_LIB_XMC_LIB_MINOR_VERSION)) ||\
      ((XMC_LIB_MAJOR_VERSION == MOTOR_LIB_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == MOTOR_LIB_XMC_LIB_MINOR_VERSION) && (XMC_LIB_PATCH_VERSION >= MOTOR_LIB_XMC_LIB_PATCH_VERSION)))
#error "MOTOR_LIB requires XMC Peripheral Library v2.0.0 or higher"
#endif

/**
  * @ingroup MOTOR_LIB_constants
  * @{
  */

/**This is Inverse of Square root of 3 (1/sqrt(3)*2^15)*/
#define MOTOR_LIB_INVSQRT3 (0x49E6)

/**This is Angle Scaling - Convert 24 bit to 16 bit*/
#define MOTOR_LIB_ANGLESCALE  (0xFF)
#define MOTOR_LIB_ANGLESCALE_SHIFT  (0x8U)

/**This is Amplitude Scaling - Convert 24 bit to 16 bit*/
#define MOTOR_LIB_AMPSCALE  (0xFF)

/**This is to extract CORDZ data */
#define MOTOR_LIB_CORDZ_DATA_POSSCALE (0xFF)
#define MOTOR_LIB_CORDZ_DATA_POSSCALE_SHIFT (0x8U)

/**This is to extract CORRX Result data */
#define MOTOR_LIB_CORRX_RESULT_POSSCALE (0x8U)

/**This is PI Controller KP Values Scaling*/
#define MOTOR_LIB_PI_KPSCALE  (0x1FF)
#define MOTOR_LIB_PI_KPSCALE_SHIFT  (0x09U)

/**This is Inverse of kCordic value (2^16/(1.64676 * 2^8)) */
#define MOTOR_LIB_INV_KCORDIC (155)
/*Divided by 2 is done by CORIDC operation*/
#define MOTOR_LIB_KCORDIC_SCALE (0xFF/2)
/**This is Inverse of kCordic value in hyperbolic mode(2^16/(0.828159360960 * 2^8)) */
#define MOTOR_LIB_INV_KCORDIC_HYPERBOLIC (308)
/**This is kCordic value in hyperbolic mode(0.828159360960*2^8) */
#define MOTOR_LIB_K_Hyperbolic (0.828159360960 * 0xFF)

/** This is CORDIC scale value after considering magnitude pre-scalar value. MOTOR_LIB_KCORDIC_SCALE *2^MOTOR_LIB_MPS_DIVBY2 */
#define MOTOR_LIB_MPS (0xFF)
#define MOTOR_LIB_MPS_DIV2 (2U)

/** This is (2^16 -1)value used for scaling operation */
#define MOTOR_LIB_2POW16 (0xFFFF)
#define MOTOR_LIB_2POW23 (0x7FFFFF)
#define MOTOR_LIB_SHIFT8 (8U)

/**This is PI Controller KI Values SCaling*/
#define MOTOR_LIB_PI_KISCALE       (0x7FFF)
#define MOTOR_LIB_PI_KISCALE_SHIFT (0x0FU)

/**
  * @}
  */



#if !defined (MATH)
/**
  * @ingroup MOTOR_LIB_constants
  * @{
  */
/**This is CORIDC K values used in SW CORIDC*/
#define MOTOR_LIB_CORDIC_K             (1304065792U)

/**This is CORIDC Iteration, maximum values is 23*/
#define MOTOR_LIB_CORDIC_ITERATIONS    (15U)

/**
  * @}
  */

/**********************************************************************************************************************
* ENUMS
**********************************************************************************************************************/

/**
  * @ingroup MOTOR_LIB_enumerations
  * @{
  */
/**
 * This enumerates magnitude prescaler value for calculated value of X & Y
 */
typedef enum MOTOR_LIB_CON_MPS
{
 /**
  * After the last iteration of calculation the X & Y values are divided by 1
  */
  MOTOR_LIB_MPS_DIVBY1 = 0x00U,
 /**
  * After the last iteration of calculation the X & Y values are divided by 2
  */
  MOTOR_LIB_MPS_DIVBY2 = 0x01U,
 /**
  * After the last iteration of calculation the X & Y values are divided by 4
  */
  MOTOR_LIB_MPS_DIVBY4 = 0x02U

} MOTOR_LIB_CON_MPS_t;
/**
  * @}
  */
#endif

#if defined (MATH)
/**
  * @ingroup MOTOR_LIB_enumerations
  * @{
  */
/**
 * This enumerates control to Keep or Clear the last X result as initial data
 * for next calculation
 */
typedef enum MOTOR_LIB_STATC_KEEPX
{
  /**
   * This clears last X Result for a New Calculation
   */
  MOTOR_LIB_CLEAR_KEEPX = 0x00U,
  /**
   * This keeps last X Result as Initial Data for a New Calculation
   */
  MOTOR_LIB_SET_KEEPX = 0x20U

} MOTOR_LIB_STATC_KEEPX_t;
/**
 * This enumerates control to Keep or Clear the last Y result as initial data
 * for next calculation
 */
typedef enum MOTOR_LIB_STATC_KEEPY
{
  /**
   * This clears last Y Result for a New Calculation
   */
  MOTOR_LIB_CLEAR_KEEPY = 0x00U,
  /**
   * This keeps last Y Result as Initial Data for a New Calculation
   */
  MOTOR_LIB_SET_KEEPY = 0x40U

} MOTOR_LIB_STATC_KEEPY_t;

/**
 * This enumerates control to Keep or Clear the last Z result as initial data
 * for next calculation
 */
typedef enum MOTOR_LIB_STATC_KEEPZ
{
  /**
   * This clears last Z Result for a New Calculation
   */
  MOTOR_LIB_CLEAR_KEEPZ = 0x00U,
  /**
   * This keeps last Z Result as Initial Data for a New Calculation
   */
  MOTOR_LIB_SET_KEEPZ = 0x80U

} MOTOR_LIB_STATC_KEEPZ_t;
/**
 * This enumerates different modes for CORDIC operating modes
 */
typedef enum MOTOR_LIB_CON_MODE
{
  /**
   * This sets CORDIC to Linear Operating Mode
   */
  MOTOR_LIB_LINEAR_MODE = 0x0U,
  /**
   * This sets CORDIC to Circular Operating Mode
   */
  MOTOR_LIB_CIRCULAR_MODE = 0x2U,
  /**
   * This sets CORDIC to Hyperbolic Operating Mode
   */
  MOTOR_LIB_HYPERBOLIC_MODE = 0x6U

} MOTOR_LIB_CON_MODE_t;

/**
 * This enumerates CORDIC Rotation Vectoring Selection
 */
typedef enum MOTOR_LIB_CON_ROTVEC
{
  /**
   * This sets CORDIC to Vectoring Mode
   */
  MOTOR_LIB_VECTORING_MODE = 0x0U,
  /**
   * This sets CORDIC to Rotation Mode
   */
  MOTOR_LIB_ROTATION_MODE = 0x8U

} MOTOR_LIB_CON_ROTVEC_t;

/**
 * This enumerates different modes for starting CORDIC operation
 */
typedef enum MOTOR_LIB_CON_STMODE
{
  /**
   * Auto start of calculation after write access to X parameter data register
   */
  MOTOR_LIB_CORDIC_AUTO_START = 0x00U,
  /**
   * Start calculation only after bit ST is set
   */
  MOTOR_LIB_CORDIC_ST_START = 0x10U

} MOTOR_LIB_CON_STMODE_t;

/**
 * This enumerates 'X result register' data format in circular vectoring mode.
 */
typedef enum MOTOR_LIB_CON_XUSIGN
{
  /**
   * This sets X result data format to Signed (twos complement), when read
   */
  MOTOR_LIB_SIGNED_X_RESULT = 0x00U,
  /**
   * This sets X result data format to Unsigned, when read
   */
  MOTOR_LIB_UNSIGNED_X_RESULT = 0x20U

}MOTOR_LIB_CON_XUSIGN_t;

/**
 * This enumerates magnitude prescaler value for calculated value of X & Y
 */
typedef enum MOTOR_LIB_CON_MPS
{
  /**
   * After the last iteration of calculation the X & Y values are divided by 1
   */
  MOTOR_LIB_MPS_DIVBY1 = 0x00U,
  /**
   * After the last iteration of calculation the X & Y values are divided by 2
   */
  MOTOR_LIB_MPS_DIVBY2 = 0x40U,
  /**
   * After the last iteration of calculation the X & Y values are divided by 4
   */
  MOTOR_LIB_MPS_DIVBY4 = 0x80U

}MOTOR_LIB_CON_MPS_t;

#endif

/**
  * @}
  */

/**
  * @ingroup MOTOR_LIB_datastructures
  * @{
  */
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/**
 * This structure holds the values of PI parameters.
 */
typedef struct MOTOR_LIB_PIHandle
{
  /**
   * This is the Kp value
   */
  uint32_t  kp;
 /**
  * This is the Ki value
  */
  uint32_t  ki;
 /**
  * This is the buffer
  */
  int32_t  i_buf;
  /**
   * Maximum limit for buffer
   */
  const int32_t  y_imax;
  /**
   * Minimum limit for buffer
   */
  const int32_t  y_imin;
  /**
   * Maximum limit for PI controller output
   */
  const int16_t  y_max;
  /**
   * Minimum limit for PI controller output
   */
  const int16_t  y_min;
  /**
   * This is the required output value for PI controller
   */
  int16_t pi_out_val;

} MOTOR_LIB_PIHandle_t;


/**
 * This structure holds the values of PT1 filter parameters.
 */
typedef struct MOTOR_LIB_PT1Handle
{
  /**
   * Filter constant
   */
  int32_t  z1;
  /**
   * Filter constant
   */
  int32_t  z2;
  /**
   * Maximum limit of PT1 buffer
   */
  const int32_t  y_max;
  /**
   * Minimum limit of PT1 buffer
   */
  const int32_t  y_min;
  /**
   * This is the integral buffer of pt1 filter
   */
  int32_t  pt1_buf;
  /**
   * This is PT1 filter output.
   */
  int32_t  pt1_out_val;

} MOTOR_LIB_PT1Handle_t;

/**
 * This structure holds the values of Feed Forward controller parameters.
 */
typedef struct MOTOR_LIB_FeedForwardHandle
{
  /**
   * PT1 filter
   */
  MOTOR_LIB_PT1Handle_t *pt1_filter_ptr;
  /**
   * FeedForward output
   */
  int32_t feedforward_out_val;
  /**
   * This is the integral buffer of pt1 filter
   */
  int32_t  antinoise_filter_buffer;
  /**
   * This is to store FeedForward output values based on dead time configuration
   */
  int32_t  dead_time_buffer;
  /**
   * This is the differential operation buffer
   */
  int32_t  differential_buffer;
  /**
   * Maximum limit for Feed Forward controller output
   */
  int32_t  y_max;
  /**
   * Minimum limit for Feed Forward controller output
   */
  int32_t  y_min;
  /**
   * This is the gain value
   */
  uint16_t  feedforward_gain;
  /**
   * This is the differential gain value
   */
  uint16_t  differential_gain;

  /**
   * This is dead band for i/p to avoid LSB flickering
   */
  uint16_t  dead_band;

  /**
   * Dead time enable/disable control
   * DeadTime - 1 -Enable delay of 1 cycle
   *          - 0 -Disable delay
   */
   uint8_t  dead_time_enable;

} MOTOR_LIB_FeedForwardHandle_t;

/**
 * @}
 */
#ifdef __cplusplus
extern "C" {
#endif
/**
 * @ingroup MOTOR_LIB_apidoc
 * @{
 */
/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
#if defined (MATH)
/**
  * @brief Enables HW CORDIC in case of XMC13 device.
  * @param None
  * @return None
  *
  * \par<b>Description</b><br>
  * This function enables HW CORDIC in case of XMC13 device.
  *
  * \par<b>Note</b><br>
  * This API should be called before using any CORDIC related API's.
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * 
  * int main (void)
  * {
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   MOTOR_LIB_CordicEnable();
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
void MOTOR_LIB_CordicEnable(void);
#endif
/**
  * @brief This is the implementation of FeedForward controller.
  * @param handle_ptr Pointer to @ref MOTOR_LIB_FeedForwardHandleType
  * @param feedforward_input_val Reference input to feedforward
  * @return None
  *
  * \par<b>Description</b><br>
  * This function is the implementation of FeedForward controller.
  * This can be used along with PI controller for fast and steady response.
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * int main (void)
  * {
  *   int32_t feedforward_input_val = 400;
  *   MOTOR_LIB_FeedForwardHandle_t handle;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   MOTOR_LIB_FeedForwardController(&handle,error_val,feedforward_input_val);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
void MOTOR_LIB_FeedForwardController(MOTOR_LIB_FeedForwardHandle_t *handle_ptr,int32_t feedforward_input_val);

/**
  * @brief This is the implementation of PI controller.
  * @param handle_ptr Pointer to MOTOR_LIB_PIHandleType
  * @param error_val Error value for PI controller
  * @return None
  *
  * \par<b>Description</b><br>
  * This function is the implementation of PI controller.\n
  * PI Output = kp*error + Ki * integral of error
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * 
  * int main (void)
  * {
  *   int32_t error_val = 400;
  *   MOTOR_LIB_PIHandle_t handle;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   MOTOR_LIB_PIController(&handle,error_val);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
void MOTOR_LIB_PIController
(
    MOTOR_LIB_PIHandle_t *handle_ptr,
    int32_t error_val
);
/**
  * @brief This is the implementation of PT1 filter.
  * @param handle_ptr PT1 Handle pointer
  * @param actual_val Input value for PT1 filter
  * @return None
  *
  * \par<b>Description</b><br>
  * This function is the implementation of PT1 filter.\n
  * Yn[3,2,1,0]  =Yn-1[3,2,1,0] +Z1*(Xn -Yn-1[3,2]) \n
  * Where Z1 is time constant.
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * 
  * int main (void)
  * {
  *   int32_t actual_val = 400;
  *   MOTOR_LIB_PT1Handle_t handle;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   MOTOR_LIB_PT1Controller(&handle,actual_val);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
void MOTOR_LIB_PT1Controller
(
   MOTOR_LIB_PT1Handle_t *handle_ptr,
   int32_t actual_val
);

/**
  * @brief This is the implementation of PT12 filter.
  * @param handle_ptr PT1 Handle pointer
  * @param actual_val Input value for PT1 filter
  * @return None
  *
  * \par<b>Description</b><br>
  * This function is the implementation of PT12 filter.\n
  * Yn[3,2,1,0]  =Yn-1[3,2,1,0] +(Z1*Xn -Z2*Yn-1[3,2]) \n
  * Where Z1 and Z2 are time constant.
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * 
  * int main (void)
  * {
  *   int32_t actual_val = 400;
  *   MOTOR_LIB_PT1Handle_t handle;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   MOTOR_LIB_PT12Controller(&handle,actual_val);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
void MOTOR_LIB_PT12Controller
(
   MOTOR_LIB_PT1Handle_t *handle_ptr,
   int32_t actual_val
);

/**
  * @brief This is the implementation of clark transform based on two phase current measurement.
  * @param phase_a  Phase A current value
  * @param phase_b  Phase B current value
  * @param i_alpha Pointer to output value Ialpha
  * @return i_beta
  *
  * \par<b>Description</b><br>
  * This function is the implementation of clark transform.\n
  * It will determine the stator current projection in a two co-ordinate non-rotating frame(Ialpha and Ibeta).\n
  * Ialpha = Phase_A/2 \n
  * Ibeta  = (Phase_A+2*Phase_B)/(2*Sqrt(3))
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * 
  * int main (void)
  * {
  *   int32_t ialpha,ibeta;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   ibeta = MOTOR_LIB_ClarkTransform(1000,400,&ialpha);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
int32_t MOTOR_LIB_ClarkTransform(int32_t phase_a, int32_t phase_b, int32_t *i_alpha );

/**
  * @brief This is the implementation of clark transform based on three phase current measurement.
  * @param phase_a  Phase A current value
  * @param phase_b  Phase B current value
  * @param phase_c  Phase C current value
  * @param i_alpha Pointer to output value Ialpha
  * @return  Ibeta <BR>
  *
  * \par<b>Description</b><br>
  * This function is the implementation of clark transform. \n
  * It will determine the stator current projection in a two co-ordinate non-rotating frame(Ialpha and Ibeta). \n
  * Ialpha = (2*Phase_A -Phase_B-Phase_C)/2 \n
  * Ibeta  = (Phase_B-Phase_C)/(2*Sqrt(3)) \n
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * 
  * int main (void)
  * {
  *   int32_t ialpha,ibeta;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   ibeta = MOTOR_LIB_ClarkTransform2(1000,400,800,&ialpha);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
int32_t MOTOR_LIB_ClarkTransform2(int32_t phase_a, int32_t phase_b, int32_t phase_c, int32_t *i_alpha );

/**
  * @brief This is the implementation of park transform.
  * @param i_alpha Ialpha(non-rotating frame)
  * @param i_beta  Ibeta(non-rotating frame)
  * @param angle  Angle
  * @param Pointer to output Iq value
  * @return  Id
  *
  * \par<b>Description</b><br>
  * This function is the implementation of park transform. \n
  * It will determine the projection in the (Id,Iq) rotating frame. \n
  * Id  =k*(Ialpha*cos(Angle)+Ibeta*sin(Angle))/2  ; where k = 1.64767 \n
  * Iq  =k*(-Ialpha*sin(Angle)+Ibeta*cos(Angle))/2 ; where k = 1.64767 \n
  *
  * \par<b>Note</b><br>
  * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic and linear functions.
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * 
  * int main (void)
  * {
  *   int32_t ialpha,ibeta,iq,id;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   id = MOTOR_LIB_ParkTransform(1000,400,800,&iq);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
int32_t MOTOR_LIB_ParkTransform(int32_t i_alpha,int32_t i_beta,int16_t angle,int32_t *iq);

/**
  * @brief This is the implementation of inverse park transform.
  * @param vd  Vd Voltage component on d-axis
  * @param vq  Vq Voltage component on q-axis
  * @param angle Angle
  * @param vbeta Pointer to output Vbeta value
  * @return Valpha <BR>
  *
  * \par<b>Description</b><br>
  * This function is the implementation of inverse park transform. \n
  * Valpha  = k*(Vd*cos(Angle)- Vq*sin(Angle))/4 ; where k = 1.64767 \n
  * Vbeta   = k*(Vd*sin(Angle)+Vq*cos(Angle))/4 ; where k = 1.64767 \n
  *
  * \par<b>Note</b><br>
  * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic and linear functions.
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * 
  * int main (void)
  * {
  *   int32_t valpha,vbeta;
  *   int16_t angle;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   valpha = MOTOR_LIB_IParkTransform(1000,400,&vbeta);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
int32_t MOTOR_LIB_IParkTransform(int32_t vd,int32_t vq,int16_t angle,int32_t *vbeta);

/**
  * @brief This is the implementation cartesian to polar transform.
  * @param x  Input X co-ordinate value
  * @param y  Input Y co-ordinate value
  * @param angle Pointer to output angle value
  * @return  Amplitude <BR>
  *
  * \par<b>Description</b><br>
  * This function is the implementation cartesian to polar transform.\n
  * Amplitude  = K * SQRT(x*x+y*y); where k = 1.64767 \n
  * Angle      = ATAN(y/x); \n
  *
  * \par<b>Note</b><br>
  * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic and linear functions.
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * 
  * int main (void)
  * {
  *   uint32_t amplitude;
  *   int16_t angle;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   amplitude = MOTOR_LIB_Car2Pol(1000,400,&angle);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
uint32_t MOTOR_LIB_Car2Pol(int32_t x,int32_t y, int16_t *angle);

/**
  * @brief This is the implementation polar to cartesian transform.
  * @param angle  Polar angle
  * @param amplitude Amplitude
  * @param x Pointer to output X co-ordinate value
  * @return  Y co-ordinate value <BR>
  *
  * \par<b>Description</b><br>
  * This function is the implementation polar to cartesian transform.\n
  * X = K * Amplitude* cos(Angle); where k = 1.64767  \n
  * Y = K * Amplitude* sin(Angle); where k = 1.64767  \n
  *
  * \par<b>Note</b><br>
  * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic and linear functions.
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * 
  * int main (void)
  * {
  *   int32_t x,y;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   y = MOTOR_LIB_Pol2Car(1000,400,&x);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
int32_t MOTOR_LIB_Pol2Car(int16_t angle,uint32_t amplitude, int32_t *x);

/**
 * @brief Returns APP version information
 * @param None
 * @return DAVE_APP_VERSION_t Returns APP version number(major, minor and patch number).
 * <BR>
 *
 * \par<b>Description</b><br>
 * Each of the DAVE APP exports a version number(major, minor and patch number).
 * Applications may then audit such a version number to determine compatibility.
 *
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   DAVE_APP_VERSION_t version;
 *   status = DAVE_Init();
 *   version = MOTOR_LIB_GetAppVersion();
 *   if (version.major != 1U)
 *   {
 *     // Probably, not the right version.
 *   }
 *   while(1);
 *   return 0;
 * }
 * @endcode
 */
DAVE_APP_VERSION_t MOTOR_LIB_GetAppVersion(void);

/**
  * @brief Returns the magnitude of resultant vector in circular mode.
  * @param x  Input X/k co-ordinate value
  * @param y  Input Y/k co-ordinate value
  * @return  Magnitude of resultant vector in circular mode <BR>
  *
  * \par<b>Description</b><br>
  * This function returns the magnitude of resultant vector in circular mode.\n
  * Magnitude  = SQRT(x*x+y*y); where k = 1.64767 \n
  *
  * \par<b>Note</b><br>
  * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic and linear functions.
  *
  * Example Usage:
  * @code
  * #include "DAVE.h"
  * int main (void)
  * {
  *   uint32_t magnitude;
  *   int16_t angle;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   magnitude = MOTOR_LIB_ResultantMagnitudeCircular(1000,400);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
uint32_t MOTOR_LIB_ResultantMagnitudeCircular(int32_t x,int32_t y);

/**
  * @brief Returns the magnitude of resultant vector in hyperbolic mode.
  * @param x  Input X/k co-ordinate value
  * @param y  Input Y/k co-ordinate value
  * @return  Magnitude of resultant vector in hyperbolic mode <BR>
  *
  * \par<b>Description</b><br>
  * This function returns the magnitude of resultant vector in hyperbolic mode.\n
  * Magnitude  = SQRT(x*x-y*y); where k = 0.828159360960 \n
  *
  * \par<b>Note</b><br>
  * On XMC13 device this API will use HW CORDIC module for computation of trigonometric, hyperbolic and linear functions. \n
  * x should be greater than y.
  *
  * Example Usage:
  * 
  * @code
  * #include "DAVE.h"
  * 
  * int main (void)
  * {
  *   uint32_t magnitude;
  *   int16_t angle;
  *   DAVE_STATUS_t status;
  *   status = DAVE_Init();
  *   magnitude = MOTOR_LIB_ResultantMagnitudeHyperbolic(1000,400);
  *   while(1);
  *   return 0;
  * }
  * @endcode
  */
uint32_t MOTOR_LIB_ResultantMagnitudeHyperbolic(int32_t x,int32_t y);

/**
 * @}
 */

/*Limits the input value based on higher_limit and lower_limit*/
static inline int32_t MOTOR_LIB_MinMaxLimiter(int32_t input_val,int32_t higher_limit,int32_t lower_limit)
{
  int32_t return_val;
  if ( input_val > higher_limit )
  {
    return_val = higher_limit;
  }
  else if ( input_val < lower_limit )
  {
    return_val = lower_limit;
  }
  else
  {
    return_val = input_val;
  }
  return return_val;
}

 /*Limits the 64 bit input value based on higher_limit and lower_limit*/
 static inline int64_t MOTOR_LIB_MinMaxLimiter64(int64_t input_val,int64_t higher_limit,int64_t lower_limit)
 {
   int64_t return_val;
   if ( input_val > higher_limit )
   {
     return_val = higher_limit;
   }
   else if ( input_val < lower_limit )
   {
     return_val = lower_limit;
   }
   else
   {
     return_val = input_val;
   }
   return return_val;
 }

/*This is used to find out the absolute value*/
static inline uint32_t MOTOR_LIB_abs(int32_t x)
{
  int32_t return_val;
  if(x > 0)
  {
    return_val = x;
  }
  else
  {
    return_val = (-x);
  }
  return ((uint32_t)return_val);
}

#ifdef __cplusplus
}
#endif
#endif /* MOTOR_LIB_H_ */
