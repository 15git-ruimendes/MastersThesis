   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "arm_mat_inverse_f32.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.arm_mat_inverse_f32,"ax",%progbits
  20              	 .align 2
  21              	 .global arm_mat_inverse_f32
  22              	 .thumb
  23              	 .thumb_func
  25              	arm_mat_inverse_f32:
  26              	.LFB149:
  27              	 .file 1 "../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c"
   1:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** /* ----------------------------------------------------------------------
   2:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * Project:      CMSIS DSP Library
   3:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * Title:        arm_mat_inverse_f32.c
   4:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * Description:  Floating-point matrix inverse
   5:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  *
   6:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * $Date:        18. March 2019
   7:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * $Revision:    V1.6.0
   8:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  *
   9:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * Target Processor: Cortex-M cores
  10:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * -------------------------------------------------------------------- */
  11:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** /*
  12:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * Copyright (C) 2010-2019 ARM Limited or its affiliates. All rights reserved.
  13:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  14:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * SPDX-License-Identifier: Apache-2.0
  15:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  16:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * not use this file except in compliance with the License.
  18:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * You may obtain a copy of the License at
  19:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  20:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * www.apache.org/licenses/LICENSE-2.0
  21:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  22:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * Unless required by applicable law or agreed to in writing, software
  23:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * See the License for the specific language governing permissions and
  26:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  * limitations under the License.
  27:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  28:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  29:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #include "CMSIS_DSP/cmsis_dsp.h"
  30:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  31:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  32:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   @ingroup groupMatrix
  33:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  34:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  35:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  36:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   @defgroup MatrixInv Matrix Inverse
  37:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  38:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   Computes the inverse of a matrix.
  39:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  40:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   The inverse is defined only if the input matrix is square and non-singular (the determinant is no
  41:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   The function checks that the input and output matrices are square and of the same size.
  42:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  43:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   Matrix inversion is numerically sensitive and the CMSIS DSP library only supports matrix
  44:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   inversion of floating-point matrices.
  45:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  46:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   @par Algorithm
  47:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   The Gauss-Jordan method is used to find the inverse.
  48:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   The algorithm performs a sequence of elementary row-operations until it
  49:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   reduces the input matrix to an identity matrix. Applying the same sequence
  50:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   of elementary row-operations to an identity matrix yields the inverse matrix.
  51:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   If the input matrix is singular, then the algorithm terminates and returns error status
  52:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   <code>ARM_MATH_SINGULAR</code>.
  53:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   \image html MatrixInverse.gif "Matrix Inverse of a 3 x 3 matrix using Gauss-Jordan Method"
  54:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  55:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  56:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  57:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   @addtogroup MatrixInv
  58:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   @{
  59:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  60:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  61:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  62:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   @brief         Floating-point matrix inverse.
  63:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   @param[in]     pSrc      points to input matrix structure. The source matrix is modified by the f
  64:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   @param[out]    pDst      points to output matrix structure
  65:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   @return        execution status
  66:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                    - \ref ARM_MATH_SUCCESS       : Operation successful
  67:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                    - \ref ARM_MATH_SIZE_MISMATCH : Matrix size check failed
  68:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                    - \ref ARM_MATH_SINGULAR      : Input matrix is found to be singular (non-invert
  69:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  70:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #if defined(ARM_MATH_MVEF) && !defined(ARM_MATH_AUTOVECTORIZE)
  71:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  72:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** arm_status arm_mat_inverse_f32(
  73:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   const arm_matrix_instance_f32 * pSrc,
  74:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_matrix_instance_f32 * pDst)
  75:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** {
  76:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     float32_t *pIn = pSrc->pData;   /* input data matrix pointer */
  77:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     float32_t *pOut = pDst->pData;  /* output data matrix pointer */
  78:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     float32_t *pInT1, *pInT2;   /* Temporary input data matrix pointer */
  79:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     float32_t *pOutT1, *pOutT2; /* Temporary output data matrix pointer */
  80:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     float32_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;    /* Temporary input and output d
  81:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  82:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     uint32_t  numRows = pSrc->numRows;  /* Number of rows in the matrix  */
  83:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     uint32_t  numCols = pSrc->numCols;  /* Number of Cols in the matrix  */
  84:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     float32_t *pTmpA, *pTmpB;
  85:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  86:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     float32_t in = 0.0f;        /* Temporary input values  */
  87:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     uint32_t  i, rowCnt, flag = 0U, j, loopCnt, k, l;   /* loop counters */
  88:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     arm_status status;          /* status of matrix inverse */
  89:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     uint32_t  blkCnt;
  90:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
  91:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #ifdef ARM_MATH_MATRIX_CHECK
  92:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    /* Check for matrix mismatch condition */
  93:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   if ((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
  94:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      || (pSrc->numRows != pDst->numRows))
  95:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   {
  96:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
  97:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SIZE_MISMATCH;
  98:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   }
  99:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   else
 100:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
 101:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 102:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 103:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /*---------------------------------------------------------------------------------------------
 104:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      * Matrix Inverse can be solved using elementary row operations.
 105:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
 106:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *  Gauss-Jordan Method:
 107:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
 108:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *     1. First combine the identity matrix and the input matrix separated by a bar to form an
 109:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *        augmented matrix as follows:
 110:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                      _  _          _     _      _   _         _         _
 111:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                     |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |
 112:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                     |  |            | | |        |   |   =   |           |
 113:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                     |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|
 114:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
 115:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      2. In our implementation, pDst Matrix is used as identity matrix.
 116:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
 117:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      3. Begin with the first row. Let i = 1.
 118:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
 119:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      4. Check to see if the pivot for row i is zero.
 120:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         The pivot is the element of the main diagonal that is on the current row.
 121:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         For instance, if working with row i, then the pivot element is aii.
 122:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         If the pivot is zero, exchange that row with a row below it that does not
 123:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         contain a zero in column i. If this is not possible, then an inverse
 124:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         to that matrix does not exist.
 125:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
 126:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      5. Divide every element of row i by the pivot.
 127:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
 128:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      6. For every row below and  row i, replace that row with the sum of that row and
 129:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         a multiple of row i so that each new element in column i below row i is zero.
 130:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
 131:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
 132:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         for every element below and above the main diagonal.
 133:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
 134:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      8. Now an identical matrix is formed to the left of the bar(input matrix, src).
 135:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).
 136:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *---------------------------------------------------------------------------------------------
 137:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 138:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /*
 139:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * Working pointer for destination matrix
 140:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          */
 141:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         pOutT1 = pOut;
 142:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /*
 143:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * Loop over the number of rows
 144:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          */
 145:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         rowCnt = numRows;
 146:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /*
 147:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * Making the destination matrix as identity matrix
 148:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          */
 149:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         while (rowCnt > 0U)
 150:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 151:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 152:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Writing all zeroes in lower triangle of the destination matrix
 153:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 154:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j = numRows - rowCnt;
 155:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             while (j > 0U)
 156:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 157:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 *pOutT1++ = 0.0f;
 158:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 j--;
 159:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 160:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 161:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Writing all ones in the diagonal of the destination matrix
 162:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 163:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             *pOutT1++ = 1.0f;
 164:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 165:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Writing all zeroes in upper triangle of the destination matrix
 166:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 167:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j = rowCnt - 1U;
 168:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             while (j > 0U)
 169:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 170:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 *pOutT1++ = 0.0f;
 171:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 j--;
 172:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 173:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 174:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Decrement the loop counter
 175:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 176:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             rowCnt--;
 177:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 178:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 179:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /*
 180:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * Loop over the number of columns of the input matrix.
 181:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * All the elements in each column are processed by the row operations
 182:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          */
 183:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         loopCnt = numCols;
 184:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /*
 185:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * Index modifier to navigate through the columns
 186:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          */
 187:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         l = 0U;
 188:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         while (loopCnt > 0U)
 189:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 190:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 191:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Check if the pivot element is zero..
 192:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * If it is zero then interchange the row with non zero row below.
 193:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * If there is no non zero element to replace in the rows below,
 194:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * then the matrix is Singular.
 195:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 196:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 197:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 198:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Working pointer for the input matrix that points
 199:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * * to the pivot element of the particular row
 200:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 201:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pInT1 = pIn + (l * numCols);
 202:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 203:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Working pointer for the destination matrix that points
 204:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * * to the pivot element of the particular row
 205:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 206:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pOutT1 = pOut + (l * numCols);
 207:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 208:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Temporary variable to hold the pivot value
 209:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 210:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             in = *pInT1;
 211:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 212:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Destination pointer modifier
 213:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 214:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             k = 1U;
 215:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 216:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 217:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Check if the pivot element is zero
 218:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 219:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             if (*pInT1 == 0.0f)
 220:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 221:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 /*
 222:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                  * Loop over the number rows present below
 223:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                  */
 224:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 for (i = (l + 1U); i < numRows; i++)
 225:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 {
 226:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     /*
 227:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * Update the input and destination pointers
 228:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      */
 229:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     pInT2 = pInT1 + (numCols * i);
 230:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     pOutT2 = pOutT1 + (numCols * k);
 231:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     /*
 232:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * Check if there is a non zero pivot element to
 233:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * * replace in the rows below
 234:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      */
 235:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     if (*pInT2 != 0.0f)
 236:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     {
 237:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         f32x4_t vecA, vecB;
 238:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         /*
 239:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * Loop over number of columns
 240:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * * to the right of the pilot element
 241:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          */
 242:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pTmpA = pInT1;
 243:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pTmpB = pInT2;
 244:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         blkCnt = (numCols - l) >> 2;
 245:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         while (blkCnt > 0U)
 246:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         {
 247:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             
 248:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vecA = vldrwq_f32(pTmpA);
 249:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vecB = vldrwq_f32(pTmpB);
 250:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vstrwq_f32(pTmpB, vecA);
 251:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vstrwq_f32(pTmpA, vecB);
 252:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 253:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             pTmpA += 4;
 254:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             pTmpB += 4;
 255:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             /*
 256:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                              * Decrement the blockSize loop counter
 257:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                              */
 258:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             blkCnt--;
 259:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         }
 260:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         /*
 261:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * tail
 262:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * (will be merged thru tail predication)
 263:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          */
 264:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         blkCnt = (numCols - l) & 3;
 265:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         if (blkCnt > 0U)
 266:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         {
 267:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             mve_pred16_t p0 = vctp32q(blkCnt);
 268:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 269:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vecA = vldrwq_f32(pTmpA);
 270:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vecB = vldrwq_f32(pTmpB);
 271:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vstrwq_p_f32(pTmpB, vecA, p0);
 272:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vstrwq_p_f32(pTmpA, vecB, p0);
 273:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         }
 274:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 275:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pInT1 += numCols - l;
 276:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pInT2 += numCols - l;
 277:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pTmpA = pOutT1;
 278:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pTmpB = pOutT2;
 279:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         blkCnt = numCols >> 2;
 280:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         while (blkCnt > 0U)
 281:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         {
 282:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 283:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vecA = vldrwq_f32(pTmpA);
 284:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vecB = vldrwq_f32(pTmpB);
 285:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vstrwq_f32(pTmpB, vecA);
 286:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vstrwq_f32(pTmpA, vecB);
 287:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             pTmpA += 4;
 288:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             pTmpB += 4;
 289:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             /*
 290:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                              * Decrement the blockSize loop counter
 291:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                              */
 292:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             blkCnt--;
 293:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         }
 294:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         /*
 295:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * tail
 296:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          */
 297:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         blkCnt = numCols & 3;
 298:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         if (blkCnt > 0U)
 299:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         {
 300:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             mve_pred16_t p0 = vctp32q(blkCnt);
 301:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 302:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vecA = vldrwq_f32(pTmpA);
 303:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vecB = vldrwq_f32(pTmpB);
 304:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vstrwq_p_f32(pTmpB, vecA, p0);
 305:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                             vstrwq_p_f32(pTmpA, vecB, p0);
 306:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         }
 307:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 308:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pOutT1 += numCols;
 309:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pOutT2 += numCols;
 310:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         /*
 311:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * Flag to indicate whether exchange is done or not
 312:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          */
 313:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         flag = 1U;
 314:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 315:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         /*
 316:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * Break after exchange is done
 317:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          */
 318:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         break;
 319:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     }
 320:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     /*
 321:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * Update the destination pointer modifier
 322:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      */
 323:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     k++;
 324:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 }
 325:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 326:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 327:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 328:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Update the status if the matrix is singular
 329:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 330:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             if ((flag != 1U) && (in == 0.0f))
 331:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 332:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 return ARM_MATH_SINGULAR;
 333:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 334:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 335:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 336:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Points to the pivot row of input and destination matrices
 337:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 338:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pPivotRowIn = pIn + (l * numCols);
 339:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pPivotRowDst = pOut + (l * numCols);
 340:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 341:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 342:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Temporary pointers to the pivot row pointers
 343:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 344:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pInT1 = pPivotRowIn;
 345:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pOutT1 = pPivotRowDst;
 346:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 347:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 348:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Pivot element of the row
 349:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 350:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             in = *(pIn + (l * numCols));
 351:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 352:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pTmpA = pInT1;
 353:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 354:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             f32x4_t invIn = vdupq_n_f32(1.0f / in);
 355:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 356:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             blkCnt = (numCols - l) >> 2;
 357:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             f32x4_t vecA;
 358:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             while (blkCnt > 0U)
 359:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 360:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 *(f32x4_t *) pTmpA = *(f32x4_t *) pTmpA * invIn;
 361:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 pTmpA += 4;
 362:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 /*
 363:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                  * Decrement the blockSize loop counter
 364:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                  */
 365:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 blkCnt--;
 366:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 367:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 368:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * tail
 369:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 370:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             blkCnt = (numCols - l) & 3;
 371:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             if (blkCnt > 0U)
 372:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 373:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 mve_pred16_t p0 = vctp32q(blkCnt);
 374:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 
 375:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 376:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 vecA = vldrwq_f32(pTmpA);
 377:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 vecA = vecA * invIn;
 378:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 vstrwq_p_f32(pTmpA, vecA, p0);
 379:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 380:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 381:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pInT1 += numCols - l;
 382:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 383:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Loop over number of columns
 384:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * * to the right of the pilot element
 385:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 386:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 387:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pTmpA = pOutT1;
 388:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             blkCnt = numCols >> 2;
 389:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             while (blkCnt > 0U)
 390:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 391:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 *(f32x4_t *) pTmpA = *(f32x4_t *) pTmpA *invIn;
 392:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 pTmpA += 4;
 393:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 /*
 394:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                  * Decrement the blockSize loop counter
 395:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                  */
 396:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 blkCnt--;
 397:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 398:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 399:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * tail
 400:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * (will be merged thru tail predication)
 401:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 402:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             blkCnt = numCols & 3;
 403:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             if (blkCnt > 0U)
 404:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 405:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 mve_pred16_t p0 = vctp32q(blkCnt);
 406:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 407:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 vecA = vldrwq_f32(pTmpA);
 408:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 vecA = vecA * invIn;
 409:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 vstrwq_p_f32(pTmpA, vecA, p0);
 410:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 411:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 412:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pOutT1 += numCols;
 413:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 414:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 415:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Replace the rows with the sum of that row and a multiple of row i
 416:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * * so that each new element in column i above row i is zero.
 417:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 418:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 419:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 420:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Temporary pointers for input and destination matrices
 421:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 422:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pInT1 = pIn;
 423:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pOutT1 = pOut;
 424:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 425:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             for (i = 0U; i < numRows; i++)
 426:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 427:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 /*
 428:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                  * Check for the pivot element
 429:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                  */
 430:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 if (i == l)
 431:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 {
 432:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     /*
 433:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * If the processing element is the pivot element,
 434:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * only the columns to the right are to be processed
 435:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      */
 436:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     pInT1 += numCols - l;
 437:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     pOutT1 += numCols;
 438:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 }
 439:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 else
 440:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 {
 441:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     /*
 442:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * Element of the reference row
 443:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      */
 444:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 445:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     /*
 446:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * Working pointers for input and destination pivot rows
 447:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      */
 448:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     pPRT_in = pPivotRowIn;
 449:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     pPRT_pDst = pPivotRowDst;
 450:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     /*
 451:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * Loop over the number of columns to the right of the pivot element,
 452:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * to replace the elements in the input matrix
 453:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      */
 454:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 455:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     in = *pInT1;
 456:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     f32x4_t tmpV = vdupq_n_f32(in);
 457:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 458:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     blkCnt = (numCols - l) >> 2;
 459:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     while (blkCnt > 0U)
 460:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     {
 461:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         f32x4_t vec1, vec2;
 462:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         /*
 463:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * Replace the element by the sum of that row
 464:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * and a multiple of the reference row
 465:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          */
 466:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec1 = vldrwq_f32(pInT1);
 467:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec2 = vldrwq_f32(pPRT_in);
 468:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec1 = vfmsq_f32(vec1, tmpV, vec2);
 469:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vstrwq_f32(pInT1, vec1);
 470:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pPRT_in += 4;
 471:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pInT1 += 4;
 472:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         /*
 473:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * Decrement the blockSize loop counter
 474:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          */
 475:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         blkCnt--;
 476:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     }
 477:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     /*
 478:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * tail
 479:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * (will be merged thru tail predication)
 480:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      */
 481:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     blkCnt = (numCols - l) & 3;
 482:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     if (blkCnt > 0U)
 483:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     {
 484:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         f32x4_t vec1, vec2;
 485:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         mve_pred16_t p0 = vctp32q(blkCnt);
 486:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 487:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec1 = vldrwq_f32(pInT1);
 488:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec2 = vldrwq_f32(pPRT_in);
 489:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec1 = vfmsq_f32(vec1, tmpV, vec2);
 490:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vstrwq_p_f32(pInT1, vec1, p0);
 491:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pInT1 += blkCnt;
 492:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     }
 493:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 494:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     blkCnt = numCols >> 2;
 495:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     while (blkCnt > 0U)
 496:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     {
 497:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         f32x4_t vec1, vec2;
 498:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 499:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         /*
 500:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * Replace the element by the sum of that row
 501:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * and a multiple of the reference row
 502:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          */
 503:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec1 = vldrwq_f32(pOutT1);
 504:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec2 = vldrwq_f32(pPRT_pDst);
 505:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec1 = vfmsq_f32(vec1, tmpV, vec2);
 506:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vstrwq_f32(pOutT1, vec1);
 507:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pPRT_pDst += 4;
 508:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pOutT1 += 4;
 509:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         /*
 510:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          * Decrement the blockSize loop counter
 511:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                          */
 512:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         blkCnt--;
 513:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     }
 514:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     /*
 515:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * tail
 516:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      * (will be merged thru tail predication)
 517:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                      */
 518:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     blkCnt = numCols & 3;
 519:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     if (blkCnt > 0U)
 520:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     {
 521:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         f32x4_t vec1, vec2;
 522:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         mve_pred16_t p0 = vctp32q(blkCnt);
 523:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 524:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec1 = vldrwq_f32(pOutT1);
 525:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec2 = vldrwq_f32(pPRT_pDst);
 526:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vec1 = vfmsq_f32(vec1, tmpV, vec2);
 527:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         vstrwq_p_f32(pOutT1, vec1, p0);
 528:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 529:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pInT2 += blkCnt;
 530:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                         pOutT1 += blkCnt;
 531:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     }
 532:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 }
 533:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 /*
 534:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                  * Increment the temporary input pointer
 535:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                  */
 536:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 pInT1 = pInT1 + l;
 537:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 538:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 539:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Increment the input pointer
 540:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 541:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pIn++;
 542:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 543:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Decrement the loop counter
 544:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 545:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             loopCnt--;
 546:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /*
 547:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * Increment the index modifier
 548:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              */
 549:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             l++;
 550:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 551:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 552:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /*
 553:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * Set status as ARM_MATH_SUCCESS
 554:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          */
 555:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         status = ARM_MATH_SUCCESS;
 556:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 557:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         if ((flag != 1U) && (in == 0.0f))
 558:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 559:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pIn = pSrc->pData;
 560:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             for (i = 0; i < numRows * numCols; i++)
 561:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 562:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 if (pIn[i] != 0.0f)
 563:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                     break;
 564:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 565:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 566:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             if (i == numRows * numCols)
 567:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                 status = ARM_MATH_SINGULAR;
 568:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 569:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 570:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Return to application */
 571:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   return (status);
 572:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** }
 573:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 574:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #else
 575:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #if defined(ARM_MATH_NEON)
 576:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** arm_status arm_mat_inverse_f32(
 577:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   const arm_matrix_instance_f32 * pSrc,
 578:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_matrix_instance_f32 * pDst)
 579:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** {
 580:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
 581:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 582:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
 583:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
 584:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data 
 585:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
 586:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
 587:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 588:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 589:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t Xchg, in = 0.0f, in1;                /* Temporary input values  */
 590:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t i, rowCnt, flag = 0U, j, loopCnt, k, l;      /* loop counters */
 591:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_status status;                             /* status of matrix inverse */
 592:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32x4_t vec1;
 593:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32x4_t vec2;
 594:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32x4_t tmpV;
 595:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 596:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #ifdef ARM_MATH_MATRIX_CHECK
 597:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 598:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Check for matrix mismatch condition */
 599:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   if ((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
 600:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      || (pSrc->numRows != pDst->numRows))
 601:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 602:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
 603:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SIZE_MISMATCH;
 604:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 605:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   else
 606:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
 607:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 608:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 609:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    /*----------------------------------------------------------------------------------------------
 610:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    * Matrix Inverse can be solved using elementary row operations.
 611:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *
 612:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *  Gauss-Jordan Method:
 613:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *
 614:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *     1. First combine the identity matrix and the input matrix separated by a bar to form an
 615:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *        augmented matrix as follows:
 616:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *              _                  _         _         _
 617:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *             |  a11  a12 | 1   0  |       |  X11 X12  |
 618:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *             |           |        |   =   |           |
 619:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *             |_ a21  a22 | 0   1 _|       |_ X21 X21 _|
 620:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *
 621:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *    2. In our implementation, pDst Matrix is used as identity matrix.
 622:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *
 623:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *    3. Begin with the first row. Let i = 1.
 624:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *
 625:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *    4. Check to see if the pivot for row i is zero.
 626:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *       The pivot is the element of the main diagonal that is on the current row.
 627:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *       For instance, if working with row i, then the pivot element is aii.
 628:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *       If the pivot is zero, exchange that row with a row below it that does not
 629:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *       contain a zero in column i. If this is not possible, then an inverse
 630:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *       to that matrix does not exist.
 631:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *
 632:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *      5. Divide every element of row i by the pivot.
 633:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *
 634:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *      6. For every row below and  row i, replace that row with the sum of that row and
 635:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *       a multiple of row i so that each new element in column i below row i is zero.
 636:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *
 637:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *      7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
 638:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *       for every element below and above the main diagonal.
 639:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *
 640:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *    8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).
 641:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *       Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).
 642:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****    *-----------------------------------------------------------------------------------------------
 643:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 644:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Working pointer for destination matrix */
 645:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     pOutT1 = pOut;
 646:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 647:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of rows */
 648:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     rowCnt = numRows;
 649:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 650:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Making the destination matrix as identity matrix */
 651:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     while (rowCnt > 0U)
 652:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 653:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in lower triangle of the destination matrix */
 654:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numRows - rowCnt;
 655:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 656:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 657:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 658:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 659:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 660:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 661:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all ones in the diagonal of the destination matrix */
 662:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       *pOutT1++ = 1.0f;
 663:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 664:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in upper triangle of the destination matrix */
 665:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = rowCnt - 1U;
 666:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 667:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 668:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 669:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 670:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 671:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 672:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 673:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 674:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       rowCnt--;
 675:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 676:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 677:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of columns of the input matrix.
 678:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        All the elements in each column are processed by the row operations */
 679:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     loopCnt = numCols;
 680:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 681:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Index modifier to navigate through the columns */
 682:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     l = 0U;
 683:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 684:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     while (loopCnt > 0U)
 685:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 686:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero..
 687:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * If it is zero then interchange the row with non zero row below.
 688:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * If there is no non zero element to replace in the rows below,
 689:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * then the matrix is Singular. */
 690:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 691:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the input matrix that points
 692:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 693:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn + (l * numCols);
 694:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 695:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the destination matrix that points
 696:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 697:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut + (l * numCols);
 698:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 699:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary variable to hold the pivot value */
 700:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pInT1;
 701:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 702:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     
 703:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Destination pointer modifier */
 704:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       k = 1U;
 705:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 706:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero */
 707:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       if (*pInT1 == 0.0f)
 708:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 709:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Loop over the number rows present below */
 710:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         for (i = (l + 1U); i < numRows; i++)
 711:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 712:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the input and destination pointers */
 713:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 = pInT1 + (numCols * i);
 714:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT2 = pOutT1 + (numCols * k);
 715:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 716:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Check if there is a non zero pivot element to
 717:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****            * replace in the rows below */
 718:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           if (*pInT2 != 0.0f)
 719:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 720:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns
 721:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * to the right of the pilot element */
 722:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j = numCols - l;
 723:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 724:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             while (j > 0U)
 725:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 726:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the input matrix */
 727:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pInT2;
 728:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT2++ = *pInT1;
 729:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT1++ = Xchg;
 730:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 731:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Decrement the loop counter */
 732:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               j--;
 733:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 734:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 735:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns of the destination matrix */
 736:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j = numCols;
 737:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 738:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             while (j > 0U)
 739:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 740:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the destination matrix */
 741:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pOutT2;
 742:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT2++ = *pOutT1;
 743:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT1++ = Xchg;
 744:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 745:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Decrement the loop counter */
 746:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               j--;
 747:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 748:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 749:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Flag to indicate whether exchange is done or not */
 750:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             flag = 1U;
 751:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 752:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Break after exchange is done */
 753:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 754:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 755:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 756:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the destination pointer modifier */
 757:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           k++;
 758:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 759:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 760:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 761:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
 762:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       if ((flag != 1U) && (in == 0.0f))
 763:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 764:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
 765:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 766:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 767:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Points to the pivot row of input and destination matrices */
 768:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowIn = pIn + (l * numCols);
 769:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowDst = pOut + (l * numCols);
 770:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 771:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers to the pivot row pointers */
 772:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pPivotRowIn;
 773:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT2 = pPivotRowDst;
 774:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 775:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Pivot element of the row */
 776:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pPivotRowIn;
 777:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       tmpV = vdupq_n_f32(1.0f/in);
 778:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 779:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns
 780:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the right of the pilot element */
 781:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = (numCols - l) >> 2;
 782:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 783:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 784:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 785:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the input matrix
 786:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 787:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         vec1 = vld1q_f32(pInT1);
 788:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 789:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         vec1 = vmulq_f32(vec1, tmpV);
 790:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         vst1q_f32(pInT1, vec1);
 791:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 += 4;
 792:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 793:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 794:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 795:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 796:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 797:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Tail */
 798:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = (numCols - l) & 3;
 799:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 800:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 801:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 802:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the input matrix
 803:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 804:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         in1 = *pInT1;
 805:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT1++ = in1 / in;
 806:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 807:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 808:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 809:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 810:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 811:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns of the destination matrix */
 812:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numCols >> 2;
 813:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 814:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 815:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 816:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the destination matrix
 817:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 818:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         vec1 = vld1q_f32(pInT2);
 819:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 820:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         vec1 = vmulq_f32(vec1, tmpV);
 821:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         vst1q_f32(pInT2, vec1);
 822:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT2 += 4;
 823:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       
 824:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 825:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 826:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 827:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 828:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Tail */
 829:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numCols & 3;
 830:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 831:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 832:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 833:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the destination matrix
 834:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 835:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         in1 = *pInT2;
 836:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT2++ = in1 / in;
 837:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 838:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 839:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 840:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 841:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 842:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Replace the rows with the sum of that row and a multiple of row i
 843:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * so that each new element in column i above row i is zero.*/
 844:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 845:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers for input and destination matrices */
 846:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
 847:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT2 = pOut;
 848:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 849:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* index used to check for pivot element */
 850:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       i = 0U;
 851:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 852:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of rows */
 853:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /*  to be replaced by the sum of that row and a multiple of row i */
 854:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       k = numRows;
 855:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 856:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (k > 0U)
 857:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 858:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Check for the pivot element */
 859:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         if (i == l)
 860:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 861:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* If the processing element is the pivot element,
 862:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              only the columns to the right are to be processed */
 863:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT1 += numCols - l;
 864:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 865:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 += numCols;
 866:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 867:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         else
 868:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 869:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Element of the reference row */
 870:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           in = *pInT1;
 871:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           tmpV = vdupq_n_f32(in);
 872:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 873:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Working pointers for input and destination pivot rows */
 874:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_in = pPivotRowIn;
 875:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_pDst = pPivotRowDst;
 876:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 877:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to the right of the pivot element,
 878:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              to replace the elements in the input matrix */
 879:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           j = (numCols - l) >> 2;
 880:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 	  
 881:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           while (j > 0U)
 882:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 883:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 884:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 885:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             vec1 = vld1q_f32(pInT1);
 886:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             vec2 = vld1q_f32(pPRT_in);
 887:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             vec1 = vmlsq_f32(vec1, tmpV, vec2);
 888:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             vst1q_f32(pInT1, vec1);
 889:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pPRT_in += 4;
 890:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pInT1 += 4;
 891:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 892:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement the loop counter */
 893:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 894:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 895:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 896:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 	  /* Tail */
 897:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           j = (numCols - l) & 3;
 898:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 899:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           while (j > 0U)
 900:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 901:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 902:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 903:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             in1 = *pInT1;
 904:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT1++ = in1 - (in * *pPRT_in++);
 905:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 906:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement the loop counter */
 907:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 908:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 909:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 910:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to
 911:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              replace the elements in the destination matrix */
 912:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           j = numCols >> 2;
 913:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 914:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           while (j > 0U)
 915:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 916:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 917:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 918:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             vec1 = vld1q_f32(pInT2);
 919:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             vec2 = vld1q_f32(pPRT_pDst);
 920:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             vec1 = vmlsq_f32(vec1, tmpV, vec2);
 921:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             vst1q_f32(pInT2, vec1);
 922:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pPRT_pDst += 4;
 923:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pInT2 += 4;
 924:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 925:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement the loop counter */
 926:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 927:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 928:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 929:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 	  /* Tail */
 930:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           j = numCols & 3;
 931:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 932:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           while (j > 0U)
 933:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 934:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 935:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 936:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             in1 = *pInT2;
 937:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT2++ = in1 - (in * *pPRT_pDst++);
 938:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 939:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement the loop counter */
 940:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 941:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 942:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 943:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 944:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 945:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment the temporary input pointer */
 946:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 = pInT1 + l;
 947:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 948:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 949:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         k--;
 950:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 951:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment the pivot index */
 952:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         i++;
 953:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 954:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 955:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the input pointer */
 956:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn++;
 957:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 958:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 959:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       loopCnt--;
 960:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 961:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the index modifier */
 962:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       l++;
 963:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 964:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 965:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SUCCESS */
 966:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SUCCESS;
 967:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 968:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     if ((flag != 1U) && (in == 0.0f))
 969:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 970:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn = pSrc->pData;
 971:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0; i < numRows * numCols; i++)
 972:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 973:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         if (pIn[i] != 0.0f)
 974:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 975:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 976:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 977:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       if (i == numRows * numCols)
 978:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         status = ARM_MATH_SINGULAR;
 979:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 980:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 981:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Return to application */
 982:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   return (status);
 983:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** }
 984:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #else
 985:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** arm_status arm_mat_inverse_f32(
 986:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   const arm_matrix_instance_f32 * pSrc,
 987:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         arm_matrix_instance_f32 * pDst)
 988:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** {
  28              	 .loc 1 988 0
  29              	 .cfi_startproc
  30              	 
  31              	 
  32              	 
  33 0000 80B4     	 push {r7}
  34              	.LCFI0:
  35              	 .cfi_def_cfa_offset 4
  36              	 .cfi_offset 7,-4
  37 0002 9BB0     	 sub sp,sp,#108
  38              	.LCFI1:
  39              	 .cfi_def_cfa_offset 112
  40 0004 00AF     	 add r7,sp,#0
  41              	.LCFI2:
  42              	 .cfi_def_cfa_register 7
  43 0006 7860     	 str r0,[r7,#4]
  44 0008 3960     	 str r1,[r7]
 989:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
  45              	 .loc 1 989 0
  46 000a 7B68     	 ldr r3,[r7,#4]
  47 000c 5B68     	 ldr r3,[r3,#4]
  48 000e 7B66     	 str r3,[r7,#100]
 990:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
  49              	 .loc 1 990 0
  50 0010 3B68     	 ldr r3,[r7]
  51 0012 5B68     	 ldr r3,[r3,#4]
  52 0014 7B62     	 str r3,[r7,#36]
 991:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
 992:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
 993:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data 
 994:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
  53              	 .loc 1 994 0
  54 0016 7B68     	 ldr r3,[r7,#4]
  55 0018 1B88     	 ldrh r3,[r3]
  56 001a 3B62     	 str r3,[r7,#32]
 995:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
  57              	 .loc 1 995 0
  58 001c 7B68     	 ldr r3,[r7,#4]
  59 001e 5B88     	 ldrh r3,[r3,#2]
  60 0020 FB61     	 str r3,[r7,#28]
 996:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 997:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #if defined (ARM_MATH_DSP)
 998:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
 999:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t Xchg, in = 0.0f, in1;                /* Temporary input values  */
  61              	 .loc 1 999 0
  62 0022 4FF00003 	 mov r3,#0
  63 0026 BB64     	 str r3,[r7,#72]
1000:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t i, rowCnt, flag = 0U, j, loopCnt, k, l;      /* loop counters */
  64              	 .loc 1 1000 0
  65 0028 0023     	 movs r3,#0
  66 002a FB63     	 str r3,[r7,#60]
1001:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_status status;                             /* status of matrix inverse */
1002:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1003:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #ifdef ARM_MATH_MATRIX_CHECK
1004:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1005:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Check for matrix mismatch condition */
1006:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   if ((pSrc->numRows != pSrc->numCols) ||
  67              	 .loc 1 1006 0
  68 002c 7B68     	 ldr r3,[r7,#4]
  69 002e 1A88     	 ldrh r2,[r3]
  70 0030 7B68     	 ldr r3,[r7,#4]
  71 0032 5B88     	 ldrh r3,[r3,#2]
  72 0034 9A42     	 cmp r2,r3
  73 0036 0BD1     	 bne .L2
1007:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       (pDst->numRows != pDst->numCols) ||
  74              	 .loc 1 1007 0 discriminator 1
  75 0038 3B68     	 ldr r3,[r7]
  76 003a 1A88     	 ldrh r2,[r3]
  77 003c 3B68     	 ldr r3,[r7]
  78 003e 5B88     	 ldrh r3,[r3,#2]
1006:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       (pDst->numRows != pDst->numCols) ||
  79              	 .loc 1 1006 0 discriminator 1
  80 0040 9A42     	 cmp r2,r3
  81 0042 05D1     	 bne .L2
1008:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       (pSrc->numRows != pDst->numRows)   )
  82              	 .loc 1 1008 0
  83 0044 7B68     	 ldr r3,[r7,#4]
  84 0046 1A88     	 ldrh r2,[r3]
  85 0048 3B68     	 ldr r3,[r7]
  86 004a 1B88     	 ldrh r3,[r3]
1007:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       (pDst->numRows != pDst->numCols) ||
  87              	 .loc 1 1007 0
  88 004c 9A42     	 cmp r2,r3
  89 004e 03D0     	 beq .L3
  90              	.L2:
1009:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   {
1010:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
1011:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SIZE_MISMATCH;
  91              	 .loc 1 1011 0
  92 0050 FD23     	 movs r3,#253
  93 0052 87F82B30 	 strb r3,[r7,#43]
  94 0056 ACE1     	 b .L4
  95              	.L3:
1012:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   }
1013:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   else
1014:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1015:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /* #ifdef ARM_MATH_MATRIX_CHECK */
1016:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1017:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   {
1018:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1019:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /*---------------------------------------------------------------------------------------------
1020:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      * Matrix Inverse can be solved using elementary row operations.
1021:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1022:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *  Gauss-Jordan Method:
1023:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1024:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      1. First combine the identity matrix and the input matrix separated by a bar to form an
1025:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *        augmented matrix as follows:
1026:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                      _                  _         _         _
1027:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                     |  a11  a12 | 1   0  |       |  X11 X12  |
1028:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                     |           |        |   =   |           |
1029:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                     |_ a21  a22 | 0   1 _|       |_ X21 X21 _|
1030:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1031:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      2. In our implementation, pDst Matrix is used as identity matrix.
1032:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1033:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      3. Begin with the first row. Let i = 1.
1034:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1035:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      4. Check to see if the pivot for row i is zero.
1036:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         The pivot is the element of the main diagonal that is on the current row.
1037:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         For instance, if working with row i, then the pivot element is aii.
1038:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         If the pivot is zero, exchange that row with a row below it that does not
1039:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         contain a zero in column i. If this is not possible, then an inverse
1040:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         to that matrix does not exist.
1041:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1042:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      5. Divide every element of row i by the pivot.
1043:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1044:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      6. For every row below and  row i, replace that row with the sum of that row and
1045:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         a multiple of row i so that each new element in column i below row i is zero.
1046:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1047:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
1048:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         for every element below and above the main diagonal.
1049:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1050:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).
1051:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).
1052:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *---------------------------------------------------------------------------------------------
1053:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1054:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Working pointer for destination matrix */
1055:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     pOutT1 = pOut;
  96              	 .loc 1 1055 0
  97 0058 7B6A     	 ldr r3,[r7,#36]
  98 005a BB65     	 str r3,[r7,#88]
1056:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1057:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of rows */
1058:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     rowCnt = numRows;
  99              	 .loc 1 1058 0
 100 005c 3B6A     	 ldr r3,[r7,#32]
 101 005e 3B64     	 str r3,[r7,#64]
1059:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1060:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Making the destination matrix as identity matrix */
1061:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     while (rowCnt > 0U)
 102              	 .loc 1 1061 0
 103 0060 29E0     	 b .L5
 104              	.L10:
1062:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     {
1063:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in lower triangle of the destination matrix */
1064:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numRows - rowCnt;
 105              	 .loc 1 1064 0
 106 0062 3A6A     	 ldr r2,[r7,#32]
 107 0064 3B6C     	 ldr r3,[r7,#64]
 108 0066 D31A     	 subs r3,r2,r3
 109 0068 BB63     	 str r3,[r7,#56]
1065:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 110              	 .loc 1 1065 0
 111 006a 08E0     	 b .L6
 112              	.L7:
1066:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1067:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 113              	 .loc 1 1067 0
 114 006c BB6D     	 ldr r3,[r7,#88]
 115 006e 1A1D     	 adds r2,r3,#4
 116 0070 BA65     	 str r2,[r7,#88]
 117 0072 4FF00002 	 mov r2,#0
 118 0076 1A60     	 str r2,[r3]
1068:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 119              	 .loc 1 1068 0
 120 0078 BB6B     	 ldr r3,[r7,#56]
 121 007a 013B     	 subs r3,r3,#1
 122 007c BB63     	 str r3,[r7,#56]
 123              	.L6:
1065:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 124              	 .loc 1 1065 0
 125 007e BB6B     	 ldr r3,[r7,#56]
 126 0080 002B     	 cmp r3,#0
 127 0082 F3D1     	 bne .L7
1069:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1070:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1071:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all ones in the diagonal of the destination matrix */
1072:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       *pOutT1++ = 1.0f;
 128              	 .loc 1 1072 0
 129 0084 BB6D     	 ldr r3,[r7,#88]
 130 0086 1A1D     	 adds r2,r3,#4
 131 0088 BA65     	 str r2,[r7,#88]
 132 008a 4FF07E52 	 mov r2,#1065353216
 133 008e 1A60     	 str r2,[r3]
1073:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1074:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in upper triangle of the destination matrix */
1075:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = rowCnt - 1U;
 134              	 .loc 1 1075 0
 135 0090 3B6C     	 ldr r3,[r7,#64]
 136 0092 013B     	 subs r3,r3,#1
 137 0094 BB63     	 str r3,[r7,#56]
1076:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 138              	 .loc 1 1076 0
 139 0096 08E0     	 b .L8
 140              	.L9:
1077:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1078:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 141              	 .loc 1 1078 0
 142 0098 BB6D     	 ldr r3,[r7,#88]
 143 009a 1A1D     	 adds r2,r3,#4
 144 009c BA65     	 str r2,[r7,#88]
 145 009e 4FF00002 	 mov r2,#0
 146 00a2 1A60     	 str r2,[r3]
1079:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 147              	 .loc 1 1079 0
 148 00a4 BB6B     	 ldr r3,[r7,#56]
 149 00a6 013B     	 subs r3,r3,#1
 150 00a8 BB63     	 str r3,[r7,#56]
 151              	.L8:
1076:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 152              	 .loc 1 1076 0
 153 00aa BB6B     	 ldr r3,[r7,#56]
 154 00ac 002B     	 cmp r3,#0
 155 00ae F3D1     	 bne .L9
1080:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1081:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1082:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement loop counter */
1083:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       rowCnt--;
 156              	 .loc 1 1083 0
 157 00b0 3B6C     	 ldr r3,[r7,#64]
 158 00b2 013B     	 subs r3,r3,#1
 159 00b4 3B64     	 str r3,[r7,#64]
 160              	.L5:
1061:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 161              	 .loc 1 1061 0
 162 00b6 3B6C     	 ldr r3,[r7,#64]
 163 00b8 002B     	 cmp r3,#0
 164 00ba D2D1     	 bne .L10
1084:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     }
1085:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1086:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of columns of the input matrix.
1087:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        All the elements in each column are processed by the row operations */
1088:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     loopCnt = numCols;
 165              	 .loc 1 1088 0
 166 00bc FB69     	 ldr r3,[r7,#28]
 167 00be 7B63     	 str r3,[r7,#52]
1089:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1090:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Index modifier to navigate through the columns */
1091:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     l = 0U;
 168              	 .loc 1 1091 0
 169 00c0 0023     	 movs r3,#0
 170 00c2 FB62     	 str r3,[r7,#44]
1092:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1093:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     while (loopCnt > 0U)
 171              	 .loc 1 1093 0
 172 00c4 3EE1     	 b .L11
 173              	.L34:
1094:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     {
1095:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero..
1096:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * If it is zero then interchange the row with non zero row below.
1097:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * If there is no non zero element to replace in the rows below,
1098:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * then the matrix is Singular. */
1099:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1100:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the input matrix that points
1101:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
1102:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn + (l * numCols);
 174              	 .loc 1 1102 0
 175 00c6 FB6A     	 ldr r3,[r7,#44]
 176 00c8 FA69     	 ldr r2,[r7,#28]
 177 00ca 02FB03F3 	 mul r3,r2,r3
 178 00ce 9B00     	 lsls r3,r3,#2
 179 00d0 7A6E     	 ldr r2,[r7,#100]
 180 00d2 1344     	 add r3,r3,r2
 181 00d4 3B66     	 str r3,[r7,#96]
1103:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1104:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the destination matrix that points
1105:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
1106:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut + (l * numCols);
 182              	 .loc 1 1106 0
 183 00d6 FB6A     	 ldr r3,[r7,#44]
 184 00d8 FA69     	 ldr r2,[r7,#28]
 185 00da 02FB03F3 	 mul r3,r2,r3
 186 00de 9B00     	 lsls r3,r3,#2
 187 00e0 7A6A     	 ldr r2,[r7,#36]
 188 00e2 1344     	 add r3,r3,r2
 189 00e4 BB65     	 str r3,[r7,#88]
1107:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1108:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary variable to hold the pivot value */
1109:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pInT1;
 190              	 .loc 1 1109 0
 191 00e6 3B6E     	 ldr r3,[r7,#96]
 192 00e8 1B68     	 ldr r3,[r3]
 193 00ea BB64     	 str r3,[r7,#72]
1110:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1111:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       
1112:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Destination pointer modifier */
1113:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       k = 1U;
 194              	 .loc 1 1113 0
 195 00ec 0123     	 movs r3,#1
 196 00ee 3B63     	 str r3,[r7,#48]
1114:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1115:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero */
1116:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       if (*pInT1 == 0.0f)
 197              	 .loc 1 1116 0
 198 00f0 3B6E     	 ldr r3,[r7,#96]
 199 00f2 D3ED007A 	 flds s15,[r3]
 200 00f6 F5EE407A 	 fcmpzs s15
 201 00fa F1EE10FA 	 fmstat
 202 00fe 58D1     	 bne .L12
1117:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1118:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Loop over the number rows present below */
1119:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1120:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         for (i = (l + 1U); i < numRows; i++)
 203              	 .loc 1 1120 0
 204 0100 FB6A     	 ldr r3,[r7,#44]
 205 0102 0133     	 adds r3,r3,#1
 206 0104 7B64     	 str r3,[r7,#68]
 207 0106 50E0     	 b .L13
 208              	.L19:
1121:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
1122:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the input and destination pointers */
1123:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 = pInT1 + (numCols * i);
 209              	 .loc 1 1123 0
 210 0108 FB69     	 ldr r3,[r7,#28]
 211 010a 7A6C     	 ldr r2,[r7,#68]
 212 010c 02FB03F3 	 mul r3,r2,r3
 213 0110 9B00     	 lsls r3,r3,#2
 214 0112 3A6E     	 ldr r2,[r7,#96]
 215 0114 1344     	 add r3,r3,r2
 216 0116 FB65     	 str r3,[r7,#92]
1124:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT2 = pOutT1 + (numCols * k);
 217              	 .loc 1 1124 0
 218 0118 FB69     	 ldr r3,[r7,#28]
 219 011a 3A6B     	 ldr r2,[r7,#48]
 220 011c 02FB03F3 	 mul r3,r2,r3
 221 0120 9B00     	 lsls r3,r3,#2
 222 0122 BA6D     	 ldr r2,[r7,#88]
 223 0124 1344     	 add r3,r3,r2
 224 0126 7B65     	 str r3,[r7,#84]
1125:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1126:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Check if there is a non zero pivot element to
1127:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****            * replace in the rows below */
1128:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           if (*pInT2 != 0.0f)
 225              	 .loc 1 1128 0
 226 0128 FB6D     	 ldr r3,[r7,#92]
 227 012a D3ED007A 	 flds s15,[r3]
 228 012e F5EE407A 	 fcmpzs s15
 229 0132 F1EE10FA 	 fmstat
 230 0136 32D0     	 beq .L14
1129:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
1130:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns
1131:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * to the right of the pilot element */
1132:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j = numCols - l;
 231              	 .loc 1 1132 0
 232 0138 FA69     	 ldr r2,[r7,#28]
 233 013a FB6A     	 ldr r3,[r7,#44]
 234 013c D31A     	 subs r3,r2,r3
 235 013e BB63     	 str r3,[r7,#56]
1133:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1134:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             while (j > 0U)
 236              	 .loc 1 1134 0
 237 0140 10E0     	 b .L15
 238              	.L16:
1135:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
1136:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the input matrix */
1137:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pInT2;
 239              	 .loc 1 1137 0
 240 0142 FB6D     	 ldr r3,[r7,#92]
 241 0144 1B68     	 ldr r3,[r3]
 242 0146 BB61     	 str r3,[r7,#24]
1138:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT2++ = *pInT1;
 243              	 .loc 1 1138 0
 244 0148 FB6D     	 ldr r3,[r7,#92]
 245 014a 1A1D     	 adds r2,r3,#4
 246 014c FA65     	 str r2,[r7,#92]
 247 014e 3A6E     	 ldr r2,[r7,#96]
 248 0150 1268     	 ldr r2,[r2]
 249 0152 1A60     	 str r2,[r3]
1139:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT1++ = Xchg;
 250              	 .loc 1 1139 0
 251 0154 3B6E     	 ldr r3,[r7,#96]
 252 0156 1A1D     	 adds r2,r3,#4
 253 0158 3A66     	 str r2,[r7,#96]
 254 015a BA69     	 ldr r2,[r7,#24]
 255 015c 1A60     	 str r2,[r3]
1140:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1141:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Decrement the loop counter */
1142:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               j--;
 256              	 .loc 1 1142 0
 257 015e BB6B     	 ldr r3,[r7,#56]
 258 0160 013B     	 subs r3,r3,#1
 259 0162 BB63     	 str r3,[r7,#56]
 260              	.L15:
1134:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 261              	 .loc 1 1134 0
 262 0164 BB6B     	 ldr r3,[r7,#56]
 263 0166 002B     	 cmp r3,#0
 264 0168 EBD1     	 bne .L16
1143:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
1144:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1145:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns of the destination matrix */
1146:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j = numCols;
 265              	 .loc 1 1146 0
 266 016a FB69     	 ldr r3,[r7,#28]
 267 016c BB63     	 str r3,[r7,#56]
1147:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1148:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             while (j > 0U)
 268              	 .loc 1 1148 0
 269 016e 10E0     	 b .L17
 270              	.L18:
1149:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
1150:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the destination matrix */
1151:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pOutT2;
 271              	 .loc 1 1151 0
 272 0170 7B6D     	 ldr r3,[r7,#84]
 273 0172 1B68     	 ldr r3,[r3]
 274 0174 BB61     	 str r3,[r7,#24]
1152:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT2++ = *pOutT1;
 275              	 .loc 1 1152 0
 276 0176 7B6D     	 ldr r3,[r7,#84]
 277 0178 1A1D     	 adds r2,r3,#4
 278 017a 7A65     	 str r2,[r7,#84]
 279 017c BA6D     	 ldr r2,[r7,#88]
 280 017e 1268     	 ldr r2,[r2]
 281 0180 1A60     	 str r2,[r3]
1153:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT1++ = Xchg;
 282              	 .loc 1 1153 0
 283 0182 BB6D     	 ldr r3,[r7,#88]
 284 0184 1A1D     	 adds r2,r3,#4
 285 0186 BA65     	 str r2,[r7,#88]
 286 0188 BA69     	 ldr r2,[r7,#24]
 287 018a 1A60     	 str r2,[r3]
1154:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1155:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Decrement loop counter */
1156:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               j--;
 288              	 .loc 1 1156 0
 289 018c BB6B     	 ldr r3,[r7,#56]
 290 018e 013B     	 subs r3,r3,#1
 291 0190 BB63     	 str r3,[r7,#56]
 292              	.L17:
1148:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 293              	 .loc 1 1148 0
 294 0192 BB6B     	 ldr r3,[r7,#56]
 295 0194 002B     	 cmp r3,#0
 296 0196 EBD1     	 bne .L18
1157:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
1158:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1159:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Flag to indicate whether exchange is done or not */
1160:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             flag = 1U;
 297              	 .loc 1 1160 0
 298 0198 0123     	 movs r3,#1
 299 019a FB63     	 str r3,[r7,#60]
1161:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1162:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Break after exchange is done */
1163:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 300              	 .loc 1 1163 0
 301 019c 09E0     	 b .L12
 302              	.L14:
1164:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           }
1165:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1166:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the destination pointer modifier */
1167:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           k++;
 303              	 .loc 1 1167 0 discriminator 2
 304 019e 3B6B     	 ldr r3,[r7,#48]
 305 01a0 0133     	 adds r3,r3,#1
 306 01a2 3B63     	 str r3,[r7,#48]
1120:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 307              	 .loc 1 1120 0 discriminator 2
 308 01a4 7B6C     	 ldr r3,[r7,#68]
 309 01a6 0133     	 adds r3,r3,#1
 310 01a8 7B64     	 str r3,[r7,#68]
 311              	.L13:
1120:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 312              	 .loc 1 1120 0 is_stmt 0 discriminator 1
 313 01aa 7A6C     	 ldr r2,[r7,#68]
 314 01ac 3B6A     	 ldr r3,[r7,#32]
 315 01ae 9A42     	 cmp r2,r3
 316 01b0 AAD3     	 bcc .L19
 317              	.L12:
1168:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1169:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Decrement loop counter */
1170:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
1171:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1172:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1173:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
1174:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       if ((flag != 1U) && (in == 0.0f))
 318              	 .loc 1 1174 0 is_stmt 1
 319 01b2 FB6B     	 ldr r3,[r7,#60]
 320 01b4 012B     	 cmp r3,#1
 321 01b6 08D0     	 beq .L20
 322              	 .loc 1 1174 0 is_stmt 0 discriminator 1
 323 01b8 D7ED127A 	 flds s15,[r7,#72]
 324 01bc F5EE407A 	 fcmpzs s15
 325 01c0 F1EE10FA 	 fmstat
 326 01c4 01D1     	 bne .L20
1175:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1176:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
 327              	 .loc 1 1176 0 is_stmt 1
 328 01c6 FB23     	 movs r3,#251
 329 01c8 F5E0     	 b .L21
 330              	.L20:
1177:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1178:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1179:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Points to the pivot row of input and destination matrices */
1180:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowIn = pIn + (l * numCols);
 331              	 .loc 1 1180 0
 332 01ca FB6A     	 ldr r3,[r7,#44]
 333 01cc FA69     	 ldr r2,[r7,#28]
 334 01ce 02FB03F3 	 mul r3,r2,r3
 335 01d2 9B00     	 lsls r3,r3,#2
 336 01d4 7A6E     	 ldr r2,[r7,#100]
 337 01d6 1344     	 add r3,r3,r2
 338 01d8 7B61     	 str r3,[r7,#20]
1181:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowDst = pOut + (l * numCols);
 339              	 .loc 1 1181 0
 340 01da FB6A     	 ldr r3,[r7,#44]
 341 01dc FA69     	 ldr r2,[r7,#28]
 342 01de 02FB03F3 	 mul r3,r2,r3
 343 01e2 9B00     	 lsls r3,r3,#2
 344 01e4 7A6A     	 ldr r2,[r7,#36]
 345 01e6 1344     	 add r3,r3,r2
 346 01e8 3B61     	 str r3,[r7,#16]
1182:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1183:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers to the pivot row pointers */
1184:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pPivotRowIn;
 347              	 .loc 1 1184 0
 348 01ea 7B69     	 ldr r3,[r7,#20]
 349 01ec 3B66     	 str r3,[r7,#96]
1185:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT2 = pPivotRowDst;
 350              	 .loc 1 1185 0
 351 01ee 3B69     	 ldr r3,[r7,#16]
 352 01f0 FB65     	 str r3,[r7,#92]
1186:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1187:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Pivot element of the row */
1188:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pPivotRowIn;
 353              	 .loc 1 1188 0
 354 01f2 7B69     	 ldr r3,[r7,#20]
 355 01f4 1B68     	 ldr r3,[r3]
 356 01f6 BB64     	 str r3,[r7,#72]
1189:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1190:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns
1191:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the right of the pilot element */
1192:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = (numCols - l);
 357              	 .loc 1 1192 0
 358 01f8 FA69     	 ldr r2,[r7,#28]
 359 01fa FB6A     	 ldr r3,[r7,#44]
 360 01fc D31A     	 subs r3,r2,r3
 361 01fe BB63     	 str r3,[r7,#56]
1193:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1194:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 362              	 .loc 1 1194 0
 363 0200 10E0     	 b .L22
 364              	.L23:
1195:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1196:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the input matrix
1197:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
1198:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         in1 = *pInT1;
 365              	 .loc 1 1198 0
 366 0202 3B6E     	 ldr r3,[r7,#96]
 367 0204 1B68     	 ldr r3,[r3]
 368 0206 FB60     	 str r3,[r7,#12]
1199:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT1++ = in1 / in;
 369              	 .loc 1 1199 0
 370 0208 3B6E     	 ldr r3,[r7,#96]
 371 020a 1A1D     	 adds r2,r3,#4
 372 020c 3A66     	 str r2,[r7,#96]
 373 020e 97ED037A 	 flds s14,[r7,#12]
 374 0212 D7ED127A 	 flds s15,[r7,#72]
 375 0216 C7EE277A 	 fdivs s15,s14,s15
 376 021a C3ED007A 	 fsts s15,[r3]
1200:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1201:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
1202:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 377              	 .loc 1 1202 0
 378 021e BB6B     	 ldr r3,[r7,#56]
 379 0220 013B     	 subs r3,r3,#1
 380 0222 BB63     	 str r3,[r7,#56]
 381              	.L22:
1194:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 382              	 .loc 1 1194 0
 383 0224 BB6B     	 ldr r3,[r7,#56]
 384 0226 002B     	 cmp r3,#0
 385 0228 EBD1     	 bne .L23
1203:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1204:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1205:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns of the destination matrix */
1206:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numCols;
 386              	 .loc 1 1206 0
 387 022a FB69     	 ldr r3,[r7,#28]
 388 022c BB63     	 str r3,[r7,#56]
1207:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1208:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
 389              	 .loc 1 1208 0
 390 022e 10E0     	 b .L24
 391              	.L25:
1209:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1210:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the destination matrix
1211:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
1212:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         in1 = *pInT2;
 392              	 .loc 1 1212 0
 393 0230 FB6D     	 ldr r3,[r7,#92]
 394 0232 1B68     	 ldr r3,[r3]
 395 0234 FB60     	 str r3,[r7,#12]
1213:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT2++ = in1 / in;
 396              	 .loc 1 1213 0
 397 0236 FB6D     	 ldr r3,[r7,#92]
 398 0238 1A1D     	 adds r2,r3,#4
 399 023a FA65     	 str r2,[r7,#92]
 400 023c 97ED037A 	 flds s14,[r7,#12]
 401 0240 D7ED127A 	 flds s15,[r7,#72]
 402 0244 C7EE277A 	 fdivs s15,s14,s15
 403 0248 C3ED007A 	 fsts s15,[r3]
1214:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1215:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
1216:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 404              	 .loc 1 1216 0
 405 024c BB6B     	 ldr r3,[r7,#56]
 406 024e 013B     	 subs r3,r3,#1
 407 0250 BB63     	 str r3,[r7,#56]
 408              	.L24:
1208:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 409              	 .loc 1 1208 0
 410 0252 BB6B     	 ldr r3,[r7,#56]
 411 0254 002B     	 cmp r3,#0
 412 0256 EBD1     	 bne .L25
1217:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1218:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1219:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Replace the rows with the sum of that row and a multiple of row i
1220:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * so that each new element in column i above row i is zero.*/
1221:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1222:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers for input and destination matrices */
1223:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
 413              	 .loc 1 1223 0
 414 0258 7B6E     	 ldr r3,[r7,#100]
 415 025a 3B66     	 str r3,[r7,#96]
1224:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT2 = pOut;
 416              	 .loc 1 1224 0
 417 025c 7B6A     	 ldr r3,[r7,#36]
 418 025e FB65     	 str r3,[r7,#92]
1225:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1226:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* index used to check for pivot element */
1227:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       i = 0U;
 419              	 .loc 1 1227 0
 420 0260 0023     	 movs r3,#0
 421 0262 7B64     	 str r3,[r7,#68]
1228:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1229:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of rows */
1230:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /*  to be replaced by the sum of that row and a multiple of row i */
1231:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       k = numRows;
 422              	 .loc 1 1231 0
 423 0264 3B6A     	 ldr r3,[r7,#32]
 424 0266 3B63     	 str r3,[r7,#48]
1232:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1233:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (k > 0U)
 425              	 .loc 1 1233 0
 426 0268 60E0     	 b .L26
 427              	.L33:
1234:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1235:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Check for the pivot element */
1236:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         if (i == l)
 428              	 .loc 1 1236 0
 429 026a 7A6C     	 ldr r2,[r7,#68]
 430 026c FB6A     	 ldr r3,[r7,#44]
 431 026e 9A42     	 cmp r2,r3
 432 0270 0CD1     	 bne .L27
1237:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
1238:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* If the processing element is the pivot element,
1239:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              only the columns to the right are to be processed */
1240:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT1 += numCols - l;
 433              	 .loc 1 1240 0
 434 0272 FA69     	 ldr r2,[r7,#28]
 435 0274 FB6A     	 ldr r3,[r7,#44]
 436 0276 D31A     	 subs r3,r2,r3
 437 0278 9B00     	 lsls r3,r3,#2
 438 027a 3A6E     	 ldr r2,[r7,#96]
 439 027c 1344     	 add r3,r3,r2
 440 027e 3B66     	 str r3,[r7,#96]
1241:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1242:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 += numCols;
 441              	 .loc 1 1242 0
 442 0280 FB69     	 ldr r3,[r7,#28]
 443 0282 9B00     	 lsls r3,r3,#2
 444 0284 FA6D     	 ldr r2,[r7,#92]
 445 0286 1344     	 add r3,r3,r2
 446 0288 FB65     	 str r3,[r7,#92]
 447 028a 44E0     	 b .L28
 448              	.L27:
1243:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
1244:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         else
1245:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
1246:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Element of the reference row */
1247:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           in = *pInT1;
 449              	 .loc 1 1247 0
 450 028c 3B6E     	 ldr r3,[r7,#96]
 451 028e 1B68     	 ldr r3,[r3]
 452 0290 BB64     	 str r3,[r7,#72]
1248:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1249:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Working pointers for input and destination pivot rows */
1250:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_in = pPivotRowIn;
 453              	 .loc 1 1250 0
 454 0292 7B69     	 ldr r3,[r7,#20]
 455 0294 3B65     	 str r3,[r7,#80]
1251:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_pDst = pPivotRowDst;
 456              	 .loc 1 1251 0
 457 0296 3B69     	 ldr r3,[r7,#16]
 458 0298 FB64     	 str r3,[r7,#76]
1252:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1253:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to the right of the pivot element,
1254:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              to replace the elements in the input matrix */
1255:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           j = (numCols - l);
 459              	 .loc 1 1255 0
 460 029a FA69     	 ldr r2,[r7,#28]
 461 029c FB6A     	 ldr r3,[r7,#44]
 462 029e D31A     	 subs r3,r2,r3
 463 02a0 BB63     	 str r3,[r7,#56]
1256:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1257:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           while (j > 0U)
 464              	 .loc 1 1257 0
 465 02a2 17E0     	 b .L29
 466              	.L30:
1258:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
1259:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
1260:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
1261:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             in1 = *pInT1;
 467              	 .loc 1 1261 0
 468 02a4 3B6E     	 ldr r3,[r7,#96]
 469 02a6 1B68     	 ldr r3,[r3]
 470 02a8 FB60     	 str r3,[r7,#12]
1262:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT1++ = in1 - (in * *pPRT_in++);
 471              	 .loc 1 1262 0
 472 02aa 3B6E     	 ldr r3,[r7,#96]
 473 02ac 1A1D     	 adds r2,r3,#4
 474 02ae 3A66     	 str r2,[r7,#96]
 475 02b0 3A6D     	 ldr r2,[r7,#80]
 476 02b2 111D     	 adds r1,r2,#4
 477 02b4 3965     	 str r1,[r7,#80]
 478 02b6 92ED007A 	 flds s14,[r2]
 479 02ba D7ED127A 	 flds s15,[r7,#72]
 480 02be 67EE277A 	 fmuls s15,s14,s15
 481 02c2 97ED037A 	 flds s14,[r7,#12]
 482 02c6 77EE677A 	 fsubs s15,s14,s15
 483 02ca C3ED007A 	 fsts s15,[r3]
1263:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1264:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement the loop counter */
1265:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 484              	 .loc 1 1265 0
 485 02ce BB6B     	 ldr r3,[r7,#56]
 486 02d0 013B     	 subs r3,r3,#1
 487 02d2 BB63     	 str r3,[r7,#56]
 488              	.L29:
1257:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 489              	 .loc 1 1257 0
 490 02d4 BB6B     	 ldr r3,[r7,#56]
 491 02d6 002B     	 cmp r3,#0
 492 02d8 E4D1     	 bne .L30
1266:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           }
1267:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1268:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to
1269:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              replace the elements in the destination matrix */
1270:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           j = numCols;
 493              	 .loc 1 1270 0
 494 02da FB69     	 ldr r3,[r7,#28]
 495 02dc BB63     	 str r3,[r7,#56]
1271:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1272:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           while (j > 0U)
 496              	 .loc 1 1272 0
 497 02de 17E0     	 b .L31
 498              	.L32:
1273:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
1274:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
1275:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
1276:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             in1 = *pInT2;
 499              	 .loc 1 1276 0
 500 02e0 FB6D     	 ldr r3,[r7,#92]
 501 02e2 1B68     	 ldr r3,[r3]
 502 02e4 FB60     	 str r3,[r7,#12]
1277:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT2++ = in1 - (in * *pPRT_pDst++);
 503              	 .loc 1 1277 0
 504 02e6 FB6D     	 ldr r3,[r7,#92]
 505 02e8 1A1D     	 adds r2,r3,#4
 506 02ea FA65     	 str r2,[r7,#92]
 507 02ec FA6C     	 ldr r2,[r7,#76]
 508 02ee 111D     	 adds r1,r2,#4
 509 02f0 F964     	 str r1,[r7,#76]
 510 02f2 92ED007A 	 flds s14,[r2]
 511 02f6 D7ED127A 	 flds s15,[r7,#72]
 512 02fa 67EE277A 	 fmuls s15,s14,s15
 513 02fe 97ED037A 	 flds s14,[r7,#12]
 514 0302 77EE677A 	 fsubs s15,s14,s15
 515 0306 C3ED007A 	 fsts s15,[r3]
1278:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1279:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement loop counter */
1280:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 516              	 .loc 1 1280 0
 517 030a BB6B     	 ldr r3,[r7,#56]
 518 030c 013B     	 subs r3,r3,#1
 519 030e BB63     	 str r3,[r7,#56]
 520              	.L31:
1272:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 521              	 .loc 1 1272 0
 522 0310 BB6B     	 ldr r3,[r7,#56]
 523 0312 002B     	 cmp r3,#0
 524 0314 E4D1     	 bne .L32
 525              	.L28:
1281:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           }
1282:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1283:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
1284:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1285:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment temporary input pointer */
1286:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 = pInT1 + l;
 526              	 .loc 1 1286 0
 527 0316 FB6A     	 ldr r3,[r7,#44]
 528 0318 9B00     	 lsls r3,r3,#2
 529 031a 3A6E     	 ldr r2,[r7,#96]
 530 031c 1344     	 add r3,r3,r2
 531 031e 3B66     	 str r3,[r7,#96]
1287:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1288:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement loop counter */
1289:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         k--;
 532              	 .loc 1 1289 0
 533 0320 3B6B     	 ldr r3,[r7,#48]
 534 0322 013B     	 subs r3,r3,#1
 535 0324 3B63     	 str r3,[r7,#48]
1290:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1291:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment pivot index */
1292:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         i++;
 536              	 .loc 1 1292 0
 537 0326 7B6C     	 ldr r3,[r7,#68]
 538 0328 0133     	 adds r3,r3,#1
 539 032a 7B64     	 str r3,[r7,#68]
 540              	.L26:
1233:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 541              	 .loc 1 1233 0
 542 032c 3B6B     	 ldr r3,[r7,#48]
 543 032e 002B     	 cmp r3,#0
 544 0330 9BD1     	 bne .L33
1293:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1294:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1295:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the input pointer */
1296:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn++;
 545              	 .loc 1 1296 0
 546 0332 7B6E     	 ldr r3,[r7,#100]
 547 0334 0433     	 adds r3,r3,#4
 548 0336 7B66     	 str r3,[r7,#100]
1297:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1298:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
1299:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       loopCnt--;
 549              	 .loc 1 1299 0
 550 0338 7B6B     	 ldr r3,[r7,#52]
 551 033a 013B     	 subs r3,r3,#1
 552 033c 7B63     	 str r3,[r7,#52]
1300:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1301:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the index modifier */
1302:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       l++;
 553              	 .loc 1 1302 0
 554 033e FB6A     	 ldr r3,[r7,#44]
 555 0340 0133     	 adds r3,r3,#1
 556 0342 FB62     	 str r3,[r7,#44]
 557              	.L11:
1093:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 558              	 .loc 1 1093 0
 559 0344 7B6B     	 ldr r3,[r7,#52]
 560 0346 002B     	 cmp r3,#0
 561 0348 7FF4BDAE 	 bne .L34
1303:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     }
1304:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1305:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1306:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #else
1307:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1308:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t Xchg, in = 0.0f;                     /* Temporary input values  */
1309:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t i, rowCnt, flag = 0U, j, loopCnt, k, l;      /* loop counters */
1310:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_status status;                             /* status of matrix inverse */
1311:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1312:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #ifdef ARM_MATH_MATRIX_CHECK
1313:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1314:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Check for matrix mismatch condition */
1315:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   if ((pSrc->numRows != pSrc->numCols) ||
1316:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       (pDst->numRows != pDst->numCols) ||
1317:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       (pSrc->numRows != pDst->numRows)   )
1318:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   {
1319:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
1320:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SIZE_MISMATCH;
1321:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   }
1322:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   else
1323:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1324:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /* #ifdef ARM_MATH_MATRIX_CHECK */
1325:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1326:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   {
1327:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1328:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /*---------------------------------------------------------------------------------------------
1329:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      * Matrix Inverse can be solved using elementary row operations.
1330:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1331:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *  Gauss-Jordan Method:
1332:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1333:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      1. First combine the identity matrix and the input matrix separated by a bar to form an
1334:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *        augmented matrix as follows:
1335:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                      _  _          _     _      _   _         _         _
1336:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                     |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |
1337:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                     |  |            | | |        |   |   =   |           |
1338:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *                     |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|
1339:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1340:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      2. In our implementation, pDst Matrix is used as identity matrix.
1341:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1342:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      3. Begin with the first row. Let i = 1.
1343:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1344:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      4. Check to see if the pivot for row i is zero.
1345:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         The pivot is the element of the main diagonal that is on the current row.
1346:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         For instance, if working with row i, then the pivot element is aii.
1347:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         If the pivot is zero, exchange that row with a row below it that does not
1348:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         contain a zero in column i. If this is not possible, then an inverse
1349:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         to that matrix does not exist.
1350:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1351:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      5. Divide every element of row i by the pivot.
1352:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1353:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      6. For every row below and  row i, replace that row with the sum of that row and
1354:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         a multiple of row i so that each new element in column i below row i is zero.
1355:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1356:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
1357:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         for every element below and above the main diagonal.
1358:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *
1359:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *      8. Now an identical matrix is formed to the left of the bar(input matrix, src).
1360:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *         Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).
1361:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****      *---------------------------------------------------------------------------------------------
1362:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1363:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Working pointer for destination matrix */
1364:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     pOutT1 = pOut;
1365:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1366:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of rows */
1367:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     rowCnt = numRows;
1368:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1369:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Making the destination matrix as identity matrix */
1370:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     while (rowCnt > 0U)
1371:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     {
1372:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in lower triangle of the destination matrix */
1373:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numRows - rowCnt;
1374:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
1375:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1376:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
1377:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
1378:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1379:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1380:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all ones in the diagonal of the destination matrix */
1381:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       *pOutT1++ = 1.0f;
1382:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1383:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in upper triangle of the destination matrix */
1384:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       j = rowCnt - 1U;
1385:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0U)
1386:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1387:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
1388:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
1389:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1390:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1391:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement loop counter */
1392:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       rowCnt--;
1393:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     }
1394:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1395:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of columns of the input matrix.
1396:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        All the elements in each column are processed by the row operations */
1397:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     loopCnt = numCols;
1398:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1399:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Index modifier to navigate through the columns */
1400:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     l = 0U;
1401:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1402:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     while (loopCnt > 0U)
1403:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     {
1404:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero..
1405:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * If it is zero then interchange the row with non zero row below.
1406:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * If there is no non zero element to replace in the rows below,
1407:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * then the matrix is Singular. */
1408:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1409:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the input matrix that points
1410:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
1411:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn + (l * numCols);
1412:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1413:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the destination matrix that points
1414:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
1415:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut + (l * numCols);
1416:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1417:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary variable to hold the pivot value */
1418:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pInT1;
1419:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1420:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Destination pointer modifier */
1421:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       k = 1U;
1422:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1423:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero */
1424:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       if (*pInT1 == 0.0f)
1425:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1426:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Loop over the number rows present below */
1427:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         for (i = (l + 1U); i < numRows; i++)
1428:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
1429:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the input and destination pointers */
1430:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 = pInT1 + (numCols * i);
1431:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT2 = pOutT1 + (numCols * k);
1432:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1433:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Check if there is a non zero pivot element to
1434:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****            * replace in the rows below */
1435:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           if (*pInT2 != 0.0f)
1436:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
1437:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns
1438:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              * to the right of the pilot element */
1439:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             for (j = 0U; j < (numCols - l); j++)
1440:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
1441:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the input matrix */
1442:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pInT2;
1443:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT2++ = *pInT1;
1444:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT1++ = Xchg;
1445:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
1446:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1447:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             for (j = 0U; j < numCols; j++)
1448:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             {
1449:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pOutT2;
1450:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT2++ = *pOutT1;
1451:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT1++ = Xchg;
1452:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             }
1453:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1454:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Flag to indicate whether exchange is done or not */
1455:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             flag = 1U;
1456:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1457:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Break after exchange is done */
1458:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
1459:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           }
1460:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1461:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the destination pointer modifier */
1462:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           k++;
1463:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
1464:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1465:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1466:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
1467:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       if ((flag != 1U) && (in == 0.0f))
1468:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1469:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
1470:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1471:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1472:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Points to the pivot row of input and destination matrices */
1473:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowIn = pIn + (l * numCols);
1474:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowDst = pOut + (l * numCols);
1475:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1476:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers to the pivot row pointers */
1477:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pPivotRowIn;
1478:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pPivotRowDst;
1479:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1480:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Pivot element of the row */
1481:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *(pIn + (l * numCols));
1482:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1483:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns
1484:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the right of the pilot element */
1485:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       for (j = 0U; j < (numCols - l); j++)
1486:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1487:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the input matrix
1488:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
1489:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT1 = *pInT1 / in;
1490:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1++;
1491:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1492:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       for (j = 0U; j < numCols; j++)
1493:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1494:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the destination matrix
1495:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
1496:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1 = *pOutT1 / in;
1497:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         pOutT1++;
1498:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1499:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1500:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Replace the rows with the sum of that row and a multiple of row i
1501:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****        * so that each new element in column i above row i is zero.*/
1502:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1503:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers for input and destination matrices */
1504:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
1505:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut;
1506:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1507:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0U; i < numRows; i++)
1508:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1509:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Check for the pivot element */
1510:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         if (i == l)
1511:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
1512:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* If the processing element is the pivot element,
1513:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              only the columns to the right are to be processed */
1514:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT1 += numCols - l;
1515:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT1 += numCols;
1516:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
1517:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         else
1518:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         {
1519:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Element of the reference row */
1520:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           in = *pInT1;
1521:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1522:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Working pointers for input and destination pivot rows */
1523:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_in = pPivotRowIn;
1524:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_pDst = pPivotRowDst;
1525:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1526:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to the right of the pivot element,
1527:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              to replace the elements in the input matrix */
1528:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           for (j = 0U; j < (numCols - l); j++)
1529:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
1530:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
1531:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
1532:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT1 = *pInT1 - (in * *pPRT_in++);
1533:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pInT1++;
1534:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           }
1535:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1536:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to
1537:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****              replace the elements in the destination matrix */
1538:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           for (j = 0U; j < numCols; j++)
1539:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           {
1540:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
1541:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
1542:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             *pOutT1 = *pOutT1 - (in * *pPRT_pDst++);
1543:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             pOutT1++;
1544:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****           }
1545:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1546:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         }
1547:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1548:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment temporary input pointer */
1549:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 = pInT1 + l;
1550:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1551:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1552:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the input pointer */
1553:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn++;
1554:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1555:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
1556:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       loopCnt--;
1557:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1558:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the index modifier */
1559:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       l++;
1560:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     }
1561:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1562:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /* #if defined (ARM_MATH_DSP) */
1563:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1564:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SUCCESS */
1565:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SUCCESS;
 562              	 .loc 1 1565 0
 563 034c 0023     	 movs r3,#0
 564 034e 87F82B30 	 strb r3,[r7,#43]
1566:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1567:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     if ((flag != 1U) && (in == 0.0f))
 565              	 .loc 1 1567 0
 566 0352 FB6B     	 ldr r3,[r7,#60]
 567 0354 012B     	 cmp r3,#1
 568 0356 2CD0     	 beq .L4
 569              	 .loc 1 1567 0 is_stmt 0 discriminator 1
 570 0358 D7ED127A 	 flds s15,[r7,#72]
 571 035c F5EE407A 	 fcmpzs s15
 572 0360 F1EE10FA 	 fmstat
 573 0364 25D1     	 bne .L4
1568:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     {
1569:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn = pSrc->pData;
 574              	 .loc 1 1569 0 is_stmt 1
 575 0366 7B68     	 ldr r3,[r7,#4]
 576 0368 5B68     	 ldr r3,[r3,#4]
 577 036a 7B66     	 str r3,[r7,#100]
1570:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0; i < numRows * numCols; i++)
 578              	 .loc 1 1570 0
 579 036c 0023     	 movs r3,#0
 580 036e 7B64     	 str r3,[r7,#68]
 581 0370 0EE0     	 b .L35
 582              	.L38:
1571:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       {
1572:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         if (pIn[i] != 0.0f)
 583              	 .loc 1 1572 0
 584 0372 7B6C     	 ldr r3,[r7,#68]
 585 0374 9B00     	 lsls r3,r3,#2
 586 0376 7A6E     	 ldr r2,[r7,#100]
 587 0378 1344     	 add r3,r3,r2
 588 037a D3ED007A 	 flds s15,[r3]
 589 037e F5EE407A 	 fcmpzs s15
 590 0382 F1EE10FA 	 fmstat
 591 0386 00D0     	 beq .L36
1573:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 592              	 .loc 1 1573 0
 593 0388 09E0     	 b .L37
 594              	.L36:
1570:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0; i < numRows * numCols; i++)
 595              	 .loc 1 1570 0 discriminator 2
 596 038a 7B6C     	 ldr r3,[r7,#68]
 597 038c 0133     	 adds r3,r3,#1
 598 038e 7B64     	 str r3,[r7,#68]
 599              	.L35:
1570:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0; i < numRows * numCols; i++)
 600              	 .loc 1 1570 0 is_stmt 0 discriminator 1
 601 0390 3B6A     	 ldr r3,[r7,#32]
 602 0392 FA69     	 ldr r2,[r7,#28]
 603 0394 02FB03F2 	 mul r2,r2,r3
 604 0398 7B6C     	 ldr r3,[r7,#68]
 605 039a 9A42     	 cmp r2,r3
 606 039c E9D8     	 bhi .L38
 607              	.L37:
1574:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       }
1575:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1576:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****       if (i == numRows * numCols)
 608              	 .loc 1 1576 0 is_stmt 1
 609 039e 3B6A     	 ldr r3,[r7,#32]
 610 03a0 FA69     	 ldr r2,[r7,#28]
 611 03a2 02FB03F2 	 mul r2,r2,r3
 612 03a6 7B6C     	 ldr r3,[r7,#68]
 613 03a8 9A42     	 cmp r2,r3
 614 03aa 02D1     	 bne .L4
1577:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****         status = ARM_MATH_SINGULAR;
 615              	 .loc 1 1577 0
 616 03ac FB23     	 movs r3,#251
 617 03ae 87F82B30 	 strb r3,[r7,#43]
 618              	.L4:
1578:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****     }
1579:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   }
1580:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** 
1581:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Return to application */
1582:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c ****   return (status);
 619              	 .loc 1 1582 0
 620 03b2 97F82B30 	 ldrb r3,[r7,#43]
 621              	.L21:
 622 03b6 5BB2     	 sxtb r3,r3
1583:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f32.c **** }
 623              	 .loc 1 1583 0
 624 03b8 1846     	 mov r0,r3
 625 03ba 6C37     	 adds r7,r7,#108
 626              	.LCFI3:
 627              	 .cfi_def_cfa_offset 4
 628 03bc BD46     	 mov sp,r7
 629              	.LCFI4:
 630              	 .cfi_def_cfa_register 13
 631              	 
 632 03be 5DF8047B 	 ldr r7,[sp],#4
 633              	.LCFI5:
 634              	 .cfi_restore 7
 635              	 .cfi_def_cfa_offset 0
 636 03c2 7047     	 bx lr
 637              	 .cfi_endproc
 638              	.LFE149:
 640              	 .text
 641              	.Letext0:
 642              	 .file 2 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 643              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 644              	 .file 4 "C:/Users/Rui Mendes/Desktop/DAVE/_Naive/_ForTesting/Dave/Generated/CMSIS_DSP/Include/arm_math.h"
 645              	 .file 5 "C:/Users/Rui Mendes/Desktop/DAVE/_Naive/_ForTesting/Libraries/CMSIS/Include/cmsis_gcc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 arm_mat_inverse_f32.c
    {standard input}:20     .text.arm_mat_inverse_f32:00000000 $t
    {standard input}:25     .text.arm_mat_inverse_f32:00000000 arm_mat_inverse_f32
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
