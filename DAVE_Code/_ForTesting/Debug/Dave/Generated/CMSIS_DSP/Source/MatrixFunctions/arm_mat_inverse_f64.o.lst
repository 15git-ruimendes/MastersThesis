   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "arm_mat_inverse_f64.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .global __aeabi_dcmpeq
  20              	 .global __aeabi_ddiv
  21              	 .global __aeabi_dmul
  22              	 .global __aeabi_dsub
  23              	 .section .text.arm_mat_inverse_f64,"ax",%progbits
  24              	 .align 2
  25              	 .global arm_mat_inverse_f64
  26              	 .thumb
  27              	 .thumb_func
  29              	arm_mat_inverse_f64:
  30              	.LFB149:
  31              	 .file 1 "../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c"
   1:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** /* ----------------------------------------------------------------------
   2:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * Project:      CMSIS DSP Library
   3:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * Title:        arm_mat_inverse_f64.c
   4:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * Description:  Floating-point matrix inverse
   5:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  *
   6:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * $Date:        18. March 2019
   7:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * $Revision:    V1.6.0
   8:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  *
   9:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * Target Processor: Cortex-M cores
  10:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * -------------------------------------------------------------------- */
  11:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** /*
  12:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * Copyright (C) 2010-2019 ARM Limited or its affiliates. All rights reserved.
  13:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  *
  14:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * SPDX-License-Identifier: Apache-2.0
  15:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  *
  16:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * not use this file except in compliance with the License.
  18:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * You may obtain a copy of the License at
  19:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  *
  20:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * www.apache.org/licenses/LICENSE-2.0
  21:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  *
  22:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * Unless required by applicable law or agreed to in writing, software
  23:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * See the License for the specific language governing permissions and
  26:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  * limitations under the License.
  27:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  */
  28:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  29:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** #include "CMSIS_DSP/cmsis_dsp.h"
  30:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  31:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** /**
  32:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   @ingroup groupMatrix
  33:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  */
  34:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  35:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  36:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** /**
  37:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   @addtogroup MatrixInv
  38:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   @{
  39:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  */
  40:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  41:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** /**
  42:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   @brief         Floating-point (64 bit) matrix inverse.
  43:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   @param[in]     pSrc      points to input matrix structure. The source matrix is modified by the f
  44:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   @param[out]    pDst      points to output matrix structure
  45:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   @return        execution status
  46:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****                    - \ref ARM_MATH_SUCCESS       : Operation successful
  47:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****                    - \ref ARM_MATH_SIZE_MISMATCH : Matrix size check failed
  48:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****                    - \ref ARM_MATH_SINGULAR      : Input matrix is found to be singular (non-invert
  49:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****  */
  50:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  51:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** arm_status arm_mat_inverse_f64(
  52:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   const arm_matrix_instance_f64 * pSrc,
  53:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         arm_matrix_instance_f64 * pDst)
  54:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** {
  32              	 .loc 1 54 0
  33              	 .cfi_startproc
  34              	 
  35              	 
  36 0000 90B5     	 push {r4,r7,lr}
  37              	.LCFI0:
  38              	 .cfi_def_cfa_offset 12
  39              	 .cfi_offset 4,-12
  40              	 .cfi_offset 7,-8
  41              	 .cfi_offset 14,-4
  42 0002 9FB0     	 sub sp,sp,#124
  43              	.LCFI1:
  44              	 .cfi_def_cfa_offset 136
  45 0004 00AF     	 add r7,sp,#0
  46              	.LCFI2:
  47              	 .cfi_def_cfa_register 7
  48 0006 7860     	 str r0,[r7,#4]
  49 0008 3960     	 str r1,[r7]
  55:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   float64_t *pIn = pSrc->pData;                  /* input data matrix pointer */
  50              	 .loc 1 55 0
  51 000a 7B68     	 ldr r3,[r7,#4]
  52 000c 5B68     	 ldr r3,[r3,#4]
  53 000e 7B67     	 str r3,[r7,#116]
  56:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   float64_t *pOut = pDst->pData;                 /* output data matrix pointer */
  54              	 .loc 1 56 0
  55 0010 3B68     	 ldr r3,[r7]
  56 0012 5B68     	 ldr r3,[r3,#4]
  57 0014 FB62     	 str r3,[r7,#44]
  57:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   float64_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
  58:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   float64_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
  59:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   float64_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data 
  60:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
  58              	 .loc 1 60 0
  59 0016 7B68     	 ldr r3,[r7,#4]
  60 0018 1B88     	 ldrh r3,[r3]
  61 001a BB62     	 str r3,[r7,#40]
  61:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
  62              	 .loc 1 61 0
  63 001c 7B68     	 ldr r3,[r7,#4]
  64 001e 5B88     	 ldrh r3,[r3,#2]
  65 0020 7B62     	 str r3,[r7,#36]
  62:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  63:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** #if defined (ARM_MATH_DSP)
  64:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  65:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   float64_t Xchg, in = 0.0, in1;                /* Temporary input values  */
  66              	 .loc 1 65 0
  67 0022 4FF00002 	 mov r2,#0
  68 0026 4FF00003 	 mov r3,#0
  69 002a C7E91423 	 strd r2,[r7,#80]
  66:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   uint32_t i, rowCnt, flag = 0U, j, loopCnt, k, l;      /* loop counters */
  70              	 .loc 1 66 0
  71 002e 0023     	 movs r3,#0
  72 0030 7B64     	 str r3,[r7,#68]
  67:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   arm_status status;                             /* status of matrix inverse */
  68:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  69:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** #ifdef ARM_MATH_MATRIX_CHECK
  70:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  71:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   /* Check for matrix mismatch condition */
  72:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   if ((pSrc->numRows != pSrc->numCols) ||
  73              	 .loc 1 72 0
  74 0032 7B68     	 ldr r3,[r7,#4]
  75 0034 1A88     	 ldrh r2,[r3]
  76 0036 7B68     	 ldr r3,[r7,#4]
  77 0038 5B88     	 ldrh r3,[r3,#2]
  78 003a 9A42     	 cmp r2,r3
  79 003c 0BD1     	 bne .L2
  73:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       (pDst->numRows != pDst->numCols) ||
  80              	 .loc 1 73 0 discriminator 1
  81 003e 3B68     	 ldr r3,[r7]
  82 0040 1A88     	 ldrh r2,[r3]
  83 0042 3B68     	 ldr r3,[r7]
  84 0044 5B88     	 ldrh r3,[r3,#2]
  72:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       (pDst->numRows != pDst->numCols) ||
  85              	 .loc 1 72 0 discriminator 1
  86 0046 9A42     	 cmp r2,r3
  87 0048 05D1     	 bne .L2
  74:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       (pSrc->numRows != pDst->numRows)   )
  88              	 .loc 1 74 0
  89 004a 7B68     	 ldr r3,[r7,#4]
  90 004c 1A88     	 ldrh r2,[r3]
  91 004e 3B68     	 ldr r3,[r7]
  92 0050 1B88     	 ldrh r3,[r3]
  73:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       (pDst->numRows != pDst->numCols) ||
  93              	 .loc 1 73 0
  94 0052 9A42     	 cmp r2,r3
  95 0054 03D0     	 beq .L3
  96              	.L2:
  75:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   {
  76:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
  77:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     status = ARM_MATH_SIZE_MISMATCH;
  97              	 .loc 1 77 0
  98 0056 FD23     	 movs r3,#253
  99 0058 87F83330 	 strb r3,[r7,#51]
 100 005c 0AE2     	 b .L4
 101              	.L3:
  78:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   }
  79:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   else
  80:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  81:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** #endif /* #ifdef ARM_MATH_MATRIX_CHECK */
  82:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  83:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   {
  84:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
  85:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /*---------------------------------------------------------------------------------------------
  86:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      * Matrix Inverse can be solved using elementary row operations.
  87:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
  88:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *  Gauss-Jordan Method:
  89:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
  90:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      1. First combine the identity matrix and the input matrix separated by a bar to form an
  91:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *        augmented matrix as follows:
  92:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *                      _                  _         _         _
  93:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *                     |  a11  a12 | 1   0  |       |  X11 X12  |
  94:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *                     |           |        |   =   |           |
  95:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *                     |_ a21  a22 | 0   1 _|       |_ X21 X21 _|
  96:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
  97:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      2. In our implementation, pDst Matrix is used as identity matrix.
  98:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
  99:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      3. Begin with the first row. Let i = 1.
 100:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 101:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      4. Check to see if the pivot for row i is zero.
 102:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         The pivot is the element of the main diagonal that is on the current row.
 103:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         For instance, if working with row i, then the pivot element is aii.
 104:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         If the pivot is zero, exchange that row with a row below it that does not
 105:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         contain a zero in column i. If this is not possible, then an inverse
 106:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         to that matrix does not exist.
 107:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 108:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      5. Divide every element of row i by the pivot.
 109:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 110:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      6. For every row below and  row i, replace that row with the sum of that row and
 111:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         a multiple of row i so that each new element in column i below row i is zero.
 112:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 113:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
 114:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         for every element below and above the main diagonal.
 115:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 116:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).
 117:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).
 118:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *---------------------------------------------------------------------------------------------
 119:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 120:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Working pointer for destination matrix */
 121:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     pOutT1 = pOut;
 102              	 .loc 1 121 0
 103 005e FB6A     	 ldr r3,[r7,#44]
 104 0060 BB66     	 str r3,[r7,#104]
 122:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 123:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Loop over the number of rows */
 124:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     rowCnt = numRows;
 105              	 .loc 1 124 0
 106 0062 BB6A     	 ldr r3,[r7,#40]
 107 0064 BB64     	 str r3,[r7,#72]
 125:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 126:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Making the destination matrix as identity matrix */
 127:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     while (rowCnt > 0U)
 108              	 .loc 1 127 0
 109 0066 34E0     	 b .L5
 110              	.L10:
 128:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     {
 129:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Writing all zeroes in lower triangle of the destination matrix */
 130:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       j = numRows - rowCnt;
 111              	 .loc 1 130 0
 112 0068 BA6A     	 ldr r2,[r7,#40]
 113 006a BB6C     	 ldr r3,[r7,#72]
 114 006c D31A     	 subs r3,r2,r3
 115 006e 3B64     	 str r3,[r7,#64]
 131:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       while (j > 0U)
 116              	 .loc 1 131 0
 117 0070 0CE0     	 b .L6
 118              	.L7:
 132:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 133:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         *pOutT1++ = 0.0;
 119              	 .loc 1 133 0
 120 0072 BB6E     	 ldr r3,[r7,#104]
 121 0074 03F10802 	 add r2,r3,#8
 122 0078 BA66     	 str r2,[r7,#104]
 123 007a 4FF00000 	 mov r0,#0
 124 007e 4FF00001 	 mov r1,#0
 125 0082 C3E90001 	 strd r0,[r3]
 134:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         j--;
 126              	 .loc 1 134 0
 127 0086 3B6C     	 ldr r3,[r7,#64]
 128 0088 013B     	 subs r3,r3,#1
 129 008a 3B64     	 str r3,[r7,#64]
 130              	.L6:
 131:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       while (j > 0U)
 131              	 .loc 1 131 0
 132 008c 3B6C     	 ldr r3,[r7,#64]
 133 008e 002B     	 cmp r3,#0
 134 0090 EFD1     	 bne .L7
 135:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 136:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 137:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Writing all ones in the diagonal of the destination matrix */
 138:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       *pOutT1++ = 1.0;
 135              	 .loc 1 138 0
 136 0092 BB6E     	 ldr r3,[r7,#104]
 137 0094 03F10802 	 add r2,r3,#8
 138 0098 BA66     	 str r2,[r7,#104]
 139 009a 4FF00000 	 mov r0,#0
 140 009e 9249     	 ldr r1,.L51
 141 00a0 C3E90001 	 strd r0,[r3]
 139:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 140:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Writing all zeroes in upper triangle of the destination matrix */
 141:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       j = rowCnt - 1U;
 142              	 .loc 1 141 0
 143 00a4 BB6C     	 ldr r3,[r7,#72]
 144 00a6 013B     	 subs r3,r3,#1
 145 00a8 3B64     	 str r3,[r7,#64]
 142:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       while (j > 0U)
 146              	 .loc 1 142 0
 147 00aa 0CE0     	 b .L8
 148              	.L9:
 143:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 144:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         *pOutT1++ = 0.0;
 149              	 .loc 1 144 0
 150 00ac BB6E     	 ldr r3,[r7,#104]
 151 00ae 03F10802 	 add r2,r3,#8
 152 00b2 BA66     	 str r2,[r7,#104]
 153 00b4 4FF00000 	 mov r0,#0
 154 00b8 4FF00001 	 mov r1,#0
 155 00bc C3E90001 	 strd r0,[r3]
 145:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         j--;
 156              	 .loc 1 145 0
 157 00c0 3B6C     	 ldr r3,[r7,#64]
 158 00c2 013B     	 subs r3,r3,#1
 159 00c4 3B64     	 str r3,[r7,#64]
 160              	.L8:
 142:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       while (j > 0U)
 161              	 .loc 1 142 0
 162 00c6 3B6C     	 ldr r3,[r7,#64]
 163 00c8 002B     	 cmp r3,#0
 164 00ca EFD1     	 bne .L9
 146:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 147:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 148:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Decrement loop counter */
 149:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       rowCnt--;
 165              	 .loc 1 149 0
 166 00cc BB6C     	 ldr r3,[r7,#72]
 167 00ce 013B     	 subs r3,r3,#1
 168 00d0 BB64     	 str r3,[r7,#72]
 169              	.L5:
 127:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     {
 170              	 .loc 1 127 0
 171 00d2 BB6C     	 ldr r3,[r7,#72]
 172 00d4 002B     	 cmp r3,#0
 173 00d6 C7D1     	 bne .L10
 150:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     }
 151:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 152:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Loop over the number of columns of the input matrix.
 153:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        All the elements in each column are processed by the row operations */
 154:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     loopCnt = numCols;
 174              	 .loc 1 154 0
 175 00d8 7B6A     	 ldr r3,[r7,#36]
 176 00da FB63     	 str r3,[r7,#60]
 155:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 156:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Index modifier to navigate through the columns */
 157:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     l = 0U;
 177              	 .loc 1 157 0
 178 00dc 0023     	 movs r3,#0
 179 00de 7B63     	 str r3,[r7,#52]
 158:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 159:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     while (loopCnt > 0U)
 180              	 .loc 1 159 0
 181 00e0 87E1     	 b .L11
 182              	.L37:
 160:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     {
 161:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Check if the pivot element is zero..
 162:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * If it is zero then interchange the row with non zero row below.
 163:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * If there is no non zero element to replace in the rows below,
 164:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * then the matrix is Singular. */
 165:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 166:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Working pointer for the input matrix that points
 167:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * to the pivot element of the particular row  */
 168:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pInT1 = pIn + (l * numCols);
 183              	 .loc 1 168 0
 184 00e2 7B6B     	 ldr r3,[r7,#52]
 185 00e4 7A6A     	 ldr r2,[r7,#36]
 186 00e6 02FB03F3 	 mul r3,r2,r3
 187 00ea DB00     	 lsls r3,r3,#3
 188 00ec 7A6F     	 ldr r2,[r7,#116]
 189 00ee 1344     	 add r3,r3,r2
 190 00f0 3B67     	 str r3,[r7,#112]
 169:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 170:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Working pointer for the destination matrix that points
 171:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * to the pivot element of the particular row  */
 172:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pOutT1 = pOut + (l * numCols);
 191              	 .loc 1 172 0
 192 00f2 7B6B     	 ldr r3,[r7,#52]
 193 00f4 7A6A     	 ldr r2,[r7,#36]
 194 00f6 02FB03F3 	 mul r3,r2,r3
 195 00fa DB00     	 lsls r3,r3,#3
 196 00fc FA6A     	 ldr r2,[r7,#44]
 197 00fe 1344     	 add r3,r3,r2
 198 0100 BB66     	 str r3,[r7,#104]
 173:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 174:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Temporary variable to hold the pivot value */
 175:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       in = *pInT1;
 199              	 .loc 1 175 0
 200 0102 3B6F     	 ldr r3,[r7,#112]
 201 0104 D3E90023 	 ldrd r2,[r3]
 202 0108 C7E91423 	 strd r2,[r7,#80]
 176:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 177:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Destination pointer modifier */
 178:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       k = 1U;
 203              	 .loc 1 178 0
 204 010c 0123     	 movs r3,#1
 205 010e BB63     	 str r3,[r7,#56]
 179:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 180:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Check if the pivot element is zero */
 181:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       if (*pInT1 == 0.0)
 206              	 .loc 1 181 0
 207 0110 3B6F     	 ldr r3,[r7,#112]
 208 0112 D3E90023 	 ldrd r2,[r3]
 209 0116 1046     	 mov r0,r2
 210 0118 1946     	 mov r1,r3
 211 011a 4FF00002 	 mov r2,#0
 212 011e 4FF00003 	 mov r3,#0
 213 0122 FFF7FEFF 	 bl __aeabi_dcmpeq
 214 0126 0346     	 mov r3,r0
 215 0128 002B     	 cmp r3,#0
 216 012a 71D0     	 beq .L12
 182:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 183:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Loop over the number rows present below */
 184:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         for (i = (l + 1U); i < numRows; i++)
 217              	 .loc 1 184 0
 218 012c 7B6B     	 ldr r3,[r7,#52]
 219 012e 0133     	 adds r3,r3,#1
 220 0130 FB64     	 str r3,[r7,#76]
 221 0132 69E0     	 b .L14
 222              	.L21:
 185:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         {
 186:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Update the input and destination pointers */
 187:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pInT2 = pInT1 + (numCols * i);
 223              	 .loc 1 187 0
 224 0134 7B6A     	 ldr r3,[r7,#36]
 225 0136 FA6C     	 ldr r2,[r7,#76]
 226 0138 02FB03F3 	 mul r3,r2,r3
 227 013c DB00     	 lsls r3,r3,#3
 228 013e 3A6F     	 ldr r2,[r7,#112]
 229 0140 1344     	 add r3,r3,r2
 230 0142 FB66     	 str r3,[r7,#108]
 188:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pOutT2 = pOutT1 + (numCols * k);
 231              	 .loc 1 188 0
 232 0144 7B6A     	 ldr r3,[r7,#36]
 233 0146 BA6B     	 ldr r2,[r7,#56]
 234 0148 02FB03F3 	 mul r3,r2,r3
 235 014c DB00     	 lsls r3,r3,#3
 236 014e BA6E     	 ldr r2,[r7,#104]
 237 0150 1344     	 add r3,r3,r2
 238 0152 7B66     	 str r3,[r7,#100]
 189:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 190:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Check if there is a non zero pivot element to
 191:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****            * replace in the rows below */
 192:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           if (*pInT2 != 0.0)
 239              	 .loc 1 192 0
 240 0154 FB6E     	 ldr r3,[r7,#108]
 241 0156 D3E90023 	 ldrd r2,[r3]
 242 015a 1046     	 mov r0,r2
 243 015c 1946     	 mov r1,r3
 244 015e 4FF00002 	 mov r2,#0
 245 0162 4FF00003 	 mov r3,#0
 246 0166 FFF7FEFF 	 bl __aeabi_dcmpeq
 247 016a 0346     	 mov r3,r0
 248 016c 002B     	 cmp r3,#0
 249 016e 42D1     	 bne .L49
 193:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           {
 194:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Loop over number of columns
 195:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****              * to the right of the pilot element */
 196:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             j = numCols - l;
 250              	 .loc 1 196 0
 251 0170 7A6A     	 ldr r2,[r7,#36]
 252 0172 7B6B     	 ldr r3,[r7,#52]
 253 0174 D31A     	 subs r3,r2,r3
 254 0176 3B64     	 str r3,[r7,#64]
 197:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 198:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             while (j > 0U)
 255              	 .loc 1 198 0
 256 0178 18E0     	 b .L17
 257              	.L18:
 199:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             {
 200:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               /* Exchange the row elements of the input matrix */
 201:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               Xchg = *pInT2;
 258              	 .loc 1 201 0
 259 017a FB6E     	 ldr r3,[r7,#108]
 260 017c D3E90023 	 ldrd r2,[r3]
 261 0180 C7E90623 	 strd r2,[r7,#24]
 202:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               *pInT2++ = *pInT1;
 262              	 .loc 1 202 0
 263 0184 F96E     	 ldr r1,[r7,#108]
 264 0186 01F10803 	 add r3,r1,#8
 265 018a FB66     	 str r3,[r7,#108]
 266 018c 3B6F     	 ldr r3,[r7,#112]
 267 018e D3E90023 	 ldrd r2,[r3]
 268 0192 C1E90023 	 strd r2,[r1]
 203:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               *pInT1++ = Xchg;
 269              	 .loc 1 203 0
 270 0196 396F     	 ldr r1,[r7,#112]
 271 0198 01F10803 	 add r3,r1,#8
 272 019c 3B67     	 str r3,[r7,#112]
 273 019e D7E90623 	 ldrd r2,[r7,#24]
 274 01a2 C1E90023 	 strd r2,[r1]
 204:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 205:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               /* Decrement the loop counter */
 206:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               j--;
 275              	 .loc 1 206 0
 276 01a6 3B6C     	 ldr r3,[r7,#64]
 277 01a8 013B     	 subs r3,r3,#1
 278 01aa 3B64     	 str r3,[r7,#64]
 279              	.L17:
 198:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             {
 280              	 .loc 1 198 0
 281 01ac 3B6C     	 ldr r3,[r7,#64]
 282 01ae 002B     	 cmp r3,#0
 283 01b0 E3D1     	 bne .L18
 207:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             }
 208:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 209:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Loop over number of columns of the destination matrix */
 210:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             j = numCols;
 284              	 .loc 1 210 0
 285 01b2 7B6A     	 ldr r3,[r7,#36]
 286 01b4 3B64     	 str r3,[r7,#64]
 211:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 212:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             while (j > 0U)
 287              	 .loc 1 212 0
 288 01b6 18E0     	 b .L19
 289              	.L20:
 213:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             {
 214:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               /* Exchange the row elements of the destination matrix */
 215:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               Xchg = *pOutT2;
 290              	 .loc 1 215 0
 291 01b8 7B6E     	 ldr r3,[r7,#100]
 292 01ba D3E90023 	 ldrd r2,[r3]
 293 01be C7E90623 	 strd r2,[r7,#24]
 216:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               *pOutT2++ = *pOutT1;
 294              	 .loc 1 216 0
 295 01c2 796E     	 ldr r1,[r7,#100]
 296 01c4 01F10803 	 add r3,r1,#8
 297 01c8 7B66     	 str r3,[r7,#100]
 298 01ca BB6E     	 ldr r3,[r7,#104]
 299 01cc D3E90023 	 ldrd r2,[r3]
 300 01d0 C1E90023 	 strd r2,[r1]
 217:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               *pOutT1++ = Xchg;
 301              	 .loc 1 217 0
 302 01d4 B96E     	 ldr r1,[r7,#104]
 303 01d6 01F10803 	 add r3,r1,#8
 304 01da BB66     	 str r3,[r7,#104]
 305 01dc D7E90623 	 ldrd r2,[r7,#24]
 306 01e0 C1E90023 	 strd r2,[r1]
 218:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 219:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               /* Decrement loop counter */
 220:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               j--;
 307              	 .loc 1 220 0
 308 01e4 3B6C     	 ldr r3,[r7,#64]
 309 01e6 013B     	 subs r3,r3,#1
 310 01e8 3B64     	 str r3,[r7,#64]
 311              	.L19:
 212:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             {
 312              	 .loc 1 212 0
 313 01ea 3B6C     	 ldr r3,[r7,#64]
 314 01ec 002B     	 cmp r3,#0
 315 01ee E3D1     	 bne .L20
 221:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             }
 222:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 223:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Flag to indicate whether exchange is done or not */
 224:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             flag = 1U;
 316              	 .loc 1 224 0
 317 01f0 0123     	 movs r3,#1
 318 01f2 7B64     	 str r3,[r7,#68]
 225:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 226:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Break after exchange is done */
 227:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             break;
 319              	 .loc 1 227 0
 320 01f4 0CE0     	 b .L12
 321              	.L49:
 228:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           }
 229:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 230:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Update the destination pointer modifier */
 231:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           k++;
 322              	 .loc 1 231 0 discriminator 2
 323 01f6 BB6B     	 ldr r3,[r7,#56]
 324 01f8 0133     	 adds r3,r3,#1
 325 01fa BB63     	 str r3,[r7,#56]
 232:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 233:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Decrement loop counter */
 234:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           i--;
 326              	 .loc 1 234 0 discriminator 2
 327 01fc FB6C     	 ldr r3,[r7,#76]
 328 01fe 013B     	 subs r3,r3,#1
 329 0200 FB64     	 str r3,[r7,#76]
 184:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         {
 330              	 .loc 1 184 0 discriminator 2
 331 0202 FB6C     	 ldr r3,[r7,#76]
 332 0204 0133     	 adds r3,r3,#1
 333 0206 FB64     	 str r3,[r7,#76]
 334              	.L14:
 184:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         {
 335              	 .loc 1 184 0 is_stmt 0 discriminator 1
 336 0208 FA6C     	 ldr r2,[r7,#76]
 337 020a BB6A     	 ldr r3,[r7,#40]
 338 020c 9A42     	 cmp r2,r3
 339 020e 91D3     	 bcc .L21
 340              	.L12:
 235:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         }
 236:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 237:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 238:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Update the status if the matrix is singular */
 239:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       if ((flag != 1U) && (in == 0.0))
 341              	 .loc 1 239 0 is_stmt 1
 342 0210 7B6C     	 ldr r3,[r7,#68]
 343 0212 012B     	 cmp r3,#1
 344 0214 0CD0     	 beq .L22
 345              	 .loc 1 239 0 is_stmt 0 discriminator 1
 346 0216 D7E91401 	 ldrd r0,[r7,#80]
 347 021a 4FF00002 	 mov r2,#0
 348 021e 4FF00003 	 mov r3,#0
 349 0222 FFF7FEFF 	 bl __aeabi_dcmpeq
 350 0226 0346     	 mov r3,r0
 351 0228 002B     	 cmp r3,#0
 352 022a 01D0     	 beq .L22
 240:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 241:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         return ARM_MATH_SINGULAR;
 353              	 .loc 1 241 0 is_stmt 1
 354 022c FB23     	 movs r3,#251
 355 022e 23E1     	 b .L24
 356              	.L22:
 242:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 243:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 244:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Points to the pivot row of input and destination matrices */
 245:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pPivotRowIn = pIn + (l * numCols);
 357              	 .loc 1 245 0
 358 0230 7B6B     	 ldr r3,[r7,#52]
 359 0232 7A6A     	 ldr r2,[r7,#36]
 360 0234 02FB03F3 	 mul r3,r2,r3
 361 0238 DB00     	 lsls r3,r3,#3
 362 023a 7A6F     	 ldr r2,[r7,#116]
 363 023c 1344     	 add r3,r3,r2
 364 023e 7B61     	 str r3,[r7,#20]
 246:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pPivotRowDst = pOut + (l * numCols);
 365              	 .loc 1 246 0
 366 0240 7B6B     	 ldr r3,[r7,#52]
 367 0242 7A6A     	 ldr r2,[r7,#36]
 368 0244 02FB03F3 	 mul r3,r2,r3
 369 0248 DB00     	 lsls r3,r3,#3
 370 024a FA6A     	 ldr r2,[r7,#44]
 371 024c 1344     	 add r3,r3,r2
 372 024e 3B61     	 str r3,[r7,#16]
 247:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 248:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Temporary pointers to the pivot row pointers */
 249:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pInT1 = pPivotRowIn;
 373              	 .loc 1 249 0
 374 0250 7B69     	 ldr r3,[r7,#20]
 375 0252 3B67     	 str r3,[r7,#112]
 250:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pInT2 = pPivotRowDst;
 376              	 .loc 1 250 0
 377 0254 3B69     	 ldr r3,[r7,#16]
 378 0256 FB66     	 str r3,[r7,#108]
 251:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 252:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Pivot element of the row */
 253:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       in = *pPivotRowIn;
 379              	 .loc 1 253 0
 380 0258 7B69     	 ldr r3,[r7,#20]
 381 025a D3E90023 	 ldrd r2,[r3]
 382 025e C7E91423 	 strd r2,[r7,#80]
 254:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 255:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Loop over number of columns
 256:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * to the right of the pilot element */
 257:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       j = (numCols - l);
 383              	 .loc 1 257 0
 384 0262 7A6A     	 ldr r2,[r7,#36]
 385 0264 7B6B     	 ldr r3,[r7,#52]
 386 0266 D31A     	 subs r3,r2,r3
 387 0268 3B64     	 str r3,[r7,#64]
 258:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 259:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       while (j > 0U)
 388              	 .loc 1 259 0
 389 026a 15E0     	 b .L25
 390              	.L26:
 260:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 261:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Divide each element of the row of the input matrix
 262:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****          * by the pivot element */
 263:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         in1 = *pInT1;
 391              	 .loc 1 263 0
 392 026c 3B6F     	 ldr r3,[r7,#112]
 393 026e D3E90023 	 ldrd r2,[r3]
 394 0272 C7E90223 	 strd r2,[r7,#8]
 264:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         *pInT1++ = in1 / in;
 395              	 .loc 1 264 0
 396 0276 3C6F     	 ldr r4,[r7,#112]
 397 0278 04F10803 	 add r3,r4,#8
 398 027c 3B67     	 str r3,[r7,#112]
 399 027e D7E90201 	 ldrd r0,[r7,#8]
 400 0282 D7E91423 	 ldrd r2,[r7,#80]
 401 0286 FFF7FEFF 	 bl __aeabi_ddiv
 402 028a 0246     	 mov r2,r0
 403 028c 0B46     	 mov r3,r1
 404 028e C4E90023 	 strd r2,[r4]
 265:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 266:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Decrement the loop counter */
 267:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         j--;
 405              	 .loc 1 267 0
 406 0292 3B6C     	 ldr r3,[r7,#64]
 407 0294 013B     	 subs r3,r3,#1
 408 0296 3B64     	 str r3,[r7,#64]
 409              	.L25:
 259:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 410              	 .loc 1 259 0
 411 0298 3B6C     	 ldr r3,[r7,#64]
 412 029a 002B     	 cmp r3,#0
 413 029c E6D1     	 bne .L26
 268:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 269:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 270:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Loop over number of columns of the destination matrix */
 271:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       j = numCols;
 414              	 .loc 1 271 0
 415 029e 7B6A     	 ldr r3,[r7,#36]
 416 02a0 3B64     	 str r3,[r7,#64]
 272:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 273:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       while (j > 0U)
 417              	 .loc 1 273 0
 418 02a2 15E0     	 b .L27
 419              	.L28:
 274:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 275:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Divide each element of the row of the destination matrix
 276:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****          * by the pivot element */
 277:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         in1 = *pInT2;
 420              	 .loc 1 277 0
 421 02a4 FB6E     	 ldr r3,[r7,#108]
 422 02a6 D3E90023 	 ldrd r2,[r3]
 423 02aa C7E90223 	 strd r2,[r7,#8]
 278:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         *pInT2++ = in1 / in;
 424              	 .loc 1 278 0
 425 02ae FC6E     	 ldr r4,[r7,#108]
 426 02b0 04F10803 	 add r3,r4,#8
 427 02b4 FB66     	 str r3,[r7,#108]
 428 02b6 D7E90201 	 ldrd r0,[r7,#8]
 429 02ba D7E91423 	 ldrd r2,[r7,#80]
 430 02be FFF7FEFF 	 bl __aeabi_ddiv
 431 02c2 0246     	 mov r2,r0
 432 02c4 0B46     	 mov r3,r1
 433 02c6 C4E90023 	 strd r2,[r4]
 279:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 280:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Decrement the loop counter */
 281:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         j--;
 434              	 .loc 1 281 0
 435 02ca 3B6C     	 ldr r3,[r7,#64]
 436 02cc 013B     	 subs r3,r3,#1
 437 02ce 3B64     	 str r3,[r7,#64]
 438              	.L27:
 273:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 439              	 .loc 1 273 0
 440 02d0 3B6C     	 ldr r3,[r7,#64]
 441 02d2 002B     	 cmp r3,#0
 442 02d4 E6D1     	 bne .L28
 282:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 283:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 284:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Replace the rows with the sum of that row and a multiple of row i
 285:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * so that each new element in column i above row i is zero.*/
 286:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 287:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Temporary pointers for input and destination matrices */
 288:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pInT1 = pIn;
 443              	 .loc 1 288 0
 444 02d6 7B6F     	 ldr r3,[r7,#116]
 445 02d8 3B67     	 str r3,[r7,#112]
 289:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pInT2 = pOut;
 446              	 .loc 1 289 0
 447 02da FB6A     	 ldr r3,[r7,#44]
 448 02dc FB66     	 str r3,[r7,#108]
 290:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 291:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* index used to check for pivot element */
 292:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       i = 0U;
 449              	 .loc 1 292 0
 450 02de 0023     	 movs r3,#0
 451 02e0 FB64     	 str r3,[r7,#76]
 293:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 294:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Loop over number of rows */
 295:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /*  to be replaced by the sum of that row and a multiple of row i */
 296:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       k = numRows;
 452              	 .loc 1 296 0
 453 02e2 BB6A     	 ldr r3,[r7,#40]
 454 02e4 BB63     	 str r3,[r7,#56]
 297:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 298:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       while (k > 0U)
 455              	 .loc 1 298 0
 456 02e6 78E0     	 b .L29
 457              	.L52:
 458              	 .align 2
 459              	.L51:
 460 02e8 0000F03F 	 .word 1072693248
 461              	.L36:
 299:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 300:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Check for the pivot element */
 301:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         if (i == l)
 462              	 .loc 1 301 0
 463 02ec FA6C     	 ldr r2,[r7,#76]
 464 02ee 7B6B     	 ldr r3,[r7,#52]
 465 02f0 9A42     	 cmp r2,r3
 466 02f2 0CD1     	 bne .L30
 302:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         {
 303:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* If the processing element is the pivot element,
 304:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****              only the columns to the right are to be processed */
 305:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pInT1 += numCols - l;
 467              	 .loc 1 305 0
 468 02f4 7A6A     	 ldr r2,[r7,#36]
 469 02f6 7B6B     	 ldr r3,[r7,#52]
 470 02f8 D31A     	 subs r3,r2,r3
 471 02fa DB00     	 lsls r3,r3,#3
 472 02fc 3A6F     	 ldr r2,[r7,#112]
 473 02fe 1344     	 add r3,r3,r2
 474 0300 3B67     	 str r3,[r7,#112]
 306:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 307:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pInT2 += numCols;
 475              	 .loc 1 307 0
 476 0302 7B6A     	 ldr r3,[r7,#36]
 477 0304 DB00     	 lsls r3,r3,#3
 478 0306 FA6E     	 ldr r2,[r7,#108]
 479 0308 1344     	 add r3,r3,r2
 480 030a FB66     	 str r3,[r7,#108]
 481 030c 5AE0     	 b .L31
 482              	.L30:
 308:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         }
 309:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         else
 310:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         {
 311:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Element of the reference row */
 312:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           in = *pInT1;
 483              	 .loc 1 312 0
 484 030e 3B6F     	 ldr r3,[r7,#112]
 485 0310 D3E90023 	 ldrd r2,[r3]
 486 0314 C7E91423 	 strd r2,[r7,#80]
 313:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 314:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Working pointers for input and destination pivot rows */
 315:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pPRT_in = pPivotRowIn;
 487              	 .loc 1 315 0
 488 0318 7B69     	 ldr r3,[r7,#20]
 489 031a 3B66     	 str r3,[r7,#96]
 316:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pPRT_pDst = pPivotRowDst;
 490              	 .loc 1 316 0
 491 031c 3B69     	 ldr r3,[r7,#16]
 492 031e FB65     	 str r3,[r7,#92]
 317:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 318:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Loop over the number of columns to the right of the pivot element,
 319:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****              to replace the elements in the input matrix */
 320:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           j = (numCols - l);
 493              	 .loc 1 320 0
 494 0320 7A6A     	 ldr r2,[r7,#36]
 495 0322 7B6B     	 ldr r3,[r7,#52]
 496 0324 D31A     	 subs r3,r2,r3
 497 0326 3B64     	 str r3,[r7,#64]
 321:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 322:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           while (j > 0U)
 498              	 .loc 1 322 0
 499 0328 21E0     	 b .L32
 500              	.L33:
 323:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           {
 324:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Replace the element by the sum of that row
 325:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****                and a multiple of the reference row  */
 326:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             in1 = *pInT1;
 501              	 .loc 1 326 0
 502 032a 3B6F     	 ldr r3,[r7,#112]
 503 032c D3E90023 	 ldrd r2,[r3]
 504 0330 C7E90223 	 strd r2,[r7,#8]
 327:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             *pInT1++ = in1 - (in * *pPRT_in++);
 505              	 .loc 1 327 0
 506 0334 3C6F     	 ldr r4,[r7,#112]
 507 0336 04F10803 	 add r3,r4,#8
 508 033a 3B67     	 str r3,[r7,#112]
 509 033c 3B6E     	 ldr r3,[r7,#96]
 510 033e 03F10802 	 add r2,r3,#8
 511 0342 3A66     	 str r2,[r7,#96]
 512 0344 D3E90023 	 ldrd r2,[r3]
 513 0348 1046     	 mov r0,r2
 514 034a 1946     	 mov r1,r3
 515 034c D7E91423 	 ldrd r2,[r7,#80]
 516 0350 FFF7FEFF 	 bl __aeabi_dmul
 517 0354 0246     	 mov r2,r0
 518 0356 0B46     	 mov r3,r1
 519 0358 D7E90201 	 ldrd r0,[r7,#8]
 520 035c FFF7FEFF 	 bl __aeabi_dsub
 521 0360 0246     	 mov r2,r0
 522 0362 0B46     	 mov r3,r1
 523 0364 C4E90023 	 strd r2,[r4]
 328:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 329:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Decrement the loop counter */
 330:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             j--;
 524              	 .loc 1 330 0
 525 0368 3B6C     	 ldr r3,[r7,#64]
 526 036a 013B     	 subs r3,r3,#1
 527 036c 3B64     	 str r3,[r7,#64]
 528              	.L32:
 322:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           {
 529              	 .loc 1 322 0
 530 036e 3B6C     	 ldr r3,[r7,#64]
 531 0370 002B     	 cmp r3,#0
 532 0372 DAD1     	 bne .L33
 331:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           }
 332:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 333:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Loop over the number of columns to
 334:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****              replace the elements in the destination matrix */
 335:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           j = numCols;
 533              	 .loc 1 335 0
 534 0374 7B6A     	 ldr r3,[r7,#36]
 535 0376 3B64     	 str r3,[r7,#64]
 336:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 337:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           while (j > 0U)
 536              	 .loc 1 337 0
 537 0378 21E0     	 b .L34
 538              	.L35:
 338:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           {
 339:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Replace the element by the sum of that row
 340:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****                and a multiple of the reference row  */
 341:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             in1 = *pInT2;
 539              	 .loc 1 341 0
 540 037a FB6E     	 ldr r3,[r7,#108]
 541 037c D3E90023 	 ldrd r2,[r3]
 542 0380 C7E90223 	 strd r2,[r7,#8]
 342:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             *pInT2++ = in1 - (in * *pPRT_pDst++);
 543              	 .loc 1 342 0
 544 0384 FC6E     	 ldr r4,[r7,#108]
 545 0386 04F10803 	 add r3,r4,#8
 546 038a FB66     	 str r3,[r7,#108]
 547 038c FB6D     	 ldr r3,[r7,#92]
 548 038e 03F10802 	 add r2,r3,#8
 549 0392 FA65     	 str r2,[r7,#92]
 550 0394 D3E90023 	 ldrd r2,[r3]
 551 0398 1046     	 mov r0,r2
 552 039a 1946     	 mov r1,r3
 553 039c D7E91423 	 ldrd r2,[r7,#80]
 554 03a0 FFF7FEFF 	 bl __aeabi_dmul
 555 03a4 0246     	 mov r2,r0
 556 03a6 0B46     	 mov r3,r1
 557 03a8 D7E90201 	 ldrd r0,[r7,#8]
 558 03ac FFF7FEFF 	 bl __aeabi_dsub
 559 03b0 0246     	 mov r2,r0
 560 03b2 0B46     	 mov r3,r1
 561 03b4 C4E90023 	 strd r2,[r4]
 343:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 344:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Decrement loop counter */
 345:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             j--;
 562              	 .loc 1 345 0
 563 03b8 3B6C     	 ldr r3,[r7,#64]
 564 03ba 013B     	 subs r3,r3,#1
 565 03bc 3B64     	 str r3,[r7,#64]
 566              	.L34:
 337:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           {
 567              	 .loc 1 337 0
 568 03be 3B6C     	 ldr r3,[r7,#64]
 569 03c0 002B     	 cmp r3,#0
 570 03c2 DAD1     	 bne .L35
 571              	.L31:
 346:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           }
 347:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 348:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         }
 349:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 350:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Increment temporary input pointer */
 351:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         pInT1 = pInT1 + l;
 572              	 .loc 1 351 0
 573 03c4 7B6B     	 ldr r3,[r7,#52]
 574 03c6 DB00     	 lsls r3,r3,#3
 575 03c8 3A6F     	 ldr r2,[r7,#112]
 576 03ca 1344     	 add r3,r3,r2
 577 03cc 3B67     	 str r3,[r7,#112]
 352:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 353:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Decrement loop counter */
 354:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         k--;
 578              	 .loc 1 354 0
 579 03ce BB6B     	 ldr r3,[r7,#56]
 580 03d0 013B     	 subs r3,r3,#1
 581 03d2 BB63     	 str r3,[r7,#56]
 355:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 356:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Increment pivot index */
 357:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         i++;
 582              	 .loc 1 357 0
 583 03d4 FB6C     	 ldr r3,[r7,#76]
 584 03d6 0133     	 adds r3,r3,#1
 585 03d8 FB64     	 str r3,[r7,#76]
 586              	.L29:
 298:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 587              	 .loc 1 298 0
 588 03da BB6B     	 ldr r3,[r7,#56]
 589 03dc 002B     	 cmp r3,#0
 590 03de 85D1     	 bne .L36
 358:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 359:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 360:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Increment the input pointer */
 361:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pIn++;
 591              	 .loc 1 361 0
 592 03e0 7B6F     	 ldr r3,[r7,#116]
 593 03e2 0833     	 adds r3,r3,#8
 594 03e4 7B67     	 str r3,[r7,#116]
 362:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 363:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Decrement the loop counter */
 364:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       loopCnt--;
 595              	 .loc 1 364 0
 596 03e6 FB6B     	 ldr r3,[r7,#60]
 597 03e8 013B     	 subs r3,r3,#1
 598 03ea FB63     	 str r3,[r7,#60]
 365:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 366:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Increment the index modifier */
 367:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       l++;
 599              	 .loc 1 367 0
 600 03ec 7B6B     	 ldr r3,[r7,#52]
 601 03ee 0133     	 adds r3,r3,#1
 602 03f0 7B63     	 str r3,[r7,#52]
 603              	.L11:
 159:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     {
 604              	 .loc 1 159 0
 605 03f2 FB6B     	 ldr r3,[r7,#60]
 606 03f4 002B     	 cmp r3,#0
 607 03f6 7FF474AE 	 bne .L37
 368:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     }
 369:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 370:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 371:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** #else
 372:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 373:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   float64_t Xchg, in = 0.0;                     /* Temporary input values  */
 374:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   uint32_t i, rowCnt, flag = 0U, j, loopCnt, k, l;      /* loop counters */
 375:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   arm_status status;                             /* status of matrix inverse */
 376:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 377:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** #ifdef ARM_MATH_MATRIX_CHECK
 378:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 379:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   /* Check for matrix mismatch condition */
 380:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   if ((pSrc->numRows != pSrc->numCols) ||
 381:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       (pDst->numRows != pDst->numCols) ||
 382:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       (pSrc->numRows != pDst->numRows)   )
 383:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   {
 384:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
 385:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     status = ARM_MATH_SIZE_MISMATCH;
 386:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   }
 387:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   else
 388:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 389:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** #endif /* #ifdef ARM_MATH_MATRIX_CHECK */
 390:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 391:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   {
 392:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 393:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /*---------------------------------------------------------------------------------------------
 394:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      * Matrix Inverse can be solved using elementary row operations.
 395:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 396:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *  Gauss-Jordan Method:
 397:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 398:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      1. First combine the identity matrix and the input matrix separated by a bar to form an
 399:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *        augmented matrix as follows:
 400:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *                      _  _          _     _      _   _         _         _
 401:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *                     |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |
 402:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *                     |  |            | | |        |   |   =   |           |
 403:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *                     |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|
 404:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 405:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      2. In our implementation, pDst Matrix is used as identity matrix.
 406:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 407:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      3. Begin with the first row. Let i = 1.
 408:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 409:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      4. Check to see if the pivot for row i is zero.
 410:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         The pivot is the element of the main diagonal that is on the current row.
 411:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         For instance, if working with row i, then the pivot element is aii.
 412:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         If the pivot is zero, exchange that row with a row below it that does not
 413:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         contain a zero in column i. If this is not possible, then an inverse
 414:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         to that matrix does not exist.
 415:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 416:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      5. Divide every element of row i by the pivot.
 417:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 418:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      6. For every row below and  row i, replace that row with the sum of that row and
 419:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         a multiple of row i so that each new element in column i below row i is zero.
 420:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 421:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
 422:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         for every element below and above the main diagonal.
 423:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *
 424:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *      8. Now an identical matrix is formed to the left of the bar(input matrix, src).
 425:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *         Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).
 426:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****      *---------------------------------------------------------------------------------------------
 427:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 428:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Working pointer for destination matrix */
 429:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     pOutT1 = pOut;
 430:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 431:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Loop over the number of rows */
 432:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     rowCnt = numRows;
 433:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 434:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Making the destination matrix as identity matrix */
 435:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     while (rowCnt > 0U)
 436:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     {
 437:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Writing all zeroes in lower triangle of the destination matrix */
 438:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       j = numRows - rowCnt;
 439:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       while (j > 0U)
 440:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 441:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         *pOutT1++ = 0.0;
 442:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         j--;
 443:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 444:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 445:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Writing all ones in the diagonal of the destination matrix */
 446:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       *pOutT1++ = 1.0;
 447:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 448:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Writing all zeroes in upper triangle of the destination matrix */
 449:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       j = rowCnt - 1U;
 450:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       while (j > 0U)
 451:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 452:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         *pOutT1++ = 0.0;
 453:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         j--;
 454:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 455:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 456:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Decrement loop counter */
 457:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       rowCnt--;
 458:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     }
 459:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 460:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Loop over the number of columns of the input matrix.
 461:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        All the elements in each column are processed by the row operations */
 462:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     loopCnt = numCols;
 463:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 464:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Index modifier to navigate through the columns */
 465:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     l = 0U;
 466:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 467:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     while (loopCnt > 0U)
 468:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     {
 469:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Check if the pivot element is zero..
 470:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * If it is zero then interchange the row with non zero row below.
 471:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * If there is no non zero element to replace in the rows below,
 472:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * then the matrix is Singular. */
 473:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 474:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Working pointer for the input matrix that points
 475:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * to the pivot element of the particular row  */
 476:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pInT1 = pIn + (l * numCols);
 477:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 478:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Working pointer for the destination matrix that points
 479:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * to the pivot element of the particular row  */
 480:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pOutT1 = pOut + (l * numCols);
 481:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 482:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Temporary variable to hold the pivot value */
 483:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       in = *pInT1;
 484:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 485:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Destination pointer modifier */
 486:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       k = 1U;
 487:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 488:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Check if the pivot element is zero */
 489:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       if (*pInT1 == 0.0)
 490:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 491:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Loop over the number rows present below */
 492:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         for (i = (l + 1U); i < numRows; i++)
 493:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         {
 494:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Update the input and destination pointers */
 495:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pInT2 = pInT1 + (numCols * i);
 496:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pOutT2 = pOutT1 + (numCols * k);
 497:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 498:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Check if there is a non zero pivot element to
 499:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****            * replace in the rows below */
 500:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           if (*pInT2 != 0.0)
 501:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           {
 502:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Loop over number of columns
 503:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****              * to the right of the pilot element */
 504:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             for (j = 0U; j < (numCols - l); j++)
 505:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             {
 506:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               /* Exchange the row elements of the input matrix */
 507:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               Xchg = *pInT2;
 508:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               *pInT2++ = *pInT1;
 509:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               *pInT1++ = Xchg;
 510:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             }
 511:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 512:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             for (j = 0U; j < numCols; j++)
 513:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             {
 514:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               Xchg = *pOutT2;
 515:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               *pOutT2++ = *pOutT1;
 516:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****               *pOutT1++ = Xchg;
 517:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             }
 518:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 519:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Flag to indicate whether exchange is done or not */
 520:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             flag = 1U;
 521:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 522:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Break after exchange is done */
 523:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             break;
 524:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           }
 525:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 526:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Update the destination pointer modifier */
 527:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           k++;
 528:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         }
 529:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 530:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 531:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Update the status if the matrix is singular */
 532:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       if ((flag != 1U) && (in == 0.0))
 533:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 534:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         return ARM_MATH_SINGULAR;
 535:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 536:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 537:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Points to the pivot row of input and destination matrices */
 538:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pPivotRowIn = pIn + (l * numCols);
 539:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pPivotRowDst = pOut + (l * numCols);
 540:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 541:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Temporary pointers to the pivot row pointers */
 542:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pInT1 = pPivotRowIn;
 543:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pOutT1 = pPivotRowDst;
 544:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 545:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Pivot element of the row */
 546:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       in = *(pIn + (l * numCols));
 547:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 548:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Loop over number of columns
 549:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * to the right of the pilot element */
 550:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       for (j = 0U; j < (numCols - l); j++)
 551:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 552:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Divide each element of the row of the input matrix
 553:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****          * by the pivot element */
 554:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         *pInT1 = *pInT1 / in;
 555:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         pInT1++;
 556:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 557:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       for (j = 0U; j < numCols; j++)
 558:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 559:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Divide each element of the row of the destination matrix
 560:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****          * by the pivot element */
 561:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         *pOutT1 = *pOutT1 / in;
 562:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         pOutT1++;
 563:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 564:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 565:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Replace the rows with the sum of that row and a multiple of row i
 566:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****        * so that each new element in column i above row i is zero.*/
 567:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 568:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Temporary pointers for input and destination matrices */
 569:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pInT1 = pIn;
 570:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pOutT1 = pOut;
 571:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 572:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       for (i = 0U; i < numRows; i++)
 573:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 574:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Check for the pivot element */
 575:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         if (i == l)
 576:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         {
 577:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* If the processing element is the pivot element,
 578:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****              only the columns to the right are to be processed */
 579:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pInT1 += numCols - l;
 580:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pOutT1 += numCols;
 581:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         }
 582:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         else
 583:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         {
 584:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Element of the reference row */
 585:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           in = *pInT1;
 586:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 587:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Working pointers for input and destination pivot rows */
 588:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pPRT_in = pPivotRowIn;
 589:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           pPRT_pDst = pPivotRowDst;
 590:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 591:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Loop over the number of columns to the right of the pivot element,
 592:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****              to replace the elements in the input matrix */
 593:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           for (j = 0U; j < (numCols - l); j++)
 594:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           {
 595:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Replace the element by the sum of that row
 596:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****                and a multiple of the reference row  */
 597:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             *pInT1 = *pInT1 - (in * *pPRT_in++);
 598:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             pInT1++;
 599:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           }
 600:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 601:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           /* Loop over the number of columns to
 602:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****              replace the elements in the destination matrix */
 603:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           for (j = 0U; j < numCols; j++)
 604:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           {
 605:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             /* Replace the element by the sum of that row
 606:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****                and a multiple of the reference row  */
 607:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             *pOutT1 = *pOutT1 - (in * *pPRT_pDst++);
 608:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             pOutT1++;
 609:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****           }
 610:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 611:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         }
 612:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 613:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         /* Increment temporary input pointer */
 614:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         pInT1 = pInT1 + l;
 615:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 616:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 617:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Increment the input pointer */
 618:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pIn++;
 619:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 620:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Decrement the loop counter */
 621:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       loopCnt--;
 622:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 623:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       /* Increment the index modifier */
 624:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       l++;
 625:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     }
 626:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 627:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** #endif /* #if defined (ARM_MATH_DSP) */
 628:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 629:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     /* Set status as ARM_MATH_SUCCESS */
 630:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     status = ARM_MATH_SUCCESS;
 608              	 .loc 1 630 0
 609 03fa 0023     	 movs r3,#0
 610 03fc 87F83330 	 strb r3,[r7,#51]
 631:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 632:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     if ((flag != 1U) && (in == 0.0))
 611              	 .loc 1 632 0
 612 0400 7B6C     	 ldr r3,[r7,#68]
 613 0402 012B     	 cmp r3,#1
 614 0404 36D0     	 beq .L4
 615              	 .loc 1 632 0 is_stmt 0 discriminator 1
 616 0406 D7E91401 	 ldrd r0,[r7,#80]
 617 040a 4FF00002 	 mov r2,#0
 618 040e 4FF00003 	 mov r3,#0
 619 0412 FFF7FEFF 	 bl __aeabi_dcmpeq
 620 0416 0346     	 mov r3,r0
 621 0418 002B     	 cmp r3,#0
 622 041a 2BD0     	 beq .L4
 633:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     {
 634:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       pIn = pSrc->pData;
 623              	 .loc 1 634 0 is_stmt 1
 624 041c 7B68     	 ldr r3,[r7,#4]
 625 041e 5B68     	 ldr r3,[r3,#4]
 626 0420 7B67     	 str r3,[r7,#116]
 635:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       for (i = 0; i < numRows * numCols; i++)
 627              	 .loc 1 635 0
 628 0422 0023     	 movs r3,#0
 629 0424 FB64     	 str r3,[r7,#76]
 630 0426 14E0     	 b .L39
 631              	.L43:
 636:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       {
 637:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         if (pIn[i] != 0.0)
 632              	 .loc 1 637 0
 633 0428 FB6C     	 ldr r3,[r7,#76]
 634 042a DB00     	 lsls r3,r3,#3
 635 042c 7A6F     	 ldr r2,[r7,#116]
 636 042e 1344     	 add r3,r3,r2
 637 0430 D3E90023 	 ldrd r2,[r3]
 638 0434 1046     	 mov r0,r2
 639 0436 1946     	 mov r1,r3
 640 0438 4FF00002 	 mov r2,#0
 641 043c 4FF00003 	 mov r3,#0
 642 0440 FFF7FEFF 	 bl __aeabi_dcmpeq
 643 0444 0346     	 mov r3,r0
 644 0446 002B     	 cmp r3,#0
 645 0448 00D1     	 bne .L50
 638:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****             break;
 646              	 .loc 1 638 0
 647 044a 09E0     	 b .L42
 648              	.L50:
 635:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       for (i = 0; i < numRows * numCols; i++)
 649              	 .loc 1 635 0 discriminator 2
 650 044c FB6C     	 ldr r3,[r7,#76]
 651 044e 0133     	 adds r3,r3,#1
 652 0450 FB64     	 str r3,[r7,#76]
 653              	.L39:
 635:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       for (i = 0; i < numRows * numCols; i++)
 654              	 .loc 1 635 0 is_stmt 0 discriminator 1
 655 0452 BB6A     	 ldr r3,[r7,#40]
 656 0454 7A6A     	 ldr r2,[r7,#36]
 657 0456 02FB03F2 	 mul r2,r2,r3
 658 045a FB6C     	 ldr r3,[r7,#76]
 659 045c 9A42     	 cmp r2,r3
 660 045e E3D8     	 bhi .L43
 661              	.L42:
 639:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       }
 640:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 641:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****       if (i == numRows * numCols)
 662              	 .loc 1 641 0 is_stmt 1
 663 0460 BB6A     	 ldr r3,[r7,#40]
 664 0462 7A6A     	 ldr r2,[r7,#36]
 665 0464 02FB03F2 	 mul r2,r2,r3
 666 0468 FB6C     	 ldr r3,[r7,#76]
 667 046a 9A42     	 cmp r2,r3
 668 046c 02D1     	 bne .L4
 642:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****         status = ARM_MATH_SINGULAR;
 669              	 .loc 1 642 0
 670 046e FB23     	 movs r3,#251
 671 0470 87F83330 	 strb r3,[r7,#51]
 672              	.L4:
 643:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****     }
 644:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   }
 645:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** 
 646:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   /* Return to application */
 647:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c ****   return (status);
 673              	 .loc 1 647 0
 674 0474 97F83330 	 ldrb r3,[r7,#51]
 675              	.L24:
 676 0478 5BB2     	 sxtb r3,r3
 648:../Dave/Generated/CMSIS_DSP/Source/MatrixFunctions/arm_mat_inverse_f64.c **** }
 677              	 .loc 1 648 0
 678 047a 1846     	 mov r0,r3
 679 047c 7C37     	 adds r7,r7,#124
 680              	.LCFI3:
 681              	 .cfi_def_cfa_offset 12
 682 047e BD46     	 mov sp,r7
 683              	.LCFI4:
 684              	 .cfi_def_cfa_register 13
 685              	 
 686 0480 90BD     	 pop {r4,r7,pc}
 687              	 .cfi_endproc
 688              	.LFE149:
 690 0482 00BF     	 .text
 691              	.Letext0:
 692              	 .file 2 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 693              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 694              	 .file 4 "C:/Users/Rui Mendes/Desktop/DAVE/_Naive/_ForTesting/Dave/Generated/CMSIS_DSP/Include/arm_math.h"
 695              	 .file 5 "C:/Users/Rui Mendes/Desktop/DAVE/_Naive/_ForTesting/Libraries/CMSIS/Include/cmsis_gcc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 arm_mat_inverse_f64.c
    {standard input}:24     .text.arm_mat_inverse_f64:00000000 $t
    {standard input}:29     .text.arm_mat_inverse_f64:00000000 arm_mat_inverse_f64
    {standard input}:460    .text.arm_mat_inverse_f64:000002e8 $d
    {standard input}:463    .text.arm_mat_inverse_f64:000002ec $t
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_dcmpeq
__aeabi_ddiv
__aeabi_dmul
__aeabi_dsub
