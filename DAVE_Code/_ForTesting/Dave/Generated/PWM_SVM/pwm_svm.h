/**
 * @file pwm_svm.h
 * @date 2021-01-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * PWM_SVM v4.0.30 - Generates 3-phase space vector pulse width modulated outputs using CCU8.
 * It supports symmetric/asymmetric and 7-segment/5-segment SVM algorithm.
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version
 *
 * 2015-06-20:
 *     - Help document comment updated
 *
 * 2021-01-08:
 *     - Modified check for minimum XMCLib version
 *
 * @endcond
 *
 */

#ifndef PWM_SVM_H_
#define PWM_SVM_H_


/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "xmc_ccu8.h"
#include "xmc_scu.h"
#include "GLOBAL_CCU8/global_ccu8.h"
#include "xmc_gpio.h"
#include "DAVE_Common.h"
#include "pwm_svm_conf.h"

/**
 * @ingroup PWM_SVM_constants
 * @{
 */
/**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#define PWM_SVM_XMC_LIB_MAJOR_VERSION 2
#define PWM_SVM_XMC_LIB_MINOR_VERSION 0
#define PWM_SVM_XMC_LIB_PATCH_VERSION 0

#if !((XMC_LIB_MAJOR_VERSION > PWM_SVM_XMC_LIB_MAJOR_VERSION) ||\
      ((XMC_LIB_MAJOR_VERSION == PWM_SVM_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > PWM_SVM_XMC_LIB_MINOR_VERSION)) ||\
      ((XMC_LIB_MAJOR_VERSION == PWM_SVM_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == PWM_SVM_XMC_LIB_MINOR_VERSION) && (XMC_LIB_PATCH_VERSION >= PWM_SVM_XMC_LIB_PATCH_VERSION)))
#error "PWM_SVM requires XMC Peripheral Library v2.0.0 or higher"
#endif

/**
 * This is the macro for sin scale to eliminate gain factor K
 */
#define PWM_SVM_KSINSCALE          (9949U)
/**
 * This is the macro for cos scale to eliminate gain factor K
 */
#define PWM_SVM_KCOSSCALE          (17231U)
/**
 * This is the macro for sixty degree count
 */
#define PWM_SVM_SIXTYDEG_24BIT     (2796202U)
/**
 * This is the macro for thirty degree count
 */
#define PWM_SVM_THIRTYDEG_24BIT    (PWM_SVM_SIXTYDEG_24BIT/2U)

/**
 * This is the macro for thirty degree count
 */
#define PWM_SVM_SIXTYDEG_16BIT     (0x3FF)

/**
 * This is the macro for thirty degree count
 *
 */
#define PWM_SVM_THIRTYDEG_16BIT     (PWM_SVM_SIXTYDEG_16BIT/2)
/**
 * This is the macro for thirty degree count based on ACOS table used for over modulation
 * 30 degree is represented as 511.
 */
#define PWM_SVM_THIRTYDEG         (511U)

/**
 * This is the size of ACOS table used for over modualtion.
 */
#define PWM_SVM_ACOS_TABLE_SIZE    (512U)

/**
 * This is the macro for number of phase
 */
#define PWM_SVM_NUMBERPHASE        (3U)
/**
 * This is the macro for maximum number of phases
 */
#define PWM_SVM_PHASE_IO_MAX       (6U)
/**
 * This is the macro for maximum dead time count
 */
#define PWM_SVM_DEADTIME_REG_MAX   (255U)
/**
 * This is the macro for maximum dead time prescaler
 */
#define PWM_SVM_DEADTIME_DIV_MAX   (3U)
/**
 * This is the macro is used for milli second conversion
 */
#define PWM_SVM_MILLISECCONV       (1000U)
/**
 * This is the macro is used for micro second conversion
 */
#define PWM_SVM_MICROSECCONV       (1000000U)
/**
 * This is the macro is used for nano second conversion
 */
#define PWM_SVM_NANOSECCONV        (1000000000U)
/**
 * This is the macro for periodmatch and trap interrupt bit field mask
 * Bit position 10 for trap and 1 for period match
 */
#define PWM_SVM_PERIODTRAP_INT_BITMASK  (1025U)
/**
 * This macro defines deadtime lower limit
 */
#define PWM_SVM_DEADTIME_LOWERLIMIT    (50U)
/**
 * This macro defines deadtime upper limit
 */
#define PWM_SVM_DEADTIME_UPPERLIMIT    (5000U)
/**
 * This macro defines Tmin limit
 */
#define PWM_SVM_TMIN_LIMIT              (5000U)
#define	PWM_SVM_SHIFT_OVERMODULATION	(3U)
#define	PWM_SVM_MAX_AMPLITUDE	        (16384U)

#if defined ( __GNUC__ )
#define RAM_ATTRIBUTE  __attribute__((section(".ram_code")))
#else
#define RAM_ATTRIBUTE
#endif
/**
 * @}
 */

typedef void (*PWM_SVM_SVMSCHEME_PTR_t)(void *handle_ptr);
typedef void (*PWM_SVM_SEGCALC_PTR_t)(void *handle_ptr, uint16_t Amplitude, uint32_t Angle);
/**
 * @ingroup PWM_SVM_enumerations
 * @{
 */
/**********************************************************************************************************************
* ENUMS
**********************************************************************************************************************/
/**
 * State of the APP
 */
typedef enum PWM_SVM_STATE
{
  PWM_SVM_UNINITIALIZED,            /*!< default state after power on reset. */
  PWM_SVM_INITIALIZED,              /*!< APP is in INITIALIZED state after execution of the Init function*/
  PWM_SVM_RUNNING,                  /*!< APP is in RUNNING state after execution of the Start function.*/
  PWM_SVM_STOPPED                   /*!< APP is in STOPPED state after execution of the Stop function.*/
} PWM_SVM_STATE_t;

/**
 * segment time calculation method
 */
typedef enum PWM_SVM_SEGTIMECALC
{
  PWM_SVM_USE_CORDIC,               /*!< CORDIC is used for SVM segment time calculation - applicable for
                                         XMC13 devices*/
  PWM_SVM_USE_LOOKUPTABLE           /*!< Lookup table is used for segment time calculation */
} PWM_SVM_SEGTIMECALC_t;

/**
 * Status of the APP which can be occured during initialization.
 */
typedef enum PWM_SVM_STATUS
{
  PWM_SVM_STATUS_SUCCESS,           /*!< APP status ok*/
  PWM_SVM_STATUS_FAILURE,           /*!< APP status failure*/
  PWM_SVM_INVALID_PARAM             /*!< parameter invalid*/
} PWM_SVM_STATUS_t;

/**
 * current measurement type
 */
typedef enum PWM_SVM_CMTYPE
{
  PWM_SVM_NONE,                     /*!< Current measurement is not required */
  PWM_SVM_DCLINKCM,                 /*!< DC Link current measurement */
  PWM_SVM_PHASECM                   /*!< Phase current measurement */
} PWM_SVM_CMTYPE_t;

/**
 * Enumeration list for SVM Schemes
 */
typedef enum PWM_SVM_SVMCONFIG
{
  PWM_SVM_7SEG_SYMM,                /*!< 7 segment symmetric scheme*/
  PWM_SVM_7SEG_ASYMM,               /*!< 7 segment asymmetric scheme*/
  PWM_SVM_5SEG_SYMM,                /*!< 5 segment symmetric scheme*/
  PWM_SVM_5SEG_ASYMM,               /*!< 5 segment asymmetric scheme*/
  PWM_SVM_PSEUDONULL_3ACTIVE,       /*!< 3 active 5 segment pseudo null vector scheme*/
  PWM_SVM_PSEUDONULL_4ACTIVE        /*!< 4 active 7 segment pseudo null vector scheme*/
} PWM_SVM_SVMCONFIG_t;

/**
 * inverter enable pin configurations
 */
typedef enum PWM_SVM_INVERTERPINLEVEL
{
  PWM_SVM_IPIN_NOTREQUIRED,         /*!< Inverter pin not required.*/
  PWM_SVM_IPIN_HIGH,                /*!< Inverter pin is active high.*/
  PWM_SVM_IPIN_LOW                  /*!< Inverter pin is active low.*/
} PWM_SVM_INVERTERPINLEVEL_t;

/**
 * @}
 */
/**
 * @ingroup PWM_SVM_datastructures
 * @{
 */
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/**
 * GPIO Port and Pin
 */
typedef struct PWM_SVM_GPIO
{
  XMC_GPIO_PORT_t *const port;
  const uint8_t pin;
} PWM_SVM_GPIO_t;

typedef struct PWM_CCU8_CC8
{
  XMC_CCU8_SLICE_t  *slice_ptr;     /**< CCU8 CC8 pointer */
  uint8_t            slice_number;  /**< The slice identifier - 0 index based*/
} PWM_CCU8_CC8_t;

/**
 * This structure holds the APP configuration parameters
 */
typedef struct PWM_SVM_Config
{
  volatile  uint32_t*           config_phasev_crs;               /*!< Address of the phase V compare register */
  volatile  uint32_t*           config_phasew_crs;               /*!< Address of the phase W compare register */
  XMC_CCU8_SLICE_COMPARE_CHANNEL_t       phase_cmpch_map[4];     /*!< Enum value corresponding to compare channel*/
  XMC_CCU8_SLICE_STATUS_t                phase_st_map[3];        /*!< This decides mapping of ST output from ST1 or ST2*/
  PWM_SVM_SEGTIMECALC_t                  segment_time_calc;      /*!< This parameter gives the segment time calculation
                                                                        type*/
  PWM_SVM_CMTYPE_t                       current_measurement;    /*!< This parameter gives the type of current
                                                                         measurement when external trigger is enabled.*/
  XMC_CCU8_SLICE_TRAP_EXIT_MODE_t        trap_exit_mode;         /*!< This variable tells exit mode of trap.*/
  XMC_GPIO_HWCTRL_t                      trap_hwsel;             /*!< This value saves trap hardware selection value*/
  PWM_SVM_INVERTERPINLEVEL_t             inverter_pin;           /*!< This saves the inverter pin level.*/
  XMC_CCU8_SLICE_OUTPUT_t                phase_u_out0;           /*!< This variable represents phase-u output 0*/
  XMC_CCU8_SLICE_OUTPUT_t                phase_v_out0;           /*!< This variable represents phase-v output 0*/
  XMC_CCU8_SLICE_OUTPUT_t                phase_w_out0;           /*!< This variable represents phase-w output 0*/
  uint32_t                               pwm_frequency;          /*!< This represents PWM frequency value.*/
  uint32_t                               module_freq;            /*!< CCU8 module frequency as per selected resolution*/
  uint32_t                               sync_start_mask;        /*!< To configure synchronous start of the CCU8 slices.*/
  uint32_t                               shadow_transfer_mask;   /*!< This variable is used for enabling shadow transfer
                                                                      for consumed slices.*/
  uint32_t                               event_sr_selector[4];   /*!< Service Request Selector register for the CCU8
                                                                    slices.*/
  uint32_t                               period_max;             /*!< Max period value*/
  uint32_t                               period_min;             /*!< Min period value*/

  uint16_t                               current_offset;         /*!< This variable gives the offset for current
                                                                      measurement */
  uint16_t                               amplitude_scale;
  uint8_t                                enable_periodmatch;     /*!< This represents enable period match interrupt*/
  uint8_t                                enable_trapevent;       /*!< This represents enable trap interrupt*/
  uint8_t                                enable_optimized_slice; /*!< This variable tells slice optimization is true or
                                                                      false*/
  uint8_t                                enable_trap;            /*!< This tell whether to enable external trap feature*/
  uint8_t                                trap_sync_pwm;          /*!< This variable tells trap synchronization with PWM
                                                                      true/false.*/
}PWM_SVM_Config_t;

/**
 * This structure holds the general APP data.
 */
typedef struct PWM_SVM
{
  const PWM_SVM_Config_t                   *const  confighandle_ptr;        /*!< Handle pointer to APP structure*/
  XMC_CCU8_MODULE_t                        *const  global_ptr;              /*!< Pointer to ccu8 module identifier data
                                                                             structure*/
  const PWM_CCU8_CC8_t                     *const phase_ptr[4];            /*!< Array of Pointer to ccu8 slice identifier
                                                                             data structure*/
  const XMC_CCU8_SLICE_COMPARE_CONFIG_t    *const  phase_configinit_ptr;    /*!< Slice Init structure pointer for the
                                                                             three CCU8 slices */
  const XMC_CCU8_SLICE_COMPARE_CONFIG_t    *const  current_configinit_ptr;  /*!< Slice Init structure pointer for the CCU8
                                                                             current trigger slices */
  const PWM_SVM_GPIO_t                     *const  pwmoutpin_ptr[6];        /*!< GPIO pin initialization structure pointer
                                                                             for PWM op pins */
  const XMC_GPIO_CONFIG_t                  *const  pwmoutconfig_ptr[6];     /*!< GPIO pin configuration structure pointer
                                                                             for PWM op pins */
  const PWM_SVM_GPIO_t                     *const  trappin_ptr;             /*!< GPIO pin initialization structure pointer
                                                                             for trap input pin */
  const XMC_GPIO_CONFIG_t                  *const  trapinconfig_ptr;        /*!< GPIO pin configuration structure pointer
                                                                             for trap input pins */
  const PWM_SVM_GPIO_t                     *const  inverterpin_ptr;         /*!< GPIO pin initialization structure pointer
                                                                             for inverter enable pin */
  const XMC_GPIO_CONFIG_t                  *const  inverterpinconfig_ptr;   /*!< GPIO pin configuration structure pointer
                                                                             for inverter enable pins */
  const XMC_CCU8_SLICE_EVENT_CONFIG_t      *const  trapconfig_ptr;          /*!< Pointer to trap event configuration
                                                                             structure*/
  const XMC_CCU8_SLICE_EVENT_CONFIG_t      *const  startconfig_ptr;         /*!< Pointer to start event configuration
                                                                             structure*/
        GLOBAL_CCU8_t                      *const  globalccu8_handle_ptr;    /*!< Pointer to the GLOBAL_CCU8 APP handle. */
        XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t  *const  deadtimeconfig_ptr;        /*!< Pointer to dead time configuration structure*/
  volatile  uint32_t*                               phaseu_crs;
  volatile  uint32_t*                               phasev_crs;
  volatile  uint32_t*                               phasew_crs;
  volatile  uint32_t*                               phaseu_cr2s;
  volatile  uint32_t*                               phasev_cr2s;
  volatile  uint32_t*                               phasew_cr2s;
        PWM_SVM_SVMSCHEME_PTR_t             svm_schemesel_ptr;               /*!< Pointer to selected svm scheme function*/
        PWM_SVM_SEGCALC_PTR_t               seg_time_calc_ptr;               /*!< Pointer to selected segment time calculation function*/
        PWM_SVM_STATE_t                     state;                           /*!< state of the APP */
        XMC_CCU8_SLICE_DTC_DIV_t            deadtime_div;                    /*!< This variable represents dead time prescaler*/
        PWM_SVM_SVMCONFIG_t                 svm_config;                      /*!< This variable represents SVM configuration
                                                                             (scheme)*/
        uint32_t                            deadtime_rising_edge;            /*!< This variable represents dead time for rising edge*/
        uint32_t                            deadtime_falling_edge;           /*!< This variable represents dead time for falling edge*/
        uint32_t                            period;                          /*!< This variable represents period value*/
        uint32_t                            over_modulation_scale;           /*!< Overmodulation scale; 2^24/(1.154-1)*PWMCOUNT */
        uint32_t                            sector;                          /*!< Sector value 0-5*/
        uint32_t                            sector_angle;                    /*!<Sector angle, 60 degree is represented as 1023*/
        uint16_t                            t0;                              /*!< zero vector segment time*/
        uint16_t                            ta;                              /*!< Ta Segment Time calculation variable*/
        uint16_t                            tb;                              /*!< Tb Segment Time calculation variable*/
        uint16_t                            ta2;                             /*!< Ta2 Segment Time calculation variable for
                                                                             asymmetric pwm*/
        uint16_t                            tb2;                             /*!< Tb2 Segment Time calculation variable for
                                                                             asymmetric pwm*/
        uint16_t                            v_ta;                            /*!< Compare Value calculation  Variable */
        uint16_t                            v_tb;                            /*!< Compare Value calculation  Variable*/
        uint16_t                            v_ta2;                           /*!< Compare Value calculation  Variable*/
        uint16_t                            v_tb2;                           /*!< Compare Value calculation  Variable*/
        uint16_t                            v_tc;                            /*!< Compare Value calculation  Variable*/
        uint16_t                            subsector;                       /*!< This variable give sub sector info for 3
                                                                               active vector technique
                                                                              *  0-Less than Transition Angle
                                                                              *  1-Greater than Transition Angle */
        uint16_t                            tmin;                            /*!< This variable represents tmin count*/
        uint16_t                            tmin_14;                         /*!< Represents Tmin interms of 2^14*/
        uint16_t                            max_amplitude;                   /*!< This variable represents maximum amplitude
                                                                                  calculation*/
        uint16_t                            over_modulation_enable;          /*!<1-over modulation is enabled, 0- over modulation is disabled*/
        uint16_t                            max_amplitude_overmod;           /*!<maximum amplitude value for over modulation */
}PWM_SVM_t;


/**
 * @}
 */
/* Support for C++ codebase */
#ifdef __cplusplus
extern "C"
{
#endif
/**
 * @ingroup PWM_SVM_apidoc
 * @{
 */
/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @brief Get PWM_SVM APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include "DAVE.h"
 *
 * int main(void) 
 * {
 *   DAVE_STATUS_t init_status;
 *   DAVE_APP_VERSION_t version;
 *
 *   // Initialize PWM_SVM APP:
 *   // PWM_SVM_Init() is called from within DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   version = PWM_SVM_GetAppVersion();
 *   if (version.major != 1U) 
 *   {
 *     // Probably, not the right version.
 *   }
 *
 *   // More code here
 *   while(1) 
 *   {
 *   }
 *   return (0);
 * }
 * @endcode<BR>
 */
DAVE_APP_VERSION_t PWM_SVM_GetAppVersion(void);

/**
 * @brief Initializes APP with configuration associated with APP struture through HandlePtr.
 * @param HandlePtr Pointer of the APP user configuration
 * @return @ref PWM_SVM_STATUS_t It returns PWM_SVM_STATUS_FAILURE when any of the consumed low level APP \n
 * init function is getting failed<BR>
 * \par<b>Description:</b><br>
 *  Initializes APP with configuration associated with APP struture through HandlePtr. \n
 *  It is the first function to be called to invoke this APP.<br>
 *  Initializes CCU8 module using low level driver init functions.\n
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 *  PWM_SVM_Start()<br>
 */
PWM_SVM_STATUS_t PWM_SVM_Init(PWM_SVM_t* const HandlePtr);

/**
 * @brief Starts the APP and initiates the synchronous start for
 * the CC8 slices.
 * @param HandlePtr Pointer of the APP user configuration \n
 * @return None\n<BR>
 * \par<b>Description:</b><br>
 *  Function starts the APP by invoking CCU8 slices used to generate PWM for SVM.\n
 *  PWM_SVM_Init() function should get called before calling this API <br>
 *  Function executed only when APP state is PWM_SVM_INITIALIZED or when APP state is
 *  PWM_SVM_STOPPED.\n
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 *  PWM_SVM_SVMUpdate()<br>
 *  PWM_SVM_Stop()<br>
 */
void PWM_SVM_Start(PWM_SVM_t* const HandlePtr);

/**
 * @brief Stops the APP by stopping the
 * PWM generation.
 * @param HandlePtr Pointer of the APP user configuration \n
 * @return None\n<BR>
 * \par<b>Description:</b><br>
 *  Function stops the CCU8 slices and
 *  resets the inverter enable pin level, executing the function changes the APP state to PWM_SVM_RUNNING .\n
 *  Calling this API will not have any effect if pwm is not running.\n
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   //Do something
 *
 *   while(1)
 *   {
 *     if (XMC_CCU8_SLICE_GetEvent(PWM_SVM_0.phase_ptr[0]->slice_ptr,XMC_CCU8_SLICE_IRQ_ID_TRAP) == 1)
 *     {
 *       //motor stop is called when trap occurs
 *       //trap should be enabled in the gui.
 *       PWM_SVM_Stop((PWM_SVM_t*)&PWM_SVM_0);
 *     }
 *   }
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 *  PWM_SVM_Start()<br>
 */
void PWM_SVM_Stop(PWM_SVM_t* const HandlePtr);

/**
 * @brief Executes the SVM algorithm.
 * @param HandlePtr Handle of the PWM_SVM APP
 * @param Amplitude Voltage to be applied to the motor.
 * 0 - 100% => 0- PWM Period Value
 * @param Angle Angle of the rotor, 0 -360 degrees => 0 - 0xFFFFFF.
 * @return None<BR>
 * \par<b>Description:</b><br>
 * Function executes the SVM algorithm. It calls internal functions to calculate and update the duty cycle of
 * the three phases depending upon the SVM type and SVM scheme. Function need to be called periodically.<br>
 * PWM_SVM_Start should get called before calling this function.<br>
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_Init();   //PWM_SVM_Init is called within DAVE_Init()
 *   PWM_SVM_Start(&PWM_SVM_0);
 *   while(1);
 *   return 0;
 * }
 * 
 * //enable period match in event settings tab
 * //Drag one interrupt APP configure with below handler name
 * //connect  period match signal to interrupt
 * void PeriodMatchInterruptHandler(void)
 * {
 *   static uint32_t angle = 0;
 * 
 *   if (angle > 0xffffff)
 *   {
 *     angle = 0;
 *   }
 *   else
 *   {
 *     angle = angle + 1000;
 *   }
 * 
 *   PWM_SVM_SVMUpdate(&PWM_SVM_0, 500, angle);
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 */
RAM_ATTRIBUTE void PWM_SVM_SVMUpdate(PWM_SVM_t* const HandlePtr, uint16_t Amplitude, uint32_t Angle);

/**
 * @brief Updates the PWM frequency dynamically.
 * @param HandlePtr Pointer of the APP user configuration
 * @param Frequency Input frequency in terms of Hz
 * @return @ref PWM_SVM_STATUS_t returns PWM_SVM_INVALID_PARAM if configure frequency when APP state is\n
 * PWM_SVM_STATUS_RUNNING
 * \par<b>Description:</b><br>
 * Function configures the PWM frequency.
 * It can configure frequency only when APP state is not PWM_SVM_STATUS_RUNNING \n
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   status |= (DAVE_STATUS_t)PWM_SVM_SetPWMFrequency((PWM_SVM_t*)&PWM_SVM_0,10000);
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   //Do something
 *   if (status == DAVE_STATUS_FAILURE)
 *   {
 *     //do something
 *   }
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_SVM_GetPWMFrequency()
 */
PWM_SVM_STATUS_t PWM_SVM_SetPWMFrequency(PWM_SVM_t* const HandlePtr, uint32_t Frequency);

/**
 * @brief Reads the PWM frequency.
 * @param HandlePtr Pointer of the APP user configuration \n
 * @return uint32_t Returns PWM frequency in Hz
 * \par<b>Description:</b><br>
 * Function returns the PWM frequency in terms of hertz. \n
 * API can be called at any point of time.<br>
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   uint32_t frequency;
 * 
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   frequency = PWM_SVM_GetPWMFrequency((PWM_SVM_t*)&PWM_SVM_0); //will return configured frequency
 *   //Do something
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_SVM_SetPWMFrequency()
 */
uint32_t PWM_SVM_GetPWMFrequency(PWM_SVM_t* const HandlePtr);

/**
 * @brief Updates the PWM rising and falling edge dead time dynamically.
 * @param HandlePtr Pointer of the APP user configuration
 * @param DeadTimeRisingEdge - Desired rising edge deadtime value in nanoseconds
 * @param DeadTimeFallingEdge - Desired falling edge deadtime value in nanoseconds
 * @return @ref PWM_SVM_STATUS_t returns PWM_SVM_STATUS_SUCCESS only when configured deadtime are
 * within the limits \n
 * \par<b>Description:</b><br>
 * Function configures the PWM rising and falling edge dead time dynamically \n
 * Function can be called at any point of time, the API will set the deadtime for
 * all three phases.
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   status |= (DAVE_STATUS_t)PWM_SVM_SetDeadTime((PWM_SVM_t*)&PWM_SVM_0,1000,1000);
 *   //Do something
 *   if (status == DAVE_STATUS_FAILURE)
 *   {
 *     //do something
 *   }
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_SVM_GetRisingEdgeDeadTime()
 * PWM_SVM_GetFallingEdgeDeadTime()
 */
PWM_SVM_STATUS_t PWM_SVM_SetDeadTime(PWM_SVM_t* const HandlePtr,
                      uint32_t DeadTimeRisingEdge,uint32_t DeadTimeFallingEdge);
/**
 * @brief Returns the current rising edge deadtime.
 * @param HandlePtr Pointer of the APP user configuration \n
 * @return uint32_t returns rising edge deadtime in nano seconds
 * \par<b>Description:</b><br>
 * Function returns the dead time for rising edge of PWM out in terms of nano seconds \n
 * Function can be called at any point of time.
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   uint32_t dead_time_rising_edge;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   //Do something
 *   dead_time_rising_edge = PWM_SVM_GetRisingEdgeDeadTime((PWM_SVM_t*)&PWM_SVM_0);
 *   if (status == DAVE_STATUS_FAILURE)
 *   {
 *     //do something
 *   }
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_SVM_SetDeadTime()
 */
uint32_t PWM_SVM_GetRisingEdgeDeadTime(PWM_SVM_t*const HandlePtr);

/**
 * @brief Returns the configured falling edge deadtime.
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return uint32_t returns falling edge deadtime in nano seconds
 * \par<b>Description:</b><br>
 * Function returns the dead time for falling edge of PWM out in terms of nano seconds \n
 * Function can be called at any point of time.
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   uint32_t dead_time_rising_edge;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   //Do something
 *   dead_time_falling_edge = PWM_SVM_GetFallingEdgeDeadTime((PWM_SVM_t*)&PWM_SVM_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_SVM_SetDeadTime()
 */
uint32_t PWM_SVM_GetFallingEdgeDeadTime(PWM_SVM_t*const HandlePtr);

/**
 * @brief Updates Tmin value in terms of nanoseconds.
 * @param HandlePtr Pointer of the APP user configuration
 * @param Tmin Required Tmin in term of nano seconds.
 * @return @ref PWM_SVM_STATUS_t returns PWM_SVM_STATUS_SUCCESS only when configured tmin is
 * within the limits \n
 * \par<b>Description:</b><br>
 * Function updates the tmin which is minimum segment time of SVM. it is required to set this value
 * when DC link current needs to be measured\n
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   status |= (DAVE_STATUS_t)PWM_SVM_SetTmin((PWM_SVM_t*)&PWM_SVM_0,500);
 *   //Do something
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_SVM_GetTmin()
 */
PWM_SVM_STATUS_t PWM_SVM_SetTmin( PWM_SVM_t*const HandlePtr, uint32_t Tmin);

/**
 * @brief Reads the current Tmin time
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return uint32_t current Tmin in nano seconds
 * \par<b>Description:</b><br>
 * Reads the current Tmin time \n
 * Function can be used at any point of time.<br>
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   uint32_t tmin;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   //Do something
 *   tmin = PWM_SVM_GetTmin((PWM_SVM_t*)&PWM_SVM_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_SVM_SetTmin()
 */
uint32_t PWM_SVM_GetTmin(PWM_SVM_t* const HandlePtr);

/**
 * @brief Function updates SVM scheme.
 * @param HandlePtr Pointer of the APP user configuration
 * @param Tmin Scheme Required SVM scheme of type @ref PWM_SVM_SVMCONFIG_t.
 * @return @ref PWM_SVM_STATUS_t returns PWM_SVM_STATUS_SUCCESS only when valid scheme of
 * type @ref PWM_SVM_SVMCONFIG_t is provided \n
 * \par<b>Description:</b><br>
 * Function updates the SVM scheme \n
 * Based on current SVM scheme and proposed SVM scheme the function is splited internally
 * into dynamic and static,
 * Below table shows the possible scheme that can be changed dynamically without stopping
 * SVM<br>
 * <table>
 * <tr><td>Proposed scheme              <td>Current scheme </td>          <td>Updation Mode</td></tr>
 * <tr><td>PWM_SVM_7SEG_SYMM           <td>PWM_SVM_5SEG_SYMM </td>            <td>dynamic</td></tr>
 * <tr><td>PWM_SVM_7SEG_ASYMM          <td>PWM_SVM_5SEG_ASYMM </td>           <td>dynamic</td></tr>
 * <tr><td>PWM_SVM_5SEG_SYMM           <td>PWM_SVM_7SEG_SYMM  </td>           <td>dynamic</td></tr>
 * <tr><td>PWM_SVM_5SEG_ASYMM          <td>PWM_SVM_7SEG_ASYMM </td>          <td> dynamic</td></tr>
 * <tr><td>PWM_SVM_PSEUDONULL_3ACTIVE  <td>PWM_SVM_PSEUDONULL_4ACTIVE</td>   <td> dynamic</td></tr>
 * <tr><td>PWM_SVM_PSEUDONULL_4ACTIVE  <td>PWM_SVM_PSEUDONULL_3ACTIVE </td>  <td> dynamic</td></tr>
 * </table>
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   //This example is trying to set scheme dynamically so this will get passed only if current
 *   //scheme is PWM_SVM_7SEG_SYMM as in table
 *   status |= (DAVE_STATUS_t)PWM_SVM_SetSVMScheme((PWM_SVM_t*)&PWM_SVM_0,PWM_SVM_5SEG_SYMM);
 *   //Do something
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_SVM_GetSVMScheme()
 */
PWM_SVM_STATUS_t PWM_SVM_SetSVMScheme(PWM_SVM_t* const HandlePtr, PWM_SVM_SVMCONFIG_t Scheme);

/**
 * @brief Reads the current SVM scheme
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return PWM_SVM_SVMCONFIG_t current SVM scheme
 * \par<b>Description:</b><br>
 * Read the current SVM scheme. <br>
 * Function can be used at any point of time. <br>
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * PWM_SVM_SVMCONFIG_t SVM_scheme;
 * int main (void)
 * {
 *   DAVE_Init();   //PWM_SVM_Init is called within DAVE_Init()
 *   PWM_SVM_Start(&PWM_SVM_0);
 *   //do something
 *   SVM_scheme = PWM_SVM_GetSVMScheme(&PWM_SVM_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_SVM_SetSVMScheme()
 */
PWM_SVM_SVMCONFIG_t PWM_SVM_GetSVMScheme( PWM_SVM_t* const HandlePtr);

/**
 * @brief Disables the inverter enable pin.
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return void
 * \par<b>Description:</b><br>
 * Function disables inverter pin if applicable \n
 * Calling this API sets or resets the inverter enable pin based on active level
 * configuration.<br>
 * calling this function will not have any effect if inverter enable pin configuration
 * is set to disabled in GUI.
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   // In the below scenario when inverter disable is called, it disables
 *   // the inverter pin but PWM will keep on generating.
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   //Do something
 *   PWM_SVM_InverterDisable((PWM_SVM_t*)&PWM_SVM_0);
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_SVM_InverterEnable()
 */
void PWM_SVM_InverterDisable(PWM_SVM_t* const HandlePtr);

/**
 * @brief Enables the inverter enable pin.
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return void
 * \par<b>Description:</b><br>
 * Function enables inverter pin if applicable \n
 * Calling this API sets or resets the inverter enable pin based on active level
 * configuration.<br>
 * calling this function will not have any effect if inverter enable pin configuration
 * is set to disabled in GUI.
 * 
 * Example Usage:
 * 
 * @code
 * #include "DAVE.h"
 * 
 * int main (void)
 * {
 *   DAVE_STATUS_t status;
 *   status = DAVE_Init(); //PWM_SVM_Init() called by DAVE_Init()
 *   PWM_SVM_Start((PWM_SVM_t*)&PWM_SVM_0);
 *   //Do something
 *   PWM_SVM_InverterDisable((PWM_SVM_t*)&PWM_SVM_0);
 *   //inverter alone is disabled but PWM is keep on running
 *   //Do something
 *   PWM_SVM_InverterEnable((PWM_SVM_t*)&PWM_SVM_0); //Inverter is enabled
 *   while(1);
 *   return 0;
 * }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_SVM_InverterDisable()
 */
void PWM_SVM_InverterEnable(PWM_SVM_t* const HandlePtr);

/**
 * @}
 */
/**
    * @brief Calculates the compare values for the Symmetric
    * 7-Segment SVM \n
    * This function is called by PWM_SVM_SVMUpdate() and it is not recommended to call
    * this function by user.
    * @param[in] HandlePtr Handle of the PWM_SVM APP
    * @return void
    * <BR>
    *
    * <b>Reentrancy:  Yes</b><BR>
    * <b>Sync/Async:  Synchronous</b><BR>
*/
RAM_ATTRIBUTE void PWM_SVM_CalCmpValueSym7(PWM_SVM_t* const HandlePtr);

/**
    * @brief Calculates the compare values for the Symmetric
    * 5-Segment SVM \n
    * This function is called by PWM_SVM_SVMUpdate() and it is not recommended to call
    * this function by user.
    * @param[in] HandlePtr Handle of the PWM_SVM APP
    * @return void
    * <BR>
    *
    * <b>Reentrancy:  Yes</b><BR>
    * <b>Sync/Async:  Synchronous</b><BR>
*/
RAM_ATTRIBUTE void PWM_SVM_CalCmpValueSym5(PWM_SVM_t* const HandlePtr);

/**
    * @brief Calculates the compare values for the Asymmetric
    * 7-Segment SVM \n
    * This function is called by PWM_SVM_SVMUpdate() and it is not recommended to call
    * this function by user.
    * @param[in] HandlePtr Handle of the PWM_SVM APP
    * @return void
    * <BR>
    *
    * <b>Reentrancy:  Yes</b><BR>
    * <b>Sync/Async:  Synchronous</b><BR>
*/
void PWM_SVM_CalCmpValueAsym7(PWM_SVM_t* const HandlePtr);

/**
    * @brief Calculates the compare values for the Asymmetric
    * 5-Segment SVM \n
    * This function is called by PWM_SVM_SVMUpdate() and it is not recommended to call
    * this function by user.
    * @param[in] HandlePtr Handle of the PWM_SVM APP
    * @return void
    * <BR>
    *
    * <b>Reentrancy:  Yes</b><BR>
    * <b>Sync/Async:  Synchronous</b><BR>
*/
void PWM_SVM_CalCmpValueAsym5(PWM_SVM_t* const HandlePtr);

/**
    * @brief  Calculates the CCU8 slice compare value
    * for Asymmetric 7-segment Pseudo zero vector SVM technique.
    * This function is called by PWM_SVM_SVMUpdate() and it is not recommended to call
    * this function by user.
    * @param[in] HandlePtr Handle of the PWM_SVM APP
    * @return void
    * <BR>
    *
    * <b>Reentrancy:  Yes</b><BR>
    * <b>Sync/Async:  Synchronous</b><BR>
*/
void PWM_SVM_Calc4av7segmentCompVal(PWM_SVM_t*const HandlePtr);

/**
    * @brief  Calculates the CCU8 slice compare value
    * for Asymmetric 5-segment Pseudo zero vector SVM technique.
    * This function is called by PWM_SVM_SVMUpdate() and it is not recommended to call
    * this function by user.
    * @param[in] HandlePtr Handle of the PWM_SVM APP
    * @return void
    * <BR>
    *
    * <b>Reentrancy:  Yes</b><BR>
    * <b>Sync/Async:  Synchronous</b><BR>
*/
void PWM_SVM_Calc3av5segmentCompVal(PWM_SVM_t* const HandlePtr);

#if defined (MATH)
/**
 * @brief This function calculates segment time using CORDIC.
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @param[in] Amplitude Amplitude
 * @param[in] Angle Input angle
 * @return void
 */
RAM_ATTRIBUTE void PWM_SVM_TimecalcUsingCORDIC(PWM_SVM_t* const HandlePtr, uint16_t Amplitude,
    uint32_t Angle);
#endif
#if(1U == PWM_SVM_IS_LUT_ENABLE)

/**
 * @brief This function calculates segment time using Look up table.
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @param[in] Angle Input angle
 * @param[in] Amplitude Amplitude
 * @return void
 */
RAM_ATTRIBUTE void PWM_SVM_TimecalcUsingLUT(PWM_SVM_t* const HandlePtr, uint16_t Amplitude, uint32_t Angle);
#endif
/**
 * @}
 */
/* Support for C++ codebase */
#ifdef __cplusplus
}
#endif

#include "pwm_svm_extern.h"



#endif /* PWM_SVM_H_ */
