/**
 * @file pwm_svm.c
 * @date 2015-10-21
 *  *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * PWM_SVM v4.0.30 - Generates 3-phase space vector pulse width modulated outputs using CCU8.
 * It supports symmetric/asymmetric and 7-segment/5-segment SVM algorithm.
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version
 *
 * 2015-06-20:
 *     - DC link current trigger is updated. <br>
 *     - max_amplitude updated when PWM scheme is changed
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "pwm_svm.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
/**
 * @brief This function updates the compare values for the Symmetric
 * SVM(standard SVM) \n
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @return void
 */
RAM_ATTRIBUTE static void PWM_SVM_lSymCompValUpdate(PWM_SVM_t* const HandlePtr);
/**
 * @brief This function updates the compare values for the Asymmetric
 * SVM(standard SVM) \n
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @return void
 */
static void PWM_SVM_lAsymCompValUpdate(PWM_SVM_t* const HandlePtr);


/**
 * @brief  This function update the compare register values based on the sector
 *  number
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @return void
 */
static void PWM_SVM_lUpdateDcLinkComRes(PWM_SVM_t* const HandlePtr);
/**
 * @brief  This function update the svm scheme dynamically while pwm is running
 *  number
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @param[in] Scheme required svm scheme
 * @return void
 */
void PWM_SVM_lDynamicSVMSchemeModification(PWM_SVM_t* const HandlePtr, PWM_SVM_SVMCONFIG_t Scheme);
/**
 * @brief  This function update the svm scheme when pwm is stopped
 *  number
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @param[in] Scheme required svm scheme
 * @return void
 */
void PWM_SVM_lStaticSVMSchemeModification(PWM_SVM_t* const HandlePtr, PWM_SVM_SVMCONFIG_t Scheme);
#if(1U == PWM_SVM_IS_CURRENTTRIGGER_ENABLE)
/**
 * @brief  This function configures the current trigger ccu8 slice
 *  number
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @return void
 */
void PWM_SVM_lCurrentTrigSliceInit(PWM_SVM_t* const HandlePtr);
#endif
/**
 * @brief  This function configures the period value for Centre aligned PWM when switching from
 *         Edge aligned PWM
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @return void
 */
void PWM_SVM_lCAPeriodValueConfig(PWM_SVM_t* const HandlePtr);
/**
 * @brief  This function configures the period value for edge aligned PWM when switching from
 *         centre aligned PWM
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @return void
 */
void PWM_SVM_lEAPeriodValueConfig(PWM_SVM_t* const HandlePtr);
/*
 * Function enables configured events.
 */
void PWM_SVM_lEnableEvent(PWM_SVM_t* const HandlePtr);
#if(1U == PWM_SVM_IS_OVERMODULATION_ENABLE)
/**
 * @brief This function calculates sector angle for over modulation using Look up table.
 * This function will update sector angle variable based on amplitude.
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @param[in] Amplitude Amplitude
 * @return void
 */
void PWM_SVM_lOvermodulation(PWM_SVM_t* const HandlePtr, uint16_t Amplitude);
/**
 * @brief This function calculates sector angle for over modulation using CORDIC and Lookup table.
 * This function will update sector angle variable based on amplitude.
 * @param[in] HandlePtr Handle of the PWM_SVM App
 * @param[in] Amplitude Amplitude
 * @return void
 */
void PWM_SVM_lOvermodulation_Cordic(PWM_SVM_t* const HandlePtr, uint16_t Amplitude);
#endif

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/
#if(1U == PWM_SVM_IS_LUT_ENABLE)
/**
 * This is the sine table used for SVM algorithm.
 */
extern const uint16_t Sinus60_tab[];
#endif


/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
void PWM_SVM_lEnableEvent(PWM_SVM_t* const HandlePtr)
{
  /*Enable the slice 0 period match interrupt */
  if ((uint8_t) true == HandlePtr->confighandle_ptr->enable_periodmatch)
  {
    XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[0]->slice_ptr,
        (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
  }
  /*Enable the slice 0 trap interrupt */
  if ((uint8_t) true == HandlePtr->confighandle_ptr->enable_trapevent)
  {
    XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[0]->slice_ptr,
        (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_EVENT2);
  }
}
/**
 * This function disables the inverter
 */
void PWM_SVM_InverterDisable(PWM_SVM_t* const HandlePtr)
{
  XMC_ASSERT("PWM_SVM_InverterDisable:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  /*Inverter Enable pin settings.*/
  if ((PWM_SVM_INVERTERPINLEVEL_t) PWM_SVM_IPIN_HIGH == HandlePtr->confighandle_ptr->inverter_pin)
  {
    /*Set IO output to low*/
    XMC_GPIO_SetOutputLow(HandlePtr->inverterpin_ptr->port, HandlePtr->inverterpin_ptr->pin);
  }
  if ((PWM_SVM_INVERTERPINLEVEL_t) PWM_SVM_IPIN_LOW == HandlePtr->confighandle_ptr->inverter_pin)
  {
    /*Set IO output to high*/
    XMC_GPIO_SetOutputHigh(HandlePtr->inverterpin_ptr->port, HandlePtr->inverterpin_ptr->pin);
  }
}
/**
 * This function Enables the inverter
 */
void PWM_SVM_InverterEnable(PWM_SVM_t* const HandlePtr)
{
  XMC_ASSERT("NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  /*Inverter Enable pin settings.*/
  if ((PWM_SVM_INVERTERPINLEVEL_t) PWM_SVM_IPIN_HIGH == HandlePtr->confighandle_ptr->inverter_pin)
  {
    /*Set IO output to high*/
    XMC_GPIO_SetOutputHigh(HandlePtr->inverterpin_ptr->port, HandlePtr->inverterpin_ptr->pin);
  }
  if ((PWM_SVM_INVERTERPINLEVEL_t) PWM_SVM_IPIN_LOW == HandlePtr->confighandle_ptr->inverter_pin)
  {
    /*Set IO output to low*/
    XMC_GPIO_SetOutputLow(HandlePtr->inverterpin_ptr->port, HandlePtr->inverterpin_ptr->pin);
  }
}
#if(1U == PWM_SVM_IS_CURRENTTRIGGER_ENABLE)
/**
 * This function configures the current trigger slice
 */
void PWM_SVM_lCurrentTrigSliceInit(PWM_SVM_t* const HandlePtr)
{
  XMC_CCU8_SLICE_CompareInit(HandlePtr->phase_ptr[3]->slice_ptr, HandlePtr->current_configinit_ptr);
  XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[3]->slice_ptr, (uint16_t) HandlePtr->period);
  /* Configure external start to event 0 */
  XMC_CCU8_SLICE_ConfigureEvent(HandlePtr->phase_ptr[3]->slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_0,
      HandlePtr->startconfig_ptr);
  XMC_CCU8_EnableClock(HandlePtr->global_ptr,HandlePtr->phase_ptr[3]->slice_number);

  /* Phase current measurement */
  if (HandlePtr->confighandle_ptr->current_measurement == PWM_SVM_PHASECM )
  {
    /* Program timer compare value for channel 1 or channel 2*/
    XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[3]->slice_ptr, HandlePtr->confighandle_ptr->phase_cmpch_map[3],
        ((uint16_t)(HandlePtr->period) >> 1U));
    /* Enable timer one match event  */
    XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr, (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH);
  }
  else if (HandlePtr->confighandle_ptr->current_measurement == PWM_SVM_DCLINKCM )/* DC Link current measurement */
  {
    /* Program timer compare value for channel 1 or channel 2*/
    XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[3]->slice_ptr,
        (XMC_CCU8_SLICE_COMPARE_CHANNEL_t)XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
        ((uint16_t)(HandlePtr->period) >> 2U));
    XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[3]->slice_ptr,
        (XMC_CCU8_SLICE_COMPARE_CHANNEL_t)XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
        ((uint16_t)(HandlePtr->period) >> 1U));
    /* Enable timer compare match event based on svm scheme */
    if ((PWM_SVM_SVMCONFIG_t)PWM_SVM_7SEG_SYMM == HandlePtr->svm_config)
    {
      XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
          (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1);
      XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
          (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1);
      XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
          (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2);
      XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
          (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2);
    }
    else
    {
      XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
          (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1);
      XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
          (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2);
    }
  }
  else
  {
    /*do nothing*/
  }

  HandlePtr->phase_ptr[3]->slice_ptr->SRS |= HandlePtr->confighandle_ptr->event_sr_selector[3];
}
#endif

/* This function updates the compare register values for DC link current measurement */
__INLINE static void PWM_SVM_lUpdateDcLinkComRes(PWM_SVM_t* const HandlePtr)
{

    XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[3]->slice_ptr,
        (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
        (uint16_t)(HandlePtr->v_tb + (uint16_t)(HandlePtr->ta >> (uint16_t) 1)));
    XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[3]->slice_ptr,
        (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
        (uint16_t)(HandlePtr->v_tb + (uint16_t)((uint16_t) HandlePtr->tb >> (uint16_t) 1) + (uint16_t) HandlePtr->ta));

}
static void PWM_SVM_lSymCompValUpdate(PWM_SVM_t* const HandlePtr)
{
  /*Update the compare register with appropriate value  based on sector*/
  switch ((HandlePtr->sector & 7U))
    {
    case 0:/*sector 0*/
      *HandlePtr->phaseu_crs = (uint32_t) HandlePtr->v_tb;
      *HandlePtr->phasev_crs = (uint32_t) (HandlePtr->v_tb + HandlePtr->tb);
      *HandlePtr->phasew_crs = (uint32_t) HandlePtr->v_ta;
       break;
    case 1:/*sector 1*/
      *HandlePtr->phaseu_crs = (uint32_t) (HandlePtr->v_tb + HandlePtr->ta);
      *HandlePtr->phasev_crs = (uint32_t) (HandlePtr->v_tb);
      *HandlePtr->phasew_crs = (uint32_t) HandlePtr->v_ta;
       break;
    case 2:/*sector 2*/
      *HandlePtr->phaseu_crs = (uint32_t) HandlePtr->v_ta;
      *HandlePtr->phasev_crs = (uint32_t) HandlePtr->v_tb;
      *HandlePtr->phasew_crs = (uint32_t) (HandlePtr->v_tb + HandlePtr->tb);
       break;
    case 3:/*sector 3*/
      *HandlePtr->phaseu_crs = (uint32_t) HandlePtr->v_ta;
      *HandlePtr->phasev_crs = (uint32_t)( HandlePtr->v_tb+ HandlePtr->ta);
      *HandlePtr->phasew_crs = (uint32_t) HandlePtr->v_tb;
       break;
    case 4:/*sector 4*/
      *HandlePtr->phaseu_crs = (uint32_t) HandlePtr->v_tb+ HandlePtr->tb;
      *HandlePtr->phasev_crs = (uint32_t) HandlePtr->v_ta;
      *HandlePtr->phasew_crs = (uint32_t) HandlePtr->v_tb;
       break;
    default:/*sector 5*/
      *HandlePtr->phaseu_crs = (uint32_t) HandlePtr->v_tb;
      *HandlePtr->phasev_crs = (uint32_t) HandlePtr->v_ta;
      *HandlePtr->phasew_crs = (uint32_t) HandlePtr->v_tb+ HandlePtr->ta;
      break;
    }
}

static void PWM_SVM_lAsymCompValUpdate(PWM_SVM_t* const HandlePtr)
{
  /* Update the compare register values based on the sector number */
  switch (HandlePtr->sector & 7U)
  {
    case 0:/*sector 0*/
      *HandlePtr->phaseu_crs = (uint32_t) HandlePtr->v_tb;
      *HandlePtr->phaseu_cr2s = (uint32_t) HandlePtr->v_tb2;

      *HandlePtr->phasev_crs = (uint32_t) ((uint32_t) HandlePtr->v_tb + (uint32_t) HandlePtr->tb);
      *HandlePtr->phasev_cr2s = (uint32_t) ((uint32_t) HandlePtr->v_tb + (uint32_t) HandlePtr->tb);

      *HandlePtr->phasew_crs = (uint32_t) HandlePtr->v_ta;
      *HandlePtr->phasew_cr2s = (uint32_t) HandlePtr->v_ta2;
      break;
    case 1:/*sector 1*/
      *HandlePtr->phaseu_crs = (uint32_t) HandlePtr->v_tb + (uint16_t) HandlePtr->ta;
      *HandlePtr->phaseu_cr2s = (uint32_t) HandlePtr->v_tb + (uint16_t) HandlePtr->ta;

      *HandlePtr->phasev_crs = (uint32_t) ((uint16_t) HandlePtr->v_tb);
      *HandlePtr->phasev_cr2s = (uint32_t) ((uint16_t)HandlePtr->v_tb2);

      *HandlePtr->phasew_crs = (uint32_t) HandlePtr->v_ta;
      *HandlePtr->phasew_cr2s = (uint32_t) HandlePtr->v_ta2;
      break;
    case 2:/*sector 2*/
      *HandlePtr->phaseu_crs = (uint32_t) HandlePtr->v_ta;
      *HandlePtr->phaseu_cr2s = (uint32_t) HandlePtr->v_ta2;

      *HandlePtr->phasev_crs = (uint32_t) ((uint16_t) HandlePtr->v_tb);
      *HandlePtr->phasev_cr2s = (uint32_t) ((uint16_t)HandlePtr->v_tb2);

      *HandlePtr->phasew_crs = (uint32_t) HandlePtr->v_tb + (uint16_t) HandlePtr->tb;
      *HandlePtr->phasew_cr2s = (uint32_t) HandlePtr->v_tb + (uint16_t) HandlePtr->tb;
      break;
    case 3:/*sector 3*/
      *HandlePtr->phaseu_crs = (uint32_t) HandlePtr->v_ta;
      *HandlePtr->phaseu_cr2s = (uint32_t) HandlePtr->v_ta2;

      *HandlePtr->phasev_crs = (uint32_t) HandlePtr->v_tb + (uint16_t) HandlePtr->ta;
      *HandlePtr->phasev_cr2s = (uint32_t) HandlePtr->v_tb + (uint16_t) HandlePtr->ta;

      *HandlePtr->phasew_crs = (uint32_t) ((uint16_t) HandlePtr->v_tb);
      *HandlePtr->phasew_cr2s = (uint32_t) ((uint16_t)HandlePtr->v_tb2);
      break;
    case 4:/*sector 4*/
      *HandlePtr->phaseu_crs = (uint32_t) HandlePtr->v_tb + (uint16_t) HandlePtr->tb;
      *HandlePtr->phaseu_cr2s = (uint32_t) HandlePtr->v_tb + (uint16_t) HandlePtr->tb;

      *HandlePtr->phasev_crs = (uint32_t) HandlePtr->v_ta;
      *HandlePtr->phasev_cr2s = (uint32_t) HandlePtr->v_ta2;

      *HandlePtr->phasew_crs = (uint32_t) ((uint16_t) HandlePtr->v_tb);
      *HandlePtr->phasew_cr2s = (uint32_t) ((uint16_t)HandlePtr->v_tb2);
      break;
    default:/*sector 5*/
      *HandlePtr->phaseu_crs = (uint32_t) ((uint16_t) HandlePtr->v_tb);
      *HandlePtr->phaseu_cr2s = (uint32_t) ((uint16_t)HandlePtr->v_tb2);

      *HandlePtr->phasev_crs = (uint32_t) HandlePtr->v_ta;
      *HandlePtr->phasev_cr2s = (uint32_t) HandlePtr->v_ta2;

      *HandlePtr->phasew_crs = (uint32_t) HandlePtr->v_tb + (uint16_t) HandlePtr->ta;
      *HandlePtr->phasew_cr2s = (uint32_t) HandlePtr->v_tb + (uint16_t) HandlePtr->ta;

      break;
  }
}

/**
 * This function calculates the CCU8 slice compare valuefor Symmetric 7-segment SVM.
 */
__INLINE void PWM_SVM_CalCmpValueSym7(PWM_SVM_t* const HandlePtr)
{
  /*If segment time ta less than tmin set to tmin*/
  if (HandlePtr->ta < (uint16_t) HandlePtr->tmin)
  {
    HandlePtr->ta = (uint16_t) HandlePtr->tmin;
  }
  /*If segment time tb less than tmin set to tmin*/
  if (HandlePtr->tb < (uint16_t) HandlePtr->tmin)
  {
    HandlePtr->tb = (uint16_t) HandlePtr->tmin;
  }

  HandlePtr->v_ta = (uint16_t)(((uint32_t) HandlePtr->period + (uint16_t) HandlePtr->ta) + (uint16_t) HandlePtr->tb)
                     >> (uint16_t) 1;
  HandlePtr->v_tb = (uint16_t)((uint16_t) HandlePtr->period - ((uint16_t) HandlePtr->ta + (uint16_t) HandlePtr->tb))
                     >> (uint16_t) 1;
#if (PWM_SVM_IS_DC_LINK_ENABLE == 1U)
  if ((PWM_SVM_CMTYPE_t) PWM_SVM_DCLINKCM == HandlePtr->confighandle_ptr->current_measurement)
  {
    /* Update the compare register values based on the sector number */
    PWM_SVM_lUpdateDcLinkComRes(HandlePtr);
  }
#endif
  /* Update the compare register values based on the sector number */
  PWM_SVM_lSymCompValUpdate(HandlePtr);

}

/**
 * This function calculates the CCU8 slice compare value for Symmetric 5-segment SVM.
 */
__INLINE void PWM_SVM_CalCmpValueSym5(PWM_SVM_t* const HandlePtr)
{
  /*If segment time ta less than tmin set to tmin*/
  if (HandlePtr->ta < HandlePtr->tmin)
  {
    HandlePtr->ta = HandlePtr->tmin;
  }
  /*If segment time tb less than tmin set to tmin*/
  if (HandlePtr->tb < HandlePtr->tmin)
  {
    HandlePtr->tb = HandlePtr->tmin;
  }
  HandlePtr->v_ta = (uint16_t) HandlePtr->period + 1U;
  HandlePtr->v_tb = ((uint16_t) HandlePtr->period - HandlePtr->ta) - HandlePtr->tb;
#if (PWM_SVM_IS_DC_LINK_ENABLE == 1U)
  if ((PWM_SVM_CMTYPE_t) PWM_SVM_DCLINKCM == HandlePtr->confighandle_ptr->current_measurement)
  {
    /* Update the compare register values based on the sector number */
    PWM_SVM_lUpdateDcLinkComRes(HandlePtr);
  }
#endif
  /* Update the compare register values based on the sector number */
  PWM_SVM_lSymCompValUpdate(HandlePtr);
}

/**
 * This function calculates the CCU8 slice compare value for Asymmetric 7-segment SVM.
 */
__INLINE void PWM_SVM_CalCmpValueAsym7(PWM_SVM_t* const HandlePtr)
{
  /* check if ta or tb is not less than Tmin*/
  if (HandlePtr->ta < HandlePtr->tmin)
  {
    HandlePtr->ta = (uint16_t)(2U * (HandlePtr->ta));
    if (HandlePtr->ta < HandlePtr->tmin)
    {
      HandlePtr->ta = HandlePtr->tmin;
    }
    HandlePtr->ta2 = HandlePtr->ta;
  }
  else
  {
    HandlePtr->ta2 = 0U;
  }
  /*  7 -Segment tb value Calcuation */
  if (HandlePtr->tb < HandlePtr->tmin)
  {
    HandlePtr->tb = (uint16_t)(2U * (HandlePtr->tb));
    if (HandlePtr->tb < HandlePtr->tmin)
    {
      HandlePtr->tb = HandlePtr->tmin;
    }
    HandlePtr->tb2 = HandlePtr->tb;
  }
  else
  {
    HandlePtr->tb2 = 0U;
  }
  HandlePtr->v_ta = ((uint16_t) HandlePtr->period + HandlePtr->ta + HandlePtr->tb) >> 1U;
  HandlePtr->v_tb = (uint16_t)((uint16_t) HandlePtr->period - ((uint16_t) HandlePtr->ta + (uint16_t) HandlePtr->tb))
                      >> 1U;

  HandlePtr->v_ta2 = HandlePtr->v_ta - HandlePtr->tb2;
  HandlePtr->v_tb2 = HandlePtr->v_tb + HandlePtr->ta2;
#if (PWM_SVM_IS_DC_LINK_ENABLE == 1U)
  if ((PWM_SVM_CMTYPE_t) PWM_SVM_DCLINKCM == HandlePtr->confighandle_ptr->current_measurement)
  {
    /* Update the compare register values based on the sector number */
    PWM_SVM_lUpdateDcLinkComRes(HandlePtr);
  }
#endif
  /* Update the compare registers*/
  PWM_SVM_lAsymCompValUpdate(HandlePtr);

}

/**
 * This function calculates the CCU8 slice compare value for Asymmetric 5-segment SVM.
 */
__INLINE void PWM_SVM_CalCmpValueAsym5(PWM_SVM_t* const HandlePtr)
{
  /* check if ta or tb is not less than Tmin*/
  if (HandlePtr->ta < HandlePtr->tmin)
  {
    HandlePtr->ta = (uint16_t)(2U * (HandlePtr->ta));
    if (HandlePtr->ta < HandlePtr->tmin)
    {
      HandlePtr->ta = HandlePtr->tmin;
    }
    HandlePtr->ta2 = HandlePtr->ta;
  }
  else
  {
    HandlePtr->ta2 = 0U;
  }
  /*  5 -Segment tb value Calcuation */
  if (HandlePtr->tb < HandlePtr->tmin)
  {
    HandlePtr->tb = HandlePtr->tmin;
  }
  HandlePtr->v_ta = (uint16_t) HandlePtr->period + 1U;
  HandlePtr->v_tb = ((uint16_t) HandlePtr->period - HandlePtr->ta) - HandlePtr->tb;

  HandlePtr->v_ta2 = HandlePtr->v_ta;
  HandlePtr->v_tb2 = HandlePtr->v_tb + HandlePtr->ta2;
#if (PWM_SVM_IS_DC_LINK_ENABLE == 1U)
  if ((PWM_SVM_CMTYPE_t) PWM_SVM_DCLINKCM == HandlePtr->confighandle_ptr->current_measurement)
  {
    /* Update the compare register values based on the sector number */
    PWM_SVM_lUpdateDcLinkComRes(HandlePtr);
  }
#endif
  /* Update the compare register values based on the sector number */
  PWM_SVM_lAsymCompValUpdate(HandlePtr);

}
/**
 * This function calculates the CCU8 slice compare value for Asymmetric 5-segment of Pseudo zero vector SVM mode.
 */
void PWM_SVM_Calc3av5segmentCompVal(PWM_SVM_t* const HandlePtr)
{
  uint16_t cr1s;
  uint16_t cr2s;
  /*calculate compare value intermediate parameters based on subsector*/
  if (HandlePtr->subsector == (uint32_t) 0)
  {
    HandlePtr->tb = HandlePtr->tb + HandlePtr->tmin;
    HandlePtr->v_tb2 = ((uint16_t) HandlePtr->period - (HandlePtr->ta + HandlePtr->tb + HandlePtr->tmin));
    HandlePtr->v_tb = (HandlePtr->v_tb2) >> 1U;
    HandlePtr->v_ta = (uint16_t) HandlePtr->period;
    HandlePtr->v_tc = HandlePtr->v_tb + HandlePtr->tmin;
  }
  else
  {
    HandlePtr->ta = HandlePtr->ta + HandlePtr->tmin;
    HandlePtr->v_tb2 = ((uint16_t) HandlePtr->period - (HandlePtr->ta + HandlePtr->tb + HandlePtr->tmin));
    HandlePtr->v_tb = (HandlePtr->v_tb2) >> 1U;
    HandlePtr->v_ta = (uint16_t) HandlePtr->period;
    HandlePtr->v_tc = HandlePtr->v_tb;
  }
  /*calculate and update compare value of current trigger slice for dc link current measurement*/
  if ((PWM_SVM_CMTYPE_t) PWM_SVM_DCLINKCM == HandlePtr->confighandle_ptr->current_measurement)
  {
    cr1s = (uint16_t) HandlePtr->v_ta - (uint16_t)(HandlePtr->ta + (HandlePtr->tb >> (uint16_t) 1));
    cr2s = (uint16_t) HandlePtr->v_ta - (uint16_t)(HandlePtr->ta >> (uint16_t) 1);
    XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[3]->slice_ptr,
        (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) cr1s);
    XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[3]->slice_ptr,
        (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) cr2s);
  }
  /*Update the compare registers based on sector number*/
  switch (HandlePtr->sector & 7U)
  {
    case 0:/*sector 0*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tc);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - HandlePtr->ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_tb2 + HandlePtr->tmin);
      break;
    case 1:/*sector 1*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tc);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - HandlePtr->ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_tb2 + HandlePtr->tmin);
      break;
    case 2:/*sector 2*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_tb2 + HandlePtr->tmin);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tc);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - HandlePtr->ta);
      break;
    case 3:/*sector 3*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_tb2 + HandlePtr->tmin);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tc);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - HandlePtr->ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);
      break;
    case 4:/*sector 4*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tc);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - HandlePtr->ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_tb2 + HandlePtr->tmin);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);
      break;
    default:/*sector 5*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_tb2 + HandlePtr->tmin);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tc);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - HandlePtr->ta);
      break;
  }

}
/**
 * This function calculates the CCU8 slice compare value for Asymmetric 7-segment of Pseudo zero vector SVM mode.
 */
void PWM_SVM_Calc4av7segmentCompVal(PWM_SVM_t* const HandlePtr)
{
  uint32_t cr1s;
  uint32_t cr2s;
  HandlePtr->ta = HandlePtr->ta + HandlePtr->tmin;
  HandlePtr->tb = HandlePtr->tb + HandlePtr->tmin;

  /*calculation of intermediate compare value parameters*/
  HandlePtr->v_tb2 = (uint16_t)(
      (uint16_t) HandlePtr->period - ((uint16_t) HandlePtr->ta +\
 (uint16_t) HandlePtr->tb + (2U * HandlePtr->tmin)));

  HandlePtr->v_tb = (uint16_t) HandlePtr->v_tb2 >> 2U;
  HandlePtr->v_ta2 = (uint16_t)(HandlePtr->v_tb2 + (2U * HandlePtr->tmin));
  HandlePtr->v_ta = (uint16_t) HandlePtr->period - (uint16_t) HandlePtr->v_tb;

  /*calculate and update compare value of current trigger slice for dc link current measurement*/
  if ((PWM_SVM_CMTYPE_t) PWM_SVM_DCLINKCM == HandlePtr->confighandle_ptr->current_measurement)
  {
    cr1s = (uint32_t) HandlePtr->v_ta - ((uint32_t)(HandlePtr->ta) + ((uint32_t) HandlePtr->tb >> 1U));
    cr2s = (uint32_t) HandlePtr->v_ta - ((uint32_t) HandlePtr->ta >> 1U);
    XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[3]->slice_ptr,
        (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) cr1s);
    XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[3]->slice_ptr,
        (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) cr2s);
  }
  /*Update the compare registers based on sector number*/
  switch (HandlePtr->sector & 7U)
  {
    case 0:/*sector 0*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + (uint16_t)((uint16_t) 2 * HandlePtr->tmin));
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - HandlePtr->ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta2 - HandlePtr->v_tb);
      break;
    case 1:/*sector 1*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - HandlePtr->ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + (uint16_t)((uint16_t) 2 * HandlePtr->tmin));
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta2 - HandlePtr->v_tb);
      break;
    case 2:/*sector 2*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta2 - HandlePtr->v_tb);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + (uint16_t)((uint16_t) 2 * HandlePtr->tmin));
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - HandlePtr->ta);
      break;
    case 3:/*sector 3*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta2 - HandlePtr->v_tb);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - (uint16_t) HandlePtr->ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + (uint16_t)((uint16_t) 2 * HandlePtr->tmin));
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);
      break;
    case 4:/*sector 4*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + (uint16_t) HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - (uint16_t) HandlePtr->ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta2 - (uint16_t) HandlePtr->v_tb);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + (uint16_t)((uint16_t) 2 * HandlePtr->tmin));
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);
      break;
    default:/*sector 5*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + (uint16_t)((uint16_t) 2 * HandlePtr->tmin));
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, (uint16_t) HandlePtr->v_ta);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, (uint16_t) HandlePtr->v_tb);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta2 - (uint16_t) HandlePtr->v_tb);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
          (uint16_t) HandlePtr->v_tb + (uint16_t) HandlePtr->tmin);
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
          (uint16_t) HandlePtr->v_ta - (uint16_t) HandlePtr->ta);
      break;
  }
}

#if defined (MATH)
/*
 * SVM Segment Time calculation using CORDIC
 */
void PWM_SVM_TimecalcUsingCORDIC(PWM_SVM_t* const HandlePtr, uint16_t Amplitude, uint32_t Angle)
{
  uint32_t cosx_amp;
  uint32_t sinx_amp;
  uint32_t cosx;
  uint32_t sinx;
  uint32_t tacord_tmp;
  uint32_t tbcord_tmp;
  uint32_t Angle_tmp;
  uint32_t sine_inv;
  uint16_t ta_tb,ta;
  uint32_t Dividend_Sine, Divisor_Sine;

  XMC_ASSERT("PWM_SVM_lTimecalcUsingCORDIC:NULL Handle Pointer",
      (HandlePtr != (PWM_SVM_t *)NULL));

  Angle_tmp =Angle & (uint32_t)0xFFFFFF;

  HandlePtr->sector = ((uint32_t)((Angle_tmp * 6U) >> 24U) & 7U);
  /*calculate sector angle*/
  HandlePtr->sector_angle = (uint32_t)((Angle_tmp) - (uint32_t)(HandlePtr->sector * PWM_SVM_SIXTYDEG_24BIT));

  /*Clearing previous values of CORDX,CORDY and CORDZ Registers*/
  MATH->STATC = 0U;

  /* Set CORDIC to Circular Operating Mode and Rotation Mode,
   * Auto start of calculation after write access to X parameter data register,
   * X result data format to Unsigned, when read,
   * After the last iteration of calculation the X & Y values are divided by 1
   */
  MATH->CON = (uint32_t)0x2A;

  /*Input sector angle*/
  MATH->CORDZ = (uint32_t)(HandlePtr->sector_angle << ((uint32_t)MATH_CORDZ_DATA_Pos));

  /* Set the Y value to zero*/
  MATH->CORDY =  (uint32_t)(0U << MATH_CORDY_DATA_Pos);

  /*Load the amplitude value */
  MATH->CORDX =  (uint32_t)(1024 << MATH_CORDX_DATA_Pos);

  /*Checking busy status of CORDIC calculation*/
  while (MATH->STATC & 0x1U)
  {
  };

  /*Reading cordic X result which is costheta X amplitude*/
  cosx_amp = (MATH->CORRX >> MATH_CORDX_DATA_Pos);
  cosx     = (cosx_amp * PWM_SVM_KCOSSCALE)>>10;
  cosx_amp = cosx * Amplitude;
  /*Reading cordic Y result which is sintheta X amplitude*/
  sinx_amp = (MATH->CORRY >> MATH_CORDY_DATA_Pos);
  sinx     = (sinx_amp * PWM_SVM_KSINSCALE)>>10;
  sinx_amp = sinx * Amplitude;

  if ((uint16_t)Amplitude > (HandlePtr->max_amplitude))
  {
    Amplitude = HandlePtr->max_amplitude;
  }

   /* Multiply Result value with sinscale to eliminate gain factor K*/
   tacord_tmp = (uint32_t)(sinx_amp>>14U);
   HandlePtr->ta = (uint16_t)((tacord_tmp * (uint32_t)HandlePtr->confighandle_ptr->amplitude_scale) >> 10U);

   /* Multiply Result value with cosscale to eliminate gain factor K*
    * sin(60-Angle) = (Sqrt(3)*cos(angle) - sin(angle))/2
    */
   tbcord_tmp = (uint32_t)((cosx_amp - sinx_amp))>>15U;
   HandlePtr->tb = (uint16_t)((tbcord_tmp * (uint32_t)HandlePtr->confighandle_ptr->amplitude_scale) >> 10U);

  ta_tb = HandlePtr->ta + HandlePtr->tb;
  HandlePtr->t0 = HandlePtr->period - ta_tb;

  if (ta_tb > (HandlePtr->period))
  {
    if (HandlePtr->over_modulation_enable == 1U)
    {

      /* Above Ta and Tb are not used for SVM PWM.*/

      Dividend_Sine = HandlePtr->period * (sinx >> 14U);
      sine_inv = (cosx - sinx) >> 15U;
      Divisor_Sine  = sinx + sine_inv;
      #if defined (MATH)
      /*###* Divider Unit (DIV) #2 for T2 of Over-Modulation *###*/
      /* Unsigned Div. Dividend << SHIFT_OVERMODULATION, Quotient >> SHIFT_OVERMODULATION, Divisor no shift.*/
      MATH->DIVCON = (0x00008004 | (PWM_SVM_SHIFT_OVERMODULATION << 16U) | (PWM_SVM_SHIFT_OVERMODULATION << 8U));
      MATH->DVD = Dividend_Sine;
      MATH->DVS = Divisor_Sine;
      #else
      ta = (Dividend_Sine/Divisor_Sine);
      #endif
      /*###* CPU computes the following simultaneously when DIV #2 is computing ###*/
      HandlePtr->t0 = 0;
      ta_tb = HandlePtr->period;                /* Make sure below T0/2 >= 0.*/
      #if defined (MATH)
      /*###* Results of DIV #2 for T2 of Over-Modulation ###*/
      while (MATH->DIVST) continue;          /* Wait if DIV is still running calculation.*/
      ta = MATH->QUOT;     /* Read DIV Quotient result. T2 = Ts x sin(theta) / (sin(theta)+sin(60-theta)).*/
      #endif
      HandlePtr->ta = ta;
      /* Ta + Tb = PERIOD_REG for Vref on SVM Hexagon edges.*/
      HandlePtr->tb = HandlePtr->period - HandlePtr->ta;

    }
  }
  /* If ta and tb values are less then zero, reset these values to zero */
  if (HandlePtr->ta > HandlePtr->period)
  {
    HandlePtr->ta = 0U;
  }
  if (HandlePtr->tb > HandlePtr->period)
  {
    HandlePtr->tb = 0U;
  }
}
#endif
#if(1U == PWM_SVM_IS_LUT_ENABLE)
/*
 * SVM Segment Time calculation using Look up table
 */
void PWM_SVM_TimecalcUsingLUT(PWM_SVM_t* const HandlePtr, uint16_t Amplitude, uint32_t Angle)
{
  uint32_t angletemp;
  uint16_t ta_tb,ta;
  uint32_t Dividend_Sine, Divisor_Sine;        /*Ts x sin(θrel), sin(θrel)+sin(60°-θrel)*/
  XMC_ASSERT("PWM_SVM_lTimecalcUsingLUT:NULL Handle Pointer",
      (HandlePtr != (PWM_SVM_t *)NULL));

  angletemp = (uint32_t)((Angle & (uint32_t)0xFFFFFF) >> 14U) * 6U;
  HandlePtr->sector_angle = (uint32_t)(angletemp & (uint32_t) 0x003FF);
  HandlePtr->sector = (uint32_t)((angletemp >> 10U) & 7U);
  if ((uint16_t)Amplitude > (HandlePtr->max_amplitude))
  {
    Amplitude = HandlePtr->max_amplitude;
  }
  HandlePtr->tb = (uint16_t)((Amplitude* Sinus60_tab[1023U - HandlePtr->sector_angle])>> 15U);
  HandlePtr->tb = (uint16_t)((HandlePtr->tb * HandlePtr->confighandle_ptr->amplitude_scale) >> 10U);

  HandlePtr->ta = (uint16_t)((Amplitude* Sinus60_tab[HandlePtr->sector_angle])>> 15U);
  HandlePtr->ta = (uint16_t)((HandlePtr->ta * HandlePtr->confighandle_ptr->amplitude_scale) >> 10U);
  ta_tb = HandlePtr->ta + HandlePtr->tb;
  HandlePtr->t0 = (uint16_t)(HandlePtr->period - ta_tb);

  if (ta_tb > (HandlePtr->period))
  {
    if (HandlePtr->over_modulation_enable == 1U)
    {

      /* Above Ta and Tb are not used for SVM PWM.*/

      /* Calculate new T1 and T2 of maximum Vref on SVM Hexagon edges,
       * where T0 = 0 (i.e.: T1+T2 = PERIOD_REG). Relative angle θrel kept the same.
       */
      Dividend_Sine = HandlePtr->period * Sinus60_tab[HandlePtr->sector_angle];
      Divisor_Sine  = Sinus60_tab[HandlePtr->sector_angle] + Sinus60_tab[1023U - HandlePtr->sector_angle];
      #if defined (MATH)
      /*###* Divider Unit (DIV) #2 for T2 of Over-Modulation *###*/
      /* Unsigned Div. Dividend << SHIFT_OVERMODULATION, Quotient >> SHIFT_OVERMODULATION, Divisor no shift.*/
      MATH->DIVCON = (0x00008004 | (PWM_SVM_SHIFT_OVERMODULATION << 16U) | (PWM_SVM_SHIFT_OVERMODULATION << 8U));
      MATH->DVD = Dividend_Sine;
      MATH->DVS = Divisor_Sine;
      #else
      ta = (uint16_t)(Dividend_Sine/Divisor_Sine);
      #endif
      /*###* CPU computes the following simultaneously when DIV #2 is computing ###*/
      HandlePtr->t0 = 0U;
      ta_tb = (uint16_t)HandlePtr->period;                /* Make sure below T0/2 >= 0.*/
      #if defined (MATH)
      /*###* Results of DIV #2 for T2 of Over-Modulation ###*/
      while (MATH->DIVST) continue;          /* Wait if DIV is still running calculation.*/
      ta = MATH->QUOT;     /* Read DIV Quotient result. T2 = Ts x sin(theta) / (sin(theta)+sin(60-theta)).*/
      #endif
      HandlePtr->ta = ta;
      /* Ta + Tb = PERIOD_REG for Vref on SVM Hexagon edges.*/
      HandlePtr->tb = (uint16_t)(HandlePtr->period - HandlePtr->ta);

    }
  }
}
#endif
/*******************************************************************************
 **                      Public Function Definitions                           **
 *******************************************************************************/
/* App API to retrieve the App version info */
DAVE_APP_VERSION_t PWM_SVM_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = PWM_SVM_MAJOR_VERSION;
  version.minor = PWM_SVM_MINOR_VERSION;
  version.patch = PWM_SVM_PATCH_VERSION;

  return version;
}

/**
 * This function initializes the peripherals and SVM structure 
 * required for the SVM algorithm.
 */
PWM_SVM_STATUS_t PWM_SVM_Init(PWM_SVM_t* const HandlePtr)
{
  uint32_t count = 0U;
  uint32_t phase_count = 0U;
  PWM_SVM_STATUS_t status = (PWM_SVM_STATUS_t) PWM_SVM_STATUS_SUCCESS;
  const PWM_SVM_Config_t* const svmptr = HandlePtr->confighandle_ptr;
  XMC_ASSERT("PWM_SVM_Init:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  if ((PWM_SVM_STATE_t) PWM_SVM_UNINITIALIZED == HandlePtr->state)
  {
    status = (PWM_SVM_STATUS_t) GLOBAL_CCU8_Init(HandlePtr->globalccu8_handle_ptr);
    /*Configure io init for all three phases output*/
    for (phase_count = 0U; phase_count < PWM_SVM_PHASE_IO_MAX; phase_count++)
    {
      XMC_GPIO_Init(HandlePtr->pwmoutpin_ptr[phase_count]->port, HandlePtr->pwmoutpin_ptr[phase_count]->pin,
          HandlePtr->pwmoutconfig_ptr[phase_count]);
    }
    /*Configure io init for trap input*/
    if ((uint8_t) true == svmptr->enable_trap)
    {
      XMC_GPIO_Init(HandlePtr->trappin_ptr->port, HandlePtr->trappin_ptr->pin, HandlePtr->trapinconfig_ptr);
      XMC_GPIO_SetHardwareControl(HandlePtr->trappin_ptr->port, HandlePtr->trappin_ptr->pin,
          HandlePtr->confighandle_ptr->trap_hwsel);
    }

    /*Configure io init for inverter enable pin output*/
    if (svmptr->inverter_pin > (PWM_SVM_INVERTERPINLEVEL_t) PWM_SVM_IPIN_NOTREQUIRED)
    {
      XMC_GPIO_Init(HandlePtr->inverterpin_ptr->port, HandlePtr->inverterpin_ptr->pin,
          HandlePtr->inverterpinconfig_ptr);
    }

    /*Inverter Enable pin level is set to passive level.*/
    PWM_SVM_InverterDisable(HandlePtr);

    /* Phase configurations */
    for (count = 0U; count < PWM_SVM_NUMBERPHASE; count++)
    {
      XMC_CCU8_SLICE_CompareInit(HandlePtr->phase_ptr[count]->slice_ptr, HandlePtr->phase_configinit_ptr);

      /* configure dead time */
      XMC_CCU8_SLICE_DeadTimeInit(HandlePtr->phase_ptr[count]->slice_ptr, HandlePtr->deadtimeconfig_ptr);

      /* Configure external start to event 0 */
      XMC_CCU8_SLICE_ConfigureEvent(HandlePtr->phase_ptr[count]->slice_ptr,
          (XMC_CCU8_SLICE_EVENT_t) XMC_CCU8_SLICE_EVENT_0, HandlePtr->startconfig_ptr);
      /* if trap is enabled, Enable Trap for all the three phases
       map the external trap functionality to event 2 */
      if ((uint8_t) true == svmptr->enable_trap)
      {
        XMC_CCU8_SLICE_ConfigureEvent(HandlePtr->phase_ptr[count]->slice_ptr, XMC_CCU8_SLICE_EVENT_2,
            HandlePtr->trapconfig_ptr);
        XMC_CCU8_SLICE_TrapConfig(HandlePtr->phase_ptr[count]->slice_ptr, svmptr->trap_exit_mode,
            (bool)svmptr->trap_sync_pwm);
      }

      /* Program period  value of the timer  */
      XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[count]->slice_ptr, (uint16_t) HandlePtr->period);
      /* Program timer compare value for channel 1 or channel 2*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[count]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_1, 0U);
      /* Program timer compare value for channel 1 or channel 2*/
      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[count]->slice_ptr,
          (XMC_CCU8_SLICE_COMPARE_CHANNEL_t) XMC_CCU8_SLICE_COMPARE_CHANNEL_2, 0U);
      /* Configures status ST1, ST2 mapping to STy */
      XMC_CCU8_SLICE_ConfigureStatusBitOutput(HandlePtr->phase_ptr[count]->slice_ptr,
          HandlePtr->confighandle_ptr->phase_st_map[count]);

      /* Bind period match event to an NVIC node  */
      HandlePtr->phase_ptr[count]->slice_ptr->SRS |= svmptr->event_sr_selector[count];

      /* enable module clock by clearing idle bit*/
      XMC_CCU8_EnableClock(HandlePtr->global_ptr, HandlePtr->phase_ptr[count]->slice_number);
    }

    PWM_SVM_lEnableEvent(HandlePtr);

    /* Current trigger slice configurations */
#if(1U == PWM_SVM_IS_CURRENTTRIGGER_ENABLE)
    if ((PWM_SVM_CMTYPE_t)PWM_SVM_NONE != svmptr->current_measurement)
    {
      PWM_SVM_lCurrentTrigSliceInit(HandlePtr);
    }
#endif

#if defined (MATH)
      /*Ungate Math coprocessor*/
      XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_MATH);
#endif
    /*Enable the shadow transfer for all three slice*/
    XMC_CCU8_EnableShadowTransfer(HandlePtr->global_ptr, svmptr->shadow_transfer_mask);

    /* update dead time variable*/
    HandlePtr->deadtime_rising_edge = HandlePtr->deadtimeconfig_ptr->channel1_st_rising_edge_counter;
    HandlePtr->deadtime_falling_edge = HandlePtr->deadtimeconfig_ptr->channel1_st_falling_edge_counter;
    HandlePtr->deadtime_div = (XMC_CCU8_SLICE_DTC_DIV_t) HandlePtr->deadtimeconfig_ptr->div;

    if ((PWM_SVM_STATUS_t) PWM_SVM_STATUS_FAILURE != status)
    {
      status = PWM_SVM_STATUS_SUCCESS;
      HandlePtr->state = (PWM_SVM_STATE_t) PWM_SVM_INITIALIZED;
    }
    else
    {
      status = PWM_SVM_STATUS_FAILURE;
    }
  }

  return (status);
}

/**
 * This function starts the CCU8 slices used to generate SVM.
 */
void PWM_SVM_Start(PWM_SVM_t* const HandlePtr)
{
  uint32_t count = 0U;
  const PWM_SVM_Config_t* const svmptr = HandlePtr->confighandle_ptr;
  XMC_ASSERT("PWM_SVM_Start:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  if (((PWM_SVM_STATE_t) PWM_SVM_INITIALIZED == HandlePtr->state)
      || ((PWM_SVM_STATE_t) PWM_SVM_STOPPED == HandlePtr->state))
  {
    HandlePtr->ta = 0U;
    HandlePtr->tb = 0U;
    HandlePtr->ta2 = 0U;
    HandlePtr->tb2 = 0U;
    HandlePtr->v_ta = 0U;
    HandlePtr->v_tb = 0U;
    HandlePtr->v_ta2 = 0U;
    HandlePtr->v_tb2 = 0U;
    HandlePtr->sector = 0U;
    HandlePtr->subsector = 0U;

    /*Enable Inverter*/
    PWM_SVM_InverterEnable(HandlePtr);

    for (count = 0U; count < PWM_SVM_NUMBERPHASE; count++)
    {
      /* if trap is enabled, Enable Trap for all the three phases
       map the external trap functionality to event 2 */
      if ((uint8_t) true == svmptr->enable_trap)
      {
        XMC_CCU8_SLICE_ClearEvent(HandlePtr->phase_ptr[count]->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT2);
        XMC_CCU8_SLICE_ClearEvent(HandlePtr->phase_ptr[count]->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_TRAP);
      }
      /* configure the Start trigger function*/
      XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[count]->slice_ptr,
          (XMC_CCU8_SLICE_EVENT_t) XMC_CCU8_SLICE_EVENT_0,
          (XMC_CCU8_SLICE_START_MODE_t) XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
    }

    if ((uint8_t) true == svmptr->enable_trap)
    {
      /* Enables trap feature for phase u out 0 and 1*/
      XMC_CCU8_SLICE_EnableTrap(HandlePtr->phase_ptr[0]->slice_ptr,
          ((uint32_t) svmptr->phase_u_out0 | ((uint32_t) svmptr->phase_u_out0 << 1U)));

      /* Enables trap feature for phase v out 0 and 1*/
      XMC_CCU8_SLICE_EnableTrap(HandlePtr->phase_ptr[1]->slice_ptr,
          ((uint32_t) svmptr->phase_v_out0 | ((uint32_t) svmptr->phase_v_out0 << 1U)));

      /* Enables trap feature for phase w out 0 and 1*/
      XMC_CCU8_SLICE_EnableTrap(HandlePtr->phase_ptr[2]->slice_ptr,
          ((uint32_t) svmptr->phase_w_out0 | ((uint32_t) svmptr->phase_w_out0 << 1U)));
    }

    /*enable module clock by clearing idle bit if any of current measurement is selected */
    if ((PWM_SVM_CMTYPE_t) PWM_SVM_NONE != svmptr->current_measurement)
    {
      XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[3]->slice_ptr, (XMC_CCU8_SLICE_EVENT_t) XMC_CCU8_SLICE_EVENT_0,
          (XMC_CCU8_SLICE_START_MODE_t) XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);

      /* offset for current measurement trigger */
      if ((PWM_SVM_CMTYPE_t) PWM_SVM_DCLINKCM == svmptr->current_measurement)
      {
        XMC_CCU8_SLICE_SetTimerValue(HandlePtr->phase_ptr[0]->slice_ptr,
            (uint16_t)((uint16_t)(HandlePtr->tmin >> (uint16_t) 1) + (uint16_t) svmptr->current_offset));
        XMC_CCU8_SLICE_SetTimerValue(HandlePtr->phase_ptr[1]->slice_ptr,
            (uint16_t)((uint16_t)(HandlePtr->tmin >> (uint16_t) 1) + (uint16_t) svmptr->current_offset));
        XMC_CCU8_SLICE_SetTimerValue(HandlePtr->phase_ptr[2]->slice_ptr,
            (uint16_t)((uint16_t)(HandlePtr->tmin >> (uint16_t) 1) + (uint16_t) svmptr->current_offset));
      }
      else
      {
        XMC_CCU8_SLICE_SetTimerValue(HandlePtr->phase_ptr[0]->slice_ptr,
            (uint16_t)((((uint16_t) HandlePtr->deadtime_rising_edge) & (uint16_t) 0xFF)
                    + (uint16_t) svmptr->current_offset));
        XMC_CCU8_SLICE_SetTimerValue(HandlePtr->phase_ptr[1]->slice_ptr,
            (uint16_t)((((uint16_t) HandlePtr->deadtime_rising_edge) & (uint16_t) 0xFF)
                    + (uint16_t) svmptr->current_offset));
        XMC_CCU8_SLICE_SetTimerValue(HandlePtr->phase_ptr[2]->slice_ptr,
            (uint16_t)((((uint16_t) HandlePtr->deadtime_rising_edge ) & (uint16_t) 0xFF)
                    + (uint16_t) svmptr->current_offset));
      }
    }

    /* synchronous start of CCU8 slices */
    XMC_SCU_SetCcuTriggerHigh((uint32_t)(svmptr->sync_start_mask));

    /* disable the Start trigger function*/
    XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[0]->slice_ptr, (XMC_CCU8_SLICE_EVENT_t) XMC_CCU8_SLICE_EVENT_NONE,
        (XMC_CCU8_SLICE_START_MODE_t) XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
    XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[1]->slice_ptr, (XMC_CCU8_SLICE_EVENT_t) XMC_CCU8_SLICE_EVENT_NONE,
        (XMC_CCU8_SLICE_START_MODE_t) XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
    XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[2]->slice_ptr, (XMC_CCU8_SLICE_EVENT_t) XMC_CCU8_SLICE_EVENT_NONE,
        (XMC_CCU8_SLICE_START_MODE_t) XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
    if ((PWM_SVM_CMTYPE_t) PWM_SVM_NONE != svmptr->current_measurement)
    {
      XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[3]->slice_ptr, (XMC_CCU8_SLICE_EVENT_t) XMC_CCU8_SLICE_EVENT_NONE,
          (XMC_CCU8_SLICE_START_MODE_t) XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
    }

    /* disable synchronous start of CCU8 slices */
    XMC_SCU_SetCcuTriggerLow((uint32_t)(svmptr->sync_start_mask));

    /* change the state to RUNNING*/
    HandlePtr->state = PWM_SVM_RUNNING;
  }
}

/**
 * This function stops the CCU8 slices used to generate SVM.
 */
void PWM_SVM_Stop(PWM_SVM_t* const HandlePtr)
{
  uint32_t count;
  const PWM_SVM_Config_t* const svmptr = HandlePtr->confighandle_ptr;
  XMC_ASSERT("PWM_SVM_Stop:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  /*Inverter Enable pin level is set to passive level.*/
  PWM_SVM_InverterDisable(HandlePtr);

  /* Disable trap */
  if ((uint8_t) 1 == svmptr->enable_trap)
  {
    /* Disables trap feature for phase u out 0 and 1*/
    XMC_CCU8_SLICE_DisableTrap(HandlePtr->phase_ptr[0]->slice_ptr,
        ((uint32_t) svmptr->phase_u_out0 | ((uint32_t) svmptr->phase_u_out0 << 1U)));

    /* Disables trap feature for phase v out 0 and 1*/
    XMC_CCU8_SLICE_DisableTrap(HandlePtr->phase_ptr[1]->slice_ptr,
        ((uint32_t) svmptr->phase_v_out0 | ((uint32_t) svmptr->phase_v_out0 << 1U)));

    /* Disables trap feature for phase w out 0 and 1*/
    XMC_CCU8_SLICE_DisableTrap(HandlePtr->phase_ptr[2]->slice_ptr,
        ((uint32_t) svmptr->phase_w_out0 | ((uint32_t) svmptr->phase_w_out0 << 1U)));

    XMC_CCU8_SLICE_ClearEvent(HandlePtr->phase_ptr[0]->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_TRAP);
    XMC_CCU8_SLICE_ClearEvent(HandlePtr->phase_ptr[1]->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_TRAP);
    XMC_CCU8_SLICE_ClearEvent(HandlePtr->phase_ptr[2]->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_TRAP);
  }

  /* stop all three phases */
  for (count = 0U; count < PWM_SVM_NUMBERPHASE; count++)
  {
    XMC_CCU8_SLICE_StopTimer(HandlePtr->phase_ptr[count]->slice_ptr);
  }
  if ((PWM_SVM_CMTYPE_t) PWM_SVM_NONE != svmptr->current_measurement)
  {
    XMC_CCU8_SLICE_StopTimer(HandlePtr->phase_ptr[3]->slice_ptr);
  }

  XMC_SCU_SetCcuTriggerLow((uint32_t) svmptr->sync_start_mask);
  HandlePtr->state = (PWM_SVM_STATE_t) PWM_SVM_STOPPED;

}

/**
 * This is the SVM algorithm for sinusoidal commutation.
 * It updates the compare registers of the CCU8 slices as per calculated
 * duty cycle.
 */
void PWM_SVM_SVMUpdate(PWM_SVM_t* const HandlePtr, uint16_t Amplitude, uint32_t Angle)
{
  const PWM_SVM_Config_t* const svmptr = HandlePtr->confighandle_ptr;
  XMC_ASSERT("PWM_SVM_SVMUpdate:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));

  /*This function calculates segment time ta, tb using CORDIC or LUT as per UI configuration */
  HandlePtr->seg_time_calc_ptr(HandlePtr, (uint16_t) Amplitude, (uint32_t) Angle);
  /*This function calculates and updates compare values in compare register*/
  HandlePtr->svm_schemesel_ptr(HandlePtr);

  /*Enable the shadow transfer for all three slice*/
  HandlePtr->global_ptr->GCSS |= svmptr->shadow_transfer_mask;
}


/*This API updates the PWM Frequency in terms of hertz*/
PWM_SVM_STATUS_t PWM_SVM_SetPWMFrequency(PWM_SVM_t* const HandlePtr, uint32_t Frequency)
{
  uint32_t pwm_time;
  uint32_t period;
  uint32_t count;
  uint32_t max_amplitude_count;
  PWM_SVM_STATUS_t status = PWM_SVM_STATUS_FAILURE;
  const PWM_SVM_Config_t* const svmptr = HandlePtr->confighandle_ptr;
  XMC_ASSERT("PWM_SVM_SetPWMFrequency:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));

  if (((PWM_SVM_STATE_t) PWM_SVM_INITIALIZED == HandlePtr->state)
      || ((PWM_SVM_STATE_t) PWM_SVM_STOPPED == HandlePtr->state))
  {
    if ((Frequency > HandlePtr->confighandle_ptr->period_min) && (Frequency <= HandlePtr->confighandle_ptr->period_max))
    {
      pwm_time = (uint32_t)((svmptr->module_freq) / Frequency);

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_EA == HandlePtr->phase_configinit_ptr->timer_mode) /* EDGE_ALIGNED */
      {
        period = (uint32_t)(pwm_time - 1U);
      }
      else /*CENTER_ALIGNED - hence half of the calculated period value is used*/
      {
        period = (uint32_t)((pwm_time >> 1U) - 1U);
      }
      /*set max amplitude for pseudo null vector based on scheme*/
      if ((PWM_SVM_SVMCONFIG_t) PWM_SVM_PSEUDONULL_3ACTIVE == HandlePtr->svm_config)
      {
        max_amplitude_count = (uint32_t)((uint32_t)PWM_SVM_MAX_AMPLITUDE - (uint32_t)((uint32_t) 3 * (uint32_t) HandlePtr->tmin_14));
      }
      else if ((PWM_SVM_SVMCONFIG_t) PWM_SVM_PSEUDONULL_4ACTIVE == HandlePtr->svm_config)
      {
        max_amplitude_count = (uint32_t)((uint32_t)PWM_SVM_MAX_AMPLITUDE - (uint32_t)((uint32_t) 4 * (uint32_t) HandlePtr->tmin_14));
      }
      else
      {
        max_amplitude_count = (uint32_t) PWM_SVM_MAX_AMPLITUDE;
      }
      /*update the calcualted period value in period register*/
      for (count = 0U; count < PWM_SVM_NUMBERPHASE; count++)
      {
        XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[count]->slice_ptr, (uint16_t) period);
      }
      if ((PWM_SVM_CMTYPE_t) PWM_SVM_NONE != HandlePtr->confighandle_ptr->current_measurement)
      {
        XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[3]->slice_ptr, (uint16_t) period);
      }

      /*Enable the shadow transfer for all three slice*/
      XMC_CCU8_EnableShadowTransfer(HandlePtr->global_ptr, svmptr->shadow_transfer_mask);
      /* update dynamic handle parameters */
      HandlePtr->period = (uint32_t) period;
      HandlePtr->max_amplitude = (uint16_t) max_amplitude_count;
      status = PWM_SVM_STATUS_SUCCESS;
    }
    else
    {
      status = PWM_SVM_INVALID_PARAM;
    }
  }
  return status;
}

/*This API returns the PWM Frequency in terms of hertz*/
uint32_t PWM_SVM_GetPWMFrequency(PWM_SVM_t* const HandlePtr)
{
  uint32_t frequency;
  const PWM_SVM_Config_t* const svmptr = HandlePtr->confighandle_ptr;
  XMC_ASSERT("PWM_SVM_GetPWMFrequency:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));

  /*calculate the frequency based on timer mode*/
  if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_EA == HandlePtr->phase_configinit_ptr->timer_mode) /* EDGE_ALIGNED */
  {
    frequency = (uint32_t)((uint32_t) svmptr->module_freq / ((uint32_t) HandlePtr->period + 1U));
  }
  else
  {
    frequency = (uint32_t)((uint32_t) svmptr->module_freq / (((uint32_t) HandlePtr->period + 1U) << 1U));
  }
  /*return the calculated frequency*/
  return (frequency);
}

/*This API updates the ccu8 pwm phase deadtime dynamically*/
/*This API sets the dead time value in terms of nano seconds*/
PWM_SVM_STATUS_t PWM_SVM_SetDeadTime(PWM_SVM_t* const HandlePtr, uint32_t DeadTimeRisingEdge,
                                     uint32_t DeadTimeFallingEdge)
{
  uint32_t deadtime_count;
  uint32_t count;
  uint32_t deadtime_max;
  PWM_SVM_STATUS_t status = PWM_SVM_STATUS_SUCCESS;
  XMC_CCU8_SLICE_DTC_DIV_t prescaler = HandlePtr->deadtime_div;
  const PWM_SVM_Config_t* const svmptr = HandlePtr->confighandle_ptr;
  uint32_t dead_time_scale = ((svmptr->module_freq >> (uint32_t) prescaler) / PWM_SVM_MILLISECCONV);
  XMC_ASSERT("PWM_SVM_SetDeadTime:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  /*Check for maximum dead time */
  if (DeadTimeRisingEdge > DeadTimeFallingEdge)
  {
    deadtime_max = DeadTimeRisingEdge;
  }
  else
  {
    deadtime_max = DeadTimeFallingEdge;
  }
  if ((deadtime_max > PWM_SVM_DEADTIME_LOWERLIMIT) && (deadtime_max <= PWM_SVM_DEADTIME_UPPERLIMIT))
  {
    deadtime_count = (uint32_t)((deadtime_max * dead_time_scale) / PWM_SVM_MICROSECCONV);

    while ((deadtime_count > PWM_SVM_DEADTIME_REG_MAX) && ((uint32_t) prescaler <= PWM_SVM_DEADTIME_DIV_MAX))
    {
      prescaler++;
      dead_time_scale = ((svmptr->module_freq >> (uint32_t) prescaler) / PWM_SVM_MILLISECCONV);
      deadtime_count = (uint32_t)((deadtime_max * dead_time_scale) / PWM_SVM_MICROSECCONV);
    }

    if (DeadTimeRisingEdge > DeadTimeFallingEdge)
    {
      HandlePtr->deadtime_rising_edge = deadtime_count;
      HandlePtr->deadtime_falling_edge = (uint32_t)((DeadTimeFallingEdge * dead_time_scale) / PWM_SVM_MICROSECCONV);
    }
    else
    {
      HandlePtr->deadtime_falling_edge = deadtime_count;
      HandlePtr->deadtime_rising_edge = (uint32_t)((DeadTimeRisingEdge * dead_time_scale) / PWM_SVM_MICROSECCONV);
    }

    /*configure the calculated deadtime*/
    for (count = 0U; count < PWM_SVM_NUMBERPHASE; count++)
    {
      /* configure dead time */
      XMC_CCU8_SLICE_SetDeadTimeValue(HandlePtr->phase_ptr[count]->slice_ptr,
          HandlePtr->confighandle_ptr->phase_cmpch_map[0], (uint8_t) HandlePtr->deadtime_rising_edge,
          (uint8_t) HandlePtr->deadtime_falling_edge);
      XMC_CCU8_SLICE_SetDeadTimePrescaler(HandlePtr->phase_ptr[count]->slice_ptr, (XMC_CCU8_SLICE_DTC_DIV_t) prescaler);
    }

    HandlePtr->deadtime_div = prescaler;
  }
  else
  {
    status = PWM_SVM_INVALID_PARAM;
  }
  return status;
}

/*This API returns the rising edge dead time */
uint32_t PWM_SVM_GetRisingEdgeDeadTime(PWM_SVM_t* const HandlePtr)
{
  uint32_t deadtime;
  uint32_t dead_time_scale = (PWM_SVM_NANOSECCONV
      / ((HandlePtr->confighandle_ptr->module_freq / PWM_SVM_MILLISECCONV) >> (uint32_t) HandlePtr->deadtime_div));
  XMC_ASSERT("PWM_SVM_GetRisingEdgeDeadTime:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  /* calculate the deadtime from dead time count*/
  deadtime = (uint32_t)((HandlePtr->deadtime_rising_edge * dead_time_scale) / PWM_SVM_MILLISECCONV);
  return (deadtime);
}

/*This API returns the falling edge dead time*/
uint32_t PWM_SVM_GetFallingEdgeDeadTime(PWM_SVM_t* const HandlePtr)
{
  uint32_t deadtime;
  uint32_t dead_time_scale = (PWM_SVM_NANOSECCONV
      / ((HandlePtr->confighandle_ptr->module_freq / PWM_SVM_MILLISECCONV) >> (uint32_t) HandlePtr->deadtime_div));
  XMC_ASSERT("PWM_SVM_GetFallingEdgeDeadTime:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  /* calculate the deadtime from dead time count*/
  deadtime = (uint32_t)((HandlePtr->deadtime_falling_edge * dead_time_scale) / PWM_SVM_MILLISECCONV);
  return (deadtime);
}

/*This API sets the Tmin value in terms of nano seconds*/
PWM_SVM_STATUS_t PWM_SVM_SetTmin(PWM_SVM_t* const HandlePtr, uint32_t Tmin)
{
  uint32_t tmin_scale = (uint32_t)(HandlePtr->confighandle_ptr->module_freq / PWM_SVM_MILLISECCONV);
  PWM_SVM_STATUS_t status = PWM_SVM_STATUS_SUCCESS;
  XMC_ASSERT("PWM_SVM_SetTmin:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  if (Tmin <= PWM_SVM_TMIN_LIMIT)
  {
    /* calculate the Tmin to Tmin count*/
    HandlePtr->tmin = (uint16_t)(((uint32_t)(Tmin * tmin_scale)) / PWM_SVM_MICROSECCONV);
  }
  else
  {
    status = PWM_SVM_INVALID_PARAM;
  }
  return (status);
}

/*returns the Tmin value in terms of nano second*/
uint32_t PWM_SVM_GetTmin(PWM_SVM_t* const HandlePtr)
{
  uint32_t tmin_scale = (PWM_SVM_NANOSECCONV / (HandlePtr->confighandle_ptr->module_freq /
  PWM_SVM_MILLISECCONV));
  XMC_ASSERT("PWM_SVM_GetTmin:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  return (uint32_t)(((uint32_t) HandlePtr->tmin * tmin_scale) / PWM_SVM_MILLISECCONV);
}

/*This API modifies the SVM scheme dynamically*/
PWM_SVM_STATUS_t PWM_SVM_SetSVMScheme(PWM_SVM_t* const HandlePtr, PWM_SVM_SVMCONFIG_t Scheme)
{
  PWM_SVM_STATUS_t status = PWM_SVM_STATUS_SUCCESS;
  XMC_ASSERT("PWM_SVM_SetSVMScheme:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  if ((Scheme == PWM_SVM_7SEG_SYMM) || (Scheme == PWM_SVM_5SEG_SYMM))
  {
    /* It is possible to change the SVM scheme in RUNNING state if timer counting and compare mode are maintained */
    if ((PWM_SVM_RUNNING == HandlePtr->state))
    {
      PWM_SVM_lDynamicSVMSchemeModification(HandlePtr, Scheme);
    }
    /* when PWM is stopped, SVM scheme can be changed without any constraint */
    else if (((PWM_SVM_STATE_t) PWM_SVM_INITIALIZED == HandlePtr->state)
        || ((PWM_SVM_STATE_t) PWM_SVM_STOPPED == HandlePtr->state))
    {
      PWM_SVM_lStaticSVMSchemeModification(HandlePtr, Scheme);
    }
    else
    {
      /*Do Nothing*/
    }
  }
  else
  {
    status = PWM_SVM_INVALID_PARAM;
  }
  return (status);
}

void PWM_SVM_lDynamicSVMSchemeModification(PWM_SVM_t* const HandlePtr, PWM_SVM_SVMCONFIG_t Scheme)
{
  switch (Scheme)
  {
    case PWM_SVM_7SEG_SYMM:
      /*change to required SVM scheme is possible only if existing scheme is 5 segment symmetric*/
      if ((PWM_SVM_5SEG_SYMM == HandlePtr->svm_config))
      {
        /*if DC link configure compare match event and bind to NVIC node accordingly*/
        if (PWM_SVM_DCLINKCM == HandlePtr->confighandle_ptr->current_measurement)
        {
          XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
              (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1);
          XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
              (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1);
          XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
              (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2);
          XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
              (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2);
          XMC_CCU8_SLICE_SetInterruptNode(HandlePtr->phase_ptr[3]->slice_ptr,
              XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2,
              (XMC_CCU8_SLICE_SR_ID_t)(
                  (HandlePtr->confighandle_ptr->event_sr_selector[0] >> CCU8_CC8_SRS_CM1SR_Pos) & (0x03U)));
        }
        /*set the scheme*/
        HandlePtr->svm_config = Scheme;
        HandlePtr->svm_schemesel_ptr = (PWM_SVM_SVMSCHEME_PTR_t) PWM_SVM_CalCmpValueSym7;
      }
      break;
    case PWM_SVM_7SEG_ASYMM:
      /*change to required SVM scheme is possible only if existing scheme is 5 segment asymmetric*/
      if ((PWM_SVM_5SEG_ASYMM == HandlePtr->svm_config))
      {
        HandlePtr->svm_config = Scheme;
      }
      break;

    case PWM_SVM_5SEG_SYMM:
      /*change to required SVM scheme is possible only if existing scheme is 7 segment asymmetric*/
      if ((PWM_SVM_7SEG_SYMM == HandlePtr->svm_config))
      {
        /*disable two of compare match event as it is not required for 5 segment*/
        XMC_CCU8_SLICE_DisableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
            (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1);
        XMC_CCU8_SLICE_DisableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
            (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2);
        HandlePtr->svm_config = Scheme;
        HandlePtr->svm_schemesel_ptr = (PWM_SVM_SVMSCHEME_PTR_t) PWM_SVM_CalCmpValueSym5;
      }
      break;

    case PWM_SVM_5SEG_ASYMM:
      /*change to required SVM scheme is possible only if existing scheme is 7 segment asymmetric*/
      if ((PWM_SVM_7SEG_ASYMM == HandlePtr->svm_config))
      {
        HandlePtr->svm_config = Scheme;
        HandlePtr->svm_schemesel_ptr = (PWM_SVM_SVMSCHEME_PTR_t) PWM_SVM_CalCmpValueAsym5;
      }
      break;

    case PWM_SVM_PSEUDONULL_3ACTIVE:
      /*change to required SVM scheme is possible only if existing scheme is pseudo null 4 active vector*/
      if ((PWM_SVM_PSEUDONULL_4ACTIVE == HandlePtr->svm_config))
      {
        HandlePtr->max_amplitude = (uint16_t)(
            (uint32_t)PWM_SVM_MAX_AMPLITUDE - (uint32_t)((uint32_t) 3 * (uint32_t) HandlePtr->tmin_14));
        HandlePtr->svm_config = Scheme;
        HandlePtr->svm_schemesel_ptr = (PWM_SVM_SVMSCHEME_PTR_t) PWM_SVM_Calc3av5segmentCompVal;
      }
      break;

    case PWM_SVM_PSEUDONULL_4ACTIVE:
      /*change to required SVM scheme is possible only if existing scheme is pseudo null 3 active vector*/
      if ((PWM_SVM_PSEUDONULL_3ACTIVE == HandlePtr->svm_config))
      {
        HandlePtr->max_amplitude = (uint16_t)(
            (uint32_t)PWM_SVM_MAX_AMPLITUDE - (uint32_t)((uint32_t) 4 * (uint32_t) HandlePtr->tmin_14));
        HandlePtr->svm_config = Scheme;
        HandlePtr->svm_schemesel_ptr = (PWM_SVM_SVMSCHEME_PTR_t) PWM_SVM_Calc4av7segmentCompVal;
      }
      break;
  }
}

void PWM_SVM_lCAPeriodValueConfig(PWM_SVM_t* const HandlePtr)
{
  if ((PWM_SVM_5SEG_ASYMM < HandlePtr->svm_config))
  {
    HandlePtr->period = ((HandlePtr->period + 1U) >> 1U) - 1U;
    XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[0]->slice_ptr, (uint16_t) HandlePtr->period);
    XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[1]->slice_ptr, (uint16_t) HandlePtr->period);
    XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[2]->slice_ptr, (uint16_t) HandlePtr->period);
    if ((PWM_SVM_CMTYPE_t) PWM_SVM_NONE != HandlePtr->confighandle_ptr->current_measurement)
    {
      XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[3]->slice_ptr, (uint16_t) HandlePtr->period);
    }
    /*Enable the shadow transfer for all three slice*/
    XMC_CCU8_EnableShadowTransfer(HandlePtr->global_ptr, HandlePtr->confighandle_ptr->shadow_transfer_mask);
    HandlePtr->max_amplitude = (uint16_t)PWM_SVM_MAX_AMPLITUDE;
  }
}

void PWM_SVM_lEAPeriodValueConfig(PWM_SVM_t* const HandlePtr)
{
  if (HandlePtr->svm_config <= PWM_SVM_5SEG_ASYMM)
  {
    HandlePtr->period = (HandlePtr->period << 1U) + 1U;
    XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[0]->slice_ptr, (uint16_t) HandlePtr->period);
    XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[1]->slice_ptr, (uint16_t) HandlePtr->period);
    XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[2]->slice_ptr, (uint16_t) HandlePtr->period);
    if ((PWM_SVM_CMTYPE_t) PWM_SVM_NONE != HandlePtr->confighandle_ptr->current_measurement)
    {
      XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[3]->slice_ptr, (uint16_t) HandlePtr->period);
    }
    /*Enable the shadow transfer for all three slice*/
    XMC_CCU8_EnableShadowTransfer(HandlePtr->global_ptr, HandlePtr->confighandle_ptr->shadow_transfer_mask);
  }
}

void PWM_SVM_lStaticSVMSchemeModification(PWM_SVM_t* const HandlePtr, PWM_SVM_SVMCONFIG_t Scheme)
{

  /* Optimized slice consumption should be unchecked for change of SVM scheme */
  if ((uint8_t) false == HandlePtr->confighandle_ptr->enable_optimized_slice)
  {
    switch (Scheme)
    {
      case PWM_SVM_7SEG_SYMM:
        /*set counting mode to centre aligned*/
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[0]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[1]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[2]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);

        PWM_SVM_lCAPeriodValueConfig(HandlePtr);
        /*set the pwm type to symmetric*/
        XMC_CCU8_SLICE_EnableSymmetricCompareMode(HandlePtr->phase_ptr[0]->slice_ptr);
        XMC_CCU8_SLICE_EnableSymmetricCompareMode(HandlePtr->phase_ptr[1]->slice_ptr);
        XMC_CCU8_SLICE_EnableSymmetricCompareMode(HandlePtr->phase_ptr[2]->slice_ptr);

        /*enable compare match event and bind to respective node*/
        if (PWM_SVM_DCLINKCM == HandlePtr->confighandle_ptr->current_measurement)
        {
          XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
              (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1);
          XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[3]->slice_ptr,
              (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2);
          XMC_CCU8_SLICE_SetInterruptNode(HandlePtr->phase_ptr[3]->slice_ptr,
              (XMC_CCU8_SLICE_IRQ_ID_t) XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2,
              (XMC_CCU8_SLICE_SR_ID_t)(
                  (HandlePtr->confighandle_ptr->event_sr_selector[3] >> CCU8_CC8_SRS_CM1SR_Pos) & 0x03U));
        }
        HandlePtr->svm_schemesel_ptr = (PWM_SVM_SVMSCHEME_PTR_t) PWM_SVM_CalCmpValueSym7;
        break;

      case PWM_SVM_7SEG_ASYMM:
        /*set counting mode to centre aligned*/
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[0]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[1]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[2]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);

        PWM_SVM_lCAPeriodValueConfig(HandlePtr);
        /*set the pwm type to asymmetric*/
        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[0]->slice_ptr);
        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[1]->slice_ptr);
        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[2]->slice_ptr);
        HandlePtr->svm_schemesel_ptr = (PWM_SVM_SVMSCHEME_PTR_t) PWM_SVM_CalCmpValueAsym7;
        break;

      case PWM_SVM_5SEG_SYMM:
        /*set counting mode to centre aligned*/
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[0]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[1]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[2]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);

        PWM_SVM_lCAPeriodValueConfig(HandlePtr);
        /*set the pwm type to symmetric*/
        XMC_CCU8_SLICE_EnableSymmetricCompareMode(HandlePtr->phase_ptr[0]->slice_ptr);
        XMC_CCU8_SLICE_EnableSymmetricCompareMode(HandlePtr->phase_ptr[1]->slice_ptr);
        XMC_CCU8_SLICE_EnableSymmetricCompareMode(HandlePtr->phase_ptr[2]->slice_ptr);
        HandlePtr->svm_schemesel_ptr = (PWM_SVM_SVMSCHEME_PTR_t) PWM_SVM_CalCmpValueSym5;
        break;

      case PWM_SVM_5SEG_ASYMM:
        /*set counting mode to centre aligned*/
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[0]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[1]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[2]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA);

        PWM_SVM_lCAPeriodValueConfig(HandlePtr);

        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[0]->slice_ptr);
        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[1]->slice_ptr);
        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[2]->slice_ptr);
        HandlePtr->svm_schemesel_ptr = (PWM_SVM_SVMSCHEME_PTR_t) PWM_SVM_CalCmpValueAsym5;
        break;

      case PWM_SVM_PSEUDONULL_3ACTIVE:
        /*set counting mode to edge aligned*/
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[0]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_EA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[1]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_EA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[2]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_EA);

        PWM_SVM_lEAPeriodValueConfig(HandlePtr);
        HandlePtr->max_amplitude = (uint16_t)((uint32_t)PWM_SVM_MAX_AMPLITUDE - (uint32_t)((uint32_t) 3 * (uint32_t) HandlePtr->tmin_14));
        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[0]->slice_ptr);
        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[1]->slice_ptr);
        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[2]->slice_ptr);
        HandlePtr->svm_schemesel_ptr = (PWM_SVM_SVMSCHEME_PTR_t) PWM_SVM_Calc3av5segmentCompVal;
        break;

      case PWM_SVM_PSEUDONULL_4ACTIVE:
        /*set counting mode to edge aligned*/
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[0]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_EA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[1]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_EA);
        XMC_CCU8_SLICE_SetTimerCountingMode(HandlePtr->phase_ptr[2]->slice_ptr,
            (XMC_CCU8_SLICE_TIMER_COUNT_MODE_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_EA);

        PWM_SVM_lEAPeriodValueConfig(HandlePtr);
        HandlePtr->max_amplitude =
            (uint16_t)((uint32_t)PWM_SVM_MAX_AMPLITUDE - (uint32_t)((uint32_t) 4 * (uint32_t) HandlePtr->tmin_14));
        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[0]->slice_ptr);
        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[1]->slice_ptr);
        XMC_CCU8_SLICE_EnableAsymmetricCompareMode(HandlePtr->phase_ptr[2]->slice_ptr);
        HandlePtr->svm_schemesel_ptr = (PWM_SVM_SVMSCHEME_PTR_t) PWM_SVM_Calc4av7segmentCompVal;
        break;
    }
    /*set the scheme*/
    HandlePtr->svm_config = Scheme;
  } /* END OF if (false == HandlePtr->enable_optimized_slice) */
}
/*This API returns the SVM scheme*/
PWM_SVM_SVMCONFIG_t PWM_SVM_GetSVMScheme(PWM_SVM_t* const HandlePtr)
{
  XMC_ASSERT("PWM_SVM_GetSVMScheme:NULL Handle Pointer", (HandlePtr != (PWM_SVM_t *) NULL));
  return (HandlePtr->svm_config);
}


