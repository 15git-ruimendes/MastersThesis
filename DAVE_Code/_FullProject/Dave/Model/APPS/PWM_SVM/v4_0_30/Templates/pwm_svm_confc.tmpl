package Model.APPS.PWM_SVM.v4_0_30.Templates;

import Model.APPS.PWM_SVM.v4_0_30.PWM_SVM

out.print("""
/**
 * @cond
 ***********************************************************************************************************************
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version
 *
 * 2017-09-25:
 *     - Fix code generation for XMC14
 *
 * 2019-04-04:
 *     - Fix code generation for GPIO mode output for XMC14 
 *
 * 2020-03-06:
 *     - Fix code generation for output polarity
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES                                                                                                      
 **********************************************************************************************************************/
#include "xmc_ccu8.h"
#include "pwm_svm.h"
""");

String appInst                   = null;
String kernelNo                  = null;
String phaseu                    = null;
String phasev                    = null;
String phasew                    = null;
String currenttrig               = null;
String phaseuCmpCh               = null;
String phasevCmpCh               = null;
String phasewCmpCh               = null;
String currenttrig_cmp_status    = null;
String currenttrig_cmp_channel   = null;
String currenttrigHandle         = null;

String TrapPin                   = null;
String InverterPin               = null;

String TrapPort                  = null;
String InverterPort              = null;

String inv_padmode               = null;
String output_strength           = null;
String output_strength_inv       = null;
String hysterysis                = null;
String trap_hwsel                = null;

String phaseu_out0               = null;
String phaseu_out1               = null;
String phasev_out0               = null;
String phasev_out1               = null;
String phasew_out0               = null;
String phasew_out1               = null;


String phu_st                    = null;
String phv_st                    = null;
String phw_st                    = null;
String svm_scheme                = null;

Integer mapped_inp_start         = 0;
Integer mapped_inp_trap          = 0;
Integer evt0cm1sr                = 0;
Integer evt0cm2sr                = 0;
Integer evt1cm1sr                = 0;
Integer evt1cm2sr                = 0;
Integer evt2cm1sr                = 0;
Integer evt2cm2sr                = 0;
Integer evt3cm1sr                = 0;
Integer evt3cm2sr                = 0;
Integer timer_count_mode         = 0;

Integer dead_time_count_rising_edge = 0;
Integer dead_time_count_falling_edge = 0;

Boolean asymmetric;
String inverterpin;
Boolean currentmeas_slice;
Integer shadowtransfer;
Integer trapinterrupt;

List event_sr                    = [null,null,null,null];
List iocr_oe                     = [null,null,null,null,null,null];
List ins                         = [null,null,null];
List TimerCountArray             = ["XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA",
                  "XMC_CCU8_SLICE_TIMER_COUNT_MODE_EA"];
List SegTimeCalcArray            = ["PWM_SVM_USE_CORDIC" ,
                  "PWM_SVM_USE_LOOKUPTABLE"];
List SVMModeArray                = ["PWM_SVM_STANDARD",
                  "PWM_SVM_PSEUDO_NULL_VECTOR"];
List SVMConfigarray              = ["PWM_SVM_7SEG_SYMM",
                  "PWM_SVM_5SEG_SYMM",
                   "PWM_SVM_7SEG_ASYMM",
                  "PWM_SVM_5SEG_ASYMM",
                  "PWM_SVM_PSEUDONULL_3ACTIVE",
                  "PWM_SVM_PSEUDONULL_4ACTIVE"];
List CurrentMeasArray            = [
                  "PWM_SVM_NONE",
                  "PWM_SVM_DCLINKCM",
                  "PWM_SVM_PHASECM",
                  "PWM_SVM_PHASECM"
                   ];
List levelArray                   =
                   [
                  'XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH',
                  'XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW',
                  'XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH'
                  ];
List trapexitArray                =
                   [
                  "XMC_CCU8_SLICE_TRAP_EXIT_MODE_AUTOMATIC",
                  "XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW"
                   ];
List mapped_input                 =
                   [
                  "XMC_CCU8_SLICE_INPUT_A"      , /**< Input-A */
                  "XMC_CCU8_SLICE_INPUT_B"      , /**< Event-B */
                  "XMC_CCU8_SLICE_INPUT_C"      , /**< Event-C */
                  "XMC_CCU8_SLICE_INPUT_D"      , /**< Event-D */
                  "XMC_CCU8_SLICE_INPUT_E"      , /**< Event-E */
                  "XMC_CCU8_SLICE_INPUT_F"      , /**< Event-F */
                  "XMC_CCU8_SLICE_INPUT_G"      , /**< Event-G */
                  "XMC_CCU8_SLICE_INPUT_H"      , /**< Event-H */
                  "XMC_CCU8_SLICE_INPUT_I"      , /**< Event-I */
                  "XMC_CCU8_SLICE_INPUT_J"      , /**< Event-J */
                  "XMC_CCU8_SLICE_INPUT_K"      , /**< Event-K */
                  "XMC_CCU8_SLICE_INPUT_L"      , /**< Event-L */
                  "XMC_CCU8_SLICE_INPUT_M"      , /**< Event-M */
                  "XMC_CCU8_SLICE_INPUT_N"      , /**< Event-N */
                  "XMC_CCU8_SLICE_INPUT_O"      , /**< Event-O */
                  "XMC_CCU8_SLICE_INPUT_P"       /**< Event-P */
                   ];

List mapped_input_CCU8V3          =
			   [
			  "XMC_CCU8_SLICE_INPUT_AA",
			  "XMC_CCU8_SLICE_INPUT_AB",
			  "XMC_CCU8_SLICE_INPUT_AC",
			  "XMC_CCU8_SLICE_INPUT_AD",
			  "XMC_CCU8_SLICE_INPUT_AE",
			  "XMC_CCU8_SLICE_INPUT_AF",
			  "XMC_CCU8_SLICE_INPUT_AG",
			  "XMC_CCU8_SLICE_INPUT_AH",
			  "XMC_CCU8_SLICE_INPUT_AI",
			  "XMC_CCU8_SLICE_INPUT_AJ",
			  "XMC_CCU8_SLICE_INPUT_AK",
			  "XMC_CCU8_SLICE_INPUT_AL",
			  "XMC_CCU8_SLICE_INPUT_AM",
			  "XMC_CCU8_SLICE_INPUT_AN",
			  "XMC_CCU8_SLICE_INPUT_AO",
			  "XMC_CCU8_SLICE_INPUT_AP",
			  "XMC_CCU8_SLICE_INPUT_AQ",
			  "XMC_CCU8_SLICE_INPUT_AR",
			  "XMC_CCU8_SLICE_INPUT_AS",
			  "XMC_CCU8_SLICE_INPUT_AT",
			  "XMC_CCU8_SLICE_INPUT_AU",
			  "XMC_CCU8_SLICE_INPUT_AV",
			  "XMC_CCU8_SLICE_INPUT_AW",
			  "XMC_CCU8_SLICE_INPUT_AX",
			  "XMC_CCU8_SLICE_INPUT_AY",
			  "XMC_CCU8_SLICE_INPUT_AZ",
			  "XMC_CCU8_SLICE_INPUT_BA",
			  "XMC_CCU8_SLICE_INPUT_BB",
			  "XMC_CCU8_SLICE_INPUT_BC",
			  "XMC_CCU8_SLICE_INPUT_BD",
			  "XMC_CCU8_SLICE_INPUT_BE",
			  "XMC_CCU8_SLICE_INPUT_BF",
			  "XMC_CCU8_SLICE_INPUT_BG",
			  "XMC_CCU8_SLICE_INPUT_BH",
			  "XMC_CCU8_SLICE_INPUT_BI",
			  "XMC_CCU8_SLICE_INPUT_BJ",
			  "XMC_CCU8_SLICE_INPUT_BK",
			  "XMC_CCU8_SLICE_INPUT_BL",
			  "XMC_CCU8_SLICE_INPUT_BM",
			  "XMC_CCU8_SLICE_INPUT_BN",
			  "XMC_CCU8_SLICE_INPUT_BO",
			  "XMC_CCU8_SLICE_INPUT_BP",
			  "XMC_CCU8_SLICE_INPUT_BQ",
			  "XMC_CCU8_SLICE_INPUT_BR",
			  "XMC_CCU8_SLICE_INPUT_BS",
			  "XMC_CCU8_SLICE_INPUT_BT",
			  "XMC_CCU8_SLICE_INPUT_BU",
			  "XMC_CCU8_SLICE_INPUT_BV",
			   ];

List gpio_mode                    =
                                  [
                    "XMC_GPIO_MODE_INPUT_TRISTATE" ,              //!< XMC_GPIO_MODE_INPUT_TRISTATE
                    "XMC_GPIO_MODE_INPUT_PULL_DOWN" ,             //!< XMC_GPIO_MODE_INPUT_PULL_DOWN
                    "XMC_GPIO_MODE_INPUT_PULL_UP" ,               //!< XMC_GPIO_MODE_INPUT_PULL_UP
                    "XMC_GPIO_MODE_INPUT_SAMPLING" ,              //!< XMC_GPIO_MODE_INPUT_SAMPLING
                    "XMC_GPIO_MODE_INPUT_INVERTED_TRISTATE" ,     //!< XMC_GPIO_MODE_INPUT_INVERTED_TRISTATE
                    "XMC_GPIO_MODE_INPUT_INVERTED_PULL_DOWN",     //!< XMC_GPIO_MODE_INPUT_INVERTED_PULL_DOWN
                    "XMC_GPIO_MODE_INPUT_INVERTED_PULL_UP",       //!< XMC_GPIO_MODE_INPUT_INVERTED_PULL_UP
                    "XMC_GPIO_MODE_INPUT_INVERTED_SAMPLING",      //!< XMC_GPIO_MODE_INPUT_INVERTED_SAMPLING
                    "XMC_GPIO_MODE_OUTPUT_PUSH_PULL",             //!< XMC_GPIO_MODE_OUTPUT_PUSH_PULL
                    "XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT1",        //!< XMC_GPIO_MODE_OUTPUT_PUSH_PULL
                    "XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT2",        //!< XMC_GPIO_MODE_OUTPUT_PUSH_PULL
                    "XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT3",        //!< XMC_GPIO_MODE_OUTPUT_PUSH_PULL
                    "XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT4",        //!< XMC_GPIO_MODE_OUTPUT_PUSH_PULL
                    "XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT5",        //!< XMC_GPIO_MODE_OUTPUT_PUSH_PULL
                    "XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT6",        //!< XMC_GPIO_MODE_OUTPUT_PUSH_PULL
                    "XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT7",        //!< XMC_GPIO_MODE_OUTPUT_PUSH_PULL
                    "XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT8",        //!< XMC_GPIO_MODE_OUTPUT_PUSH_PULL
                    "XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT9",        //!< XMC_GPIO_MODE_OUTPUT_PUSH_PULL
                    "XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN",            //!< XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN
                    "XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN_ALT1",       //!< XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN
                    "XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN_ALT2",       //!< XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN
                    "XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN_ALT3",       //!< XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN
                    "XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN_ALT4",       //!< XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN
                    "XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN_ALT5",       //!< XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN
                    "XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN_ALT6",       //!< XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN
                    "XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN_ALT7",       //!< XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN
                    "XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN_ALT8",       //!< XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN
                    "XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN_ALT9",       //!< XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN
                                ];

List passivelvl_array =   [
    'XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_HIGH',
    'XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW',
];

String family = daveEnv.project.selectedDevice.deviceId.family
String series = daveEnv.project.selectedDevice.deviceId.series
							
/**********************************************************************************************************************/
for (Object appIns : appInstancesList ) {
  appInst = appIns.getInstanceLabel()
  
  Integer reg_read_phu_h  = 0;
  Integer reg_read_phu_l  = 0;
  Integer reg_read_phv_h  = 0;
  Integer reg_read_phv_l  = 0;
  Integer reg_read_phw_h  = 0;
  Integer reg_read_phw_l  = 0;
  Float amplitude_scale = 0;
  Integer pwm_padmode              = 0;
  
  
  if(appIns.hwres_ccu8_config_a.getSolverUri() != null)
  {

  if(appIns.hwres_port_pad_trap.getSolverUri() != null)   /*check if uri is valid,since this resource is consumed conditionally*/
  {
    TrapPort = appIns.hwres_port_pad_trap.getSolverUri()[4];
    TrapPin  = appIns.hwres_port_pad_trap.getSolverUri()[6];
  }

  if(appIns.hwres_port_pad_inverterenable.getSolverUri() != null)/*check if uri is valid,since this resource is consumed conditionally*/
  {
    InverterPort = appIns.hwres_port_pad_inverterenable.getSolverUri()[4];
    InverterPin  = appIns.hwres_port_pad_inverterenable.getSolverUri()[6];
  }
  
  kernelNo = appIns.hwres_ccu8_config_a.getSolverUri()[4];
  phaseu   = appIns.hwres_ccu8_config_a.getSolverUri()[6];
  
  /* start: dummy read*/
  appIns.hwres_ccu8_config_a.getRegValue("srs","srs_cm1sr")
  appIns.hwres_ccu8_config_a.getRegValue("srs","srs_cm2sr")
  appIns.hwres_ccu8_config_b.getRegValue("srs","srs_cm1sr")
  appIns.hwres_ccu8_config_b.getRegValue("srs","srs_cm2sr")
  appIns.hwres_ccu8_config_c.getRegValue("srs","srs_cm1sr")
  appIns.hwres_ccu8_config_c.getRegValue("srs","srs_cm2sr")
  appIns.hwres_ccu8_config_d.getRegValue("srs","srs_cm1sr")
  appIns.hwres_ccu8_config_d.getRegValue("srs","srs_cm2sr")
  /* end: dummy read*/
  
/**************************************Phase U Compare match SR***********************************/
  if(appIns.sv_svm_phu_high_out.getSolverValue() == "out0")
  {
    evt0cm1sr = ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_cm1sr")) << 2)
  }
  else if(appIns.sv_svm_phu_high_out.getSolverValue() == "out2")
  {
    evt0cm2sr = ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_cm2sr")) << 4)
  }
  else
  {
    evt0cm1sr = 0
    evt0cm2sr = 0
  }


  if((appIns.gint_index.value < 2) && (appIns.gcheck_optimization.value == true))
  {
    /*****************************************Phase V Compare match SR*******************************/
    /* Optimization is enabled and symmetric */
   if(appIns.sv_svm_phv_high_out.getSolverValue() == "out0")
   {
     evt1cm1sr = ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_cm1sr")) << 2)
   }
   else if(appIns.sv_svm_phv_high_out.getSolverValue() == "out2")
   {
     evt1cm2sr = ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_cm2sr")) << 4)
   }
   else
   {
     evt1cm1sr = 0
     evt1cm2sr = 0
   }
   /****************************************Phase W Compare match SR********************************/
   /* Optimization is enabled and symmetric */
   if(appIns.sv_svm_phw_high_out.getSolverValue() == "out0")
   {
     evt2cm1sr = ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_cm1sr")) << 2)
   }
   else if(appIns.sv_svm_phw_high_out.getSolverValue() == "out2")
   {
     evt2cm2sr = ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_cm2sr")) << 4)
   }
   else
   {
     evt2cm1sr = 0
     evt2cm2sr = 0
   } 
   
   /* symmetric mode and if optimization is enabled,
    * Phase U and Phase V share the slice
    * Phase W and current trigger share the slice (except for DC link current measurement*/
   phasev = appIns.hwres_ccu8_config_a.getSolverUri()[6];
   phasew = appIns.hwres_ccu8_config_b.getSolverUri()[6];
   
   /* mapping of interrupts to service request node for phase V
    * phase U and phase V share the same slice */
   event_sr[1] =
   ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_e2sr")) << 12) |
   ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_e1sr")) << 10) |
   ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_e0sr")) << 8) |
   ((int)evt1cm1sr) |
   ((int)evt1cm2sr) |
   ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_posr")))
   
   /* mapping of interrupts to service request node for phase W */
   event_sr[2] =
   ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_e2sr")) << 12) |
   ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_e1sr")) << 10) |
   ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_e0sr")) << 8) |
   ((int)evt2cm1sr) |
   ((int)evt2cm2sr) |
   ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_posr")))
  }
  else
  {
    /*****************************************Phase V Compare match SR*******************************/
  if(appIns.hwres_ccu8_config_b.getSolverUri() != null)
  {
     if(appIns.sv_svm_phv_high_out.getSolverValue() == "out0")
     {
      evt1cm2sr = ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_cm1sr")) << 2)
     }
     else if(appIns.sv_svm_phv_high_out.getSolverValue() == "out2")
     {
      evt1cm2sr = ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_cm2sr")) << 4)
     }
     else
     {
       evt1cm1sr = 0
     evt1cm2sr = 0
     }
  }
  /****************************************Phase W Compare match SR********************************/
  if(appIns.hwres_ccu8_config_c.getSolverUri() != null)
  {
     if(appIns.sv_svm_phw_high_out.getSolverValue() == "out0")
     {
      evt2cm2sr = ((int)(appIns.hwres_ccu8_config_c.getRegValue("srs","srs_cm1sr")) << 2)
     }
     else if(appIns.sv_svm_phw_high_out.getSolverValue() == "out2")
     {
      evt2cm2sr = ((int)(appIns.hwres_ccu8_config_c.getRegValue("srs","srs_cm2sr")) << 4)
     }
     else
     {
       evt2cm1sr = 0
     evt2cm2sr = 0
     }
  }
  
  /* For asymmetric mode OR symmetric mode with optimization disabled
   * Phase U and Phase V share the slice
   * Phase W and current trigger share the slice (except for DC link current measurement*/
  phasev = appIns.hwres_ccu8_config_b.getSolverUri()[6];
  phasew = appIns.hwres_ccu8_config_c.getSolverUri()[6];
  /* mapping of interrupts to service request node for phase V */
  event_sr[1] =
  ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_e2sr")) << 12) |
  ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_e1sr")) << 10) |
  ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_e0sr")) << 8) |
  ((int)evt1cm1sr) |
  ((int)evt1cm2sr) |
  ((int)(appIns.hwres_ccu8_config_b.getRegValue("srs","srs_posr")))
  /* mapping of interrupts to service request node for phase W */
  event_sr[2] =
  ((int)(appIns.hwres_ccu8_config_c.getRegValue("srs","srs_e2sr")) << 12) |
  ((int)(appIns.hwres_ccu8_config_c.getRegValue("srs","srs_e1sr")) << 10) |
  ((int)(appIns.hwres_ccu8_config_c.getRegValue("srs","srs_e0sr")) << 8) |
  ((int)evt2cm1sr) |
  ((int)evt2cm2sr) |
  ((int)(appIns.hwres_ccu8_config_c.getRegValue("srs","srs_posr")))
  }
/***********************************Current Slice Compare match SR**************************************/  
  /* mapping of interrupts to service request node for phase U */
  event_sr[0] = ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_e2sr")) << 12) |
                ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_e1sr")) << 10) |
              ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_e0sr")) << 8) |
        ((int)evt0cm1sr) | ((int)evt0cm2sr) |
              ((int)(appIns.hwres_ccu8_config_a.getRegValue("srs","srs_posr")))
    
  if(appIns.gcombo_externaltrigger.value == "None")
  {
    currenttrig = 0;
    currentmeas_slice = false;
    currenttrigHandle = "NULL";
    event_sr[3] = 0;
  }
  else
  {
    evt3cm1sr = ((int)(appIns.hwres_ccu8_config_d.getRegValue("srs","srs_cm1sr")) << 2)
    evt3cm2sr = ((int)(appIns.hwres_ccu8_config_d.getRegValue("srs","srs_cm2sr")) << 4)
      
    currenttrig = appIns.hwres_ccu8_config_d.getSolverUri()[6];
    currentmeas_slice = true;
    currenttrigHandle = "(CCU8_CC8_TypeDef*)CCU8" + kernelNo + "_CC8"+ currenttrig;
    /* mapping of interrupts to service request node for current trigger slice */
    event_sr[3] =
    ((int)(appIns.hwres_ccu8_config_d.getRegValue("srs","srs_e2sr")) << 12) |
    ((int)(appIns.hwres_ccu8_config_d.getRegValue("srs","srs_e1sr")) << 10) |
    ((int)(appIns.hwres_ccu8_config_d.getRegValue("srs","srs_e0sr")) << 8) |
    ((int)evt3cm1sr) |
    ((int)evt3cm2sr) |
    ((int)(appIns.hwres_ccu8_config_d.getRegValue("srs","srs_posr")))
  }
  
  /*phase u channel, output manipulation*/
  if(appIns.sv_svm_phu_high_out.getSolverValue() == "out0")
  {
    phaseu_out0 = "XMC_CCU8_SLICE_OUTPUT_0"
    phaseu_out1 = "XMC_CCU8_SLICE_OUTPUT_1"
    phu_st = "XMC_CCU8_SLICE_STATUS_CHANNEL_1";
    phaseuCmpCh = "1"
  }
  else
  {
    phaseuCmpCh = "2"
    phaseu_out0 = "XMC_CCU8_SLICE_OUTPUT_2"
    phaseu_out1 = "XMC_CCU8_SLICE_OUTPUT_3"
    phu_st = "XMC_CCU8_SLICE_STATUS_CHANNEL_2";
  }
  /*phase v channel, output manipulation*/
  if(appIns.sv_svm_phv_high_out.getSolverValue() == "out0")
  {
    phasevCmpCh = "1"
    phasev_out0 = "XMC_CCU8_SLICE_OUTPUT_0"
    phasev_out1 = "XMC_CCU8_SLICE_OUTPUT_1"
    phv_st = "XMC_CCU8_SLICE_STATUS_CHANNEL_1";
  }
  else
  {
    phasevCmpCh = "2"
    phasev_out0 = "XMC_CCU8_SLICE_OUTPUT_2"
    phasev_out1 = "XMC_CCU8_SLICE_OUTPUT_3"
    phv_st = "XMC_CCU8_SLICE_STATUS_CHANNEL_2";
  }
  /*phase w channel, output manipulation*/
  if(appIns.sv_svm_phw_high_out.getSolverValue() == "out0")
  {
    phasewCmpCh = "1"
    phasew_out0 = "XMC_CCU8_SLICE_OUTPUT_0"
    phasew_out1 = "XMC_CCU8_SLICE_OUTPUT_1"
    phw_st = "XMC_CCU8_SLICE_STATUS_CHANNEL_1";
  }
  else
  {
    phasewCmpCh = "2"
    phasew_out0 = "XMC_CCU8_SLICE_OUTPUT_2"
    phasew_out1 = "XMC_CCU8_SLICE_OUTPUT_3"
    phw_st = "XMC_CCU8_SLICE_STATUS_CHANNEL_2";
  }
  
  if(appIns.sv_svm_current_trig_ch1.getSolverValue() == "out0")
  {
    currenttrig_cmp_status = "(XMC_CCU8_SLICE_STATUS_t)XMC_CCU8_SLICE_STATUS_CHANNEL_1"
    currenttrig_cmp_channel = "XMC_CCU8_SLICE_COMPARE_CHANNEL_1"
  }
  else
  {
    currenttrig_cmp_status = "(XMC_CCU8_SLICE_STATUS_t)XMC_CCU8_SLICE_STATUS_CHANNEL_2"
    currenttrig_cmp_channel = "XMC_CCU8_SLICE_COMPARE_CHANNEL_2"
  }

  /*dummy mux read*/
  
  appIns.hwres_port_pad_phuhigh.getRegValue("PDISC","pdisc_pdis")
  appIns.hwres_port_pad_phulow.getRegValue("PDISC","pdisc_pdis")
  appIns.hwres_port_pad_phvhigh.getRegValue("PDISC","pdisc_pdis")
  appIns.hwres_port_pad_phvlow.getRegValue("PDISC","pdisc_pdis")
  appIns.hwres_port_pad_phwhigh.getRegValue("PDISC","pdisc_pdis")
  appIns.hwres_port_pad_phwlow.getRegValue("PDISC","pdisc_pdis")
  appIns.hwres_port_pad_inverterenable.getRegValue("PDISC","pdisc_pdis")
  
  iocr_oe[0]    = appIns.hwres_port_pad_phuhigh.getRegValue("IOCR","iocr_oe")
  iocr_oe[1]    = appIns.hwres_port_pad_phulow.getRegValue("IOCR","iocr_oe")
  iocr_oe[2]    = appIns.hwres_port_pad_phvhigh.getRegValue("IOCR","iocr_oe")
  iocr_oe[3]    = appIns.hwres_port_pad_phvlow.getRegValue("IOCR","iocr_oe")
  iocr_oe[4]    = appIns.hwres_port_pad_phwhigh.getRegValue("IOCR","iocr_oe")
  iocr_oe[5]    = appIns.hwres_port_pad_phwlow.getRegValue("IOCR","iocr_oe")
  
  ins[0]        = appIns.hwres_ccu8_config_b.getRegValue("ins","ins_ev0is")
  ins[1]        = appIns.hwres_ccu8_config_c.getRegValue("ins","ins_ev0is")
  ins[2]        = appIns.hwres_ccu8_config_d.getRegValue("ins","ins_ev0is")
  
  appIns.hwres_port_pad_phuhigh.getRegValue("","hwsel_hw")
  appIns.hwres_port_pad_phulow.getRegValue("","hwsel_hw")
  appIns.hwres_port_pad_phvhigh.getRegValue("","hwsel_hw")
  appIns.hwres_port_pad_phvlow.getRegValue("","hwsel_hw")
  appIns.hwres_port_pad_phwhigh.getRegValue("","hwsel_hw")
  appIns.hwres_port_pad_phwlow.getRegValue("","hwsel_hw")
  appIns.hwres_port_pad_inverterenable.getRegValue("","hwsel_hw")
  appIns.hwres_port_pad_inverterenable.getRegValue("IOCR","iocr_pcr")
  appIns.hwres_port_pad_inverterenable.getRegValue("IOCR","iocr_oe")
  
  appIns.hwres_ccu8_config_a.getRegValue("ins","ins_ev1is")
  appIns.hwres_ccu8_config_b.getRegValue("ins","ins_ev1is")
  appIns.hwres_ccu8_config_c.getRegValue("ins","ins_ev1is")
  appIns.hwres_ccu8_config_d.getRegValue("ins","ins_ev1is")
  
  appIns.hwres_ccu8_config_b.getRegValue("ins","ins_ev2is")
  appIns.hwres_ccu8_config_c.getRegValue("ins","ins_ev2is")
  appIns.hwres_ccu8_config_d.getRegValue("ins","ins_ev2is")

  appIns.hwres_port_pad_trap.getRegValue("IOCR","iocr_pcr")
  
/**********************************************************************************************************************/
  dead_time_count_rising_edge  = appIns.gint_deadtimecount_rising_edge.value;
  dead_time_count_falling_edge = appIns.gint_deadtimecount_falling_edge.value;
/**********************************************************************************************************************/
  shadowtransfer = (0x01 << (4* Integer.parseInt(phaseu))) |
    (0x01 << (4* Integer.parseInt(phasev))) |
    (0x01 << (4* Integer.parseInt(phasew)));
  if(currentmeas_slice == true)
  {
    shadowtransfer = shadowtransfer | (0x01 << (4* Integer.parseInt(currenttrig)))
  }
/**********************************************************************************************************************/
  if(appIns.gint_index.value < 4)
  {
    timer_count_mode = 0;  /*to decide centre aligned/edge aligned and also used to decide standard SVM/pseudo SVM*/
  }
  else
  {
    timer_count_mode = 1; /*to decide centre aligned/edge aligned*/
  }
/**********************************************************************************************************************/
  if(appIns.gint_index.value > 1)
  {
    asymmetric = true;
  }
  else
  {
    asymmetric = false;
  }
  
/**********************************************************************************************************************/
    /*GPIO configuration for ouptput mode of pwm output pins*/
  if (appIns.gcombo_outchar.value == "Push Pull")
  {
    pwm_padmode = 8 //"XMC_GPIO_MODE_OUTPUT_PUSH_PULL"
  }
  else
  {
    pwm_padmode = 18 //"XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN"
  }
/***********************************************************************************************************************/
  /*GPIO configuration for ouptput mode of inverter enable pins*/
  if (appIns.gcombo_inverteroutchar.value == "Push Pull") {
    inv_padmode = "XMC_GPIO_MODE_OUTPUT_PUSH_PULL"
  }
  else {
    inv_padmode = "XMC_GPIO_MODE_OUTPUT_OPEN_DRAIN"
  }

  /*GPIO configuration for pwm pin output strength */
  if (appIns.gcombo_paddriver.value == "Weak Driver") {
    output_strength = "XMC_GPIO_OUTPUT_STRENGTH_WEAK"
  }
  else if (appIns.gcombo_paddriver.value == "Medium Driver") {
    output_strength = "XMC_GPIO_OUTPUT_STRENGTH_MEDIUM"
  }
  else if (appIns.gcombo_paddriver.value == "Strong Driver Slow Edge") {
    output_strength = "XMC_GPIO_OUTPUT_STRENGTH_STRONG_SLOW_EDGE"
  }
  else if (appIns.gcombo_paddriver.value == "Strong Driver Soft Edge") {
    output_strength = "XMC_GPIO_OUTPUT_STRENGTH_STRONG_SOFT_EDGE"
  }
  else if (appIns.gcombo_paddriver.value == "Strong Driver Medium Edge") {
    output_strength = "XMC_GPIO_OUTPUT_STRENGTH_STRONG_MEDIUM_EDGE"
  }
  else {
    output_strength = "XMC_GPIO_OUTPUT_STRENGTH_STRONG_SHARP_EDGE"
  }
/***********************************************************************************************/
  /*GPIO configuration for inerter pin output strength */
  if (appIns.gcombo_inverterpaddriver.value == "Weak Driver") {
    output_strength_inv = "XMC_GPIO_OUTPUT_STRENGTH_WEAK"
  }
  else if (appIns.gcombo_inverterpaddriver.value == "Medium Driver") {
    output_strength_inv = "XMC_GPIO_OUTPUT_STRENGTH_MEDIUM"
  }
  else if (appIns.gcombo_inverterpaddriver.value == "Strong Driver Slow Edge") {
    output_strength_inv = "XMC_GPIO_OUTPUT_STRENGTH_STRONG_SLOW_EDGE"
  }
  else if (appIns.gcombo_inverterpaddriver.value == "Strong Driver Soft Edge") {
    output_strength_inv = "XMC_GPIO_OUTPUT_STRENGTH_STRONG_SOFT_EDGE"
  }
  else if (appIns.gcombo_inverterpaddriver.value == "Strong Driver Medium Edge") {
    output_strength_inv = "XMC_GPIO_OUTPUT_STRENGTH_STRONG_MEDIUM_EDGE"
  }
  else {
    output_strength_inv = "XMC_GPIO_OUTPUT_STRENGTH_STRONG_SHARP_EDGE"
  }
  
  hysterysis = "XMC_GPIO_OUTPUT_STRENGTH_STRONG_MEDIUM_EDGE"

/************************************************************************************************/
  
Float overmodscale  = 16777216 /(appIns.gint_maxamp.value *0.154700538)

Float maxovermodamp = appIns.gint_maxamp.value *1.154700538

amplitude_scale = ((appIns.gint_periodreg.value/16383) * 1024);

Float tmin_14 = 0
if(appIns.gint_tmincount.value != 0)
{
  tmin_14 = 16383/appIns.gint_tmincount.value
}

Integer ov_mod;
Integer max_amplitude_t;
if(appIns.gcheck_overmodulation.value == true)
{
  ov_mod = 1;
  max_amplitude_t = 16384 * 1.15;
}
else
{
  ov_mod = 0;
  max_amplitude_t = 16384;
}
svm_scheme = ["PWM_SVM_CalCmpValueSym7","PWM_SVM_CalCmpValueSym5",
              "PWM_SVM_CalCmpValueAsym7","PWM_SVM_CalCmpValueAsym5",
              "PWM_SVM_Calc3av5segmentCompVal",
              "PWM_SVM_Calc4av7segmentCompVal"][appIns.gcombo_svm_schemeselect.options.indexOf(appIns.gcombo_svm_schemeselect.value)]
			  
String seg_time_calc = ["PWM_SVM_TimecalcUsingCORDIC","PWM_SVM_TimecalcUsingLUT"][appIns.gcombo_segmenttimecalculation.options.indexOf(appIns.gcombo_segmenttimecalculation.value)]
/************************************************************************************************/
mapped_inp_start = (int)appIns.hwres_ccu8_config_a.getRegValue("INS","ins_ev0is")
mapped_inp_trap =  (int)appIns.hwres_ccu8_config_a.getRegValue("INS","ins_ev2is")

out.print("""
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/*pwm phase u port & pin init structure*/
const PWM_SVM_GPIO_t ${appInst}_PhUHighPin =
{
  .port = (XMC_GPIO_PORT_t *)PORT${appIns.hwres_port_pad_phuhigh.getSolverUri()[4]}_BASE, 
  .pin  = ${appIns.hwres_port_pad_phuhigh.getSolverUri()[6]}U
};
/*pwm phase u port & pin init structure*/
const PWM_SVM_GPIO_t ${appInst}_PhULowPin =
{
  .port = (XMC_GPIO_PORT_t *)PORT${appIns.hwres_port_pad_phulow.getSolverUri()[4]}_BASE, 
  .pin = ${appIns.hwres_port_pad_phulow.getSolverUri()[6]}U
};
/*pwm phase v port & pin init structure*/
const PWM_SVM_GPIO_t ${appInst}_PhVHighPin =
{
  .port = (XMC_GPIO_PORT_t *)PORT${appIns.hwres_port_pad_phvhigh.getSolverUri()[4]}_BASE, 
  .pin = ${appIns.hwres_port_pad_phvhigh.getSolverUri()[6]}U
}; 
/*pwm phase v port & pin init structure*/
const PWM_SVM_GPIO_t ${appInst}_PhVLowPin =
{
  .port = (XMC_GPIO_PORT_t *)PORT${appIns.hwres_port_pad_phvlow.getSolverUri()[4]}_BASE, 
  .pin = ${appIns.hwres_port_pad_phvlow.getSolverUri()[6]}U
};
/*pwm phase w port & pin init structure*/
const PWM_SVM_GPIO_t ${appInst}_PhWHighPin =
{
  .port = (XMC_GPIO_PORT_t *)PORT${appIns.hwres_port_pad_phwhigh.getSolverUri()[4]}_BASE, 
  .pin = ${appIns.hwres_port_pad_phwhigh.getSolverUri()[6]}U
}; 
/*pwm phase w port & pin init structure*/
const PWM_SVM_GPIO_t ${appInst}_PhWLowPin =
{
  .port = (XMC_GPIO_PORT_t *)PORT${appIns.hwres_port_pad_phwlow.getSolverUri()[4]}_BASE, 
  .pin = ${appIns.hwres_port_pad_phwlow.getSolverUri()[6]}U
};
""");
/* verify if any register bitfields are not returning null then read */
if(appIns.hwres_port_pad_phuhigh.getRegValue("IOCR","iocr_pcr") != null)
{
reg_read_phu_h = (int)(appIns.hwres_port_pad_phuhigh.getRegValue("IOCR","iocr_pcr"))
}

if(appIns.hwres_port_pad_phulow.getRegValue("IOCR","iocr_pcr") != null)
{
reg_read_phu_l = (int)(appIns.hwres_port_pad_phulow.getRegValue("IOCR","iocr_pcr"))
}

if(appIns.hwres_port_pad_phvhigh.getRegValue("IOCR","iocr_pcr") != null)
{
reg_read_phv_h = (int)(appIns.hwres_port_pad_phvhigh.getRegValue("IOCR","iocr_pcr"))
}

if(appIns.hwres_port_pad_phvlow.getRegValue("IOCR","iocr_pcr") != null)
{
reg_read_phv_l = (int)(appIns.hwres_port_pad_phvlow.getRegValue("IOCR","iocr_pcr"))
}

if(appIns.hwres_port_pad_phwhigh.getRegValue("IOCR","iocr_pcr") != null)
{
reg_read_phw_h = (int)(appIns.hwres_port_pad_phwhigh.getRegValue("IOCR","iocr_pcr"))
}

if(appIns.hwres_port_pad_phwlow.getRegValue("IOCR","iocr_pcr") != null)
{
reg_read_phw_l = (int)(appIns.hwres_port_pad_phwlow.getRegValue("IOCR","iocr_pcr"))
}

if (daveEnv.project.selectedDevice.deviceId.family == "XMC4"){
out.print("""
/* GPIO config Init handle for Phase U High Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhUHiOutPinConf = 
{
 .mode            = ${gpio_mode[pwm_padmode + reg_read_phu_h]},
 .output_level    = XMC_GPIO_OUTPUT_LEVEL_LOW,
 .output_strength = ${output_strength}
};
/* GPIO config Init handle for Phase U Low Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhULoOutPinConf = 
{
 .mode            = ${gpio_mode[pwm_padmode + reg_read_phu_l]},
 .output_level    = XMC_GPIO_OUTPUT_LEVEL_LOW,
 .output_strength = ${output_strength}
};
/* GPIO config Init handle for Phase V High Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhVHiOutPinConf = 
{
 .mode            = ${gpio_mode[pwm_padmode + reg_read_phv_h]},
 .output_level    = XMC_GPIO_OUTPUT_LEVEL_LOW,
 .output_strength = ${output_strength}
};
/* GPIO config Init handle for Phase V Low Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhVLoOutPinConf = 
{
 .mode            = ${gpio_mode[pwm_padmode + reg_read_phv_l]},
 .output_level    = XMC_GPIO_OUTPUT_LEVEL_LOW,
 .output_strength = ${output_strength}
};
/* GPIO config Init handle for Phase W High Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhWHiOutPinConf = 
{
 .mode            = ${gpio_mode[pwm_padmode + reg_read_phw_h]},
 .output_level    = XMC_GPIO_OUTPUT_LEVEL_LOW,
 .output_strength = ${output_strength}
};
/* GPIO config Init handle for Phase W Low Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhWLoOutPinConf = 
{
 .mode            = ${gpio_mode[pwm_padmode + reg_read_phw_l]},
 .output_level    = XMC_GPIO_OUTPUT_LEVEL_LOW,
 .output_strength = ${output_strength}
};
""");
}

if (daveEnv.project.selectedDevice.deviceId.family == "XMC1"){
out.print("""
/* GPIO config Init handle for Phase U High Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhUHiOutPinConf = 
{
 .mode             = ${gpio_mode[pwm_padmode + reg_read_phu_h]},
 .input_hysteresis = XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
 .output_level     = XMC_GPIO_OUTPUT_LEVEL_LOW
};
/* GPIO config Init handle for Phase U Low Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhULoOutPinConf = 
{
 .mode             = ${gpio_mode[pwm_padmode + reg_read_phu_l]},
 .input_hysteresis = XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
 .output_level     = XMC_GPIO_OUTPUT_LEVEL_LOW
};
/* GPIO config Init handle for Phase V High Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhVHiOutPinConf = 
{
 .mode             = ${gpio_mode[pwm_padmode + reg_read_phv_h]},
 .input_hysteresis = XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
 .output_level     = XMC_GPIO_OUTPUT_LEVEL_LOW
};
/* GPIO config Init handle for Phase V Low Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhVLoOutPinConf = 
{
 .mode             = ${gpio_mode[pwm_padmode + reg_read_phv_l]},
 .input_hysteresis = XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
 .output_level     = XMC_GPIO_OUTPUT_LEVEL_LOW
};
/* GPIO config Init handle for Phase W High Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhWHiOutPinConf = 
{
 .mode             = ${gpio_mode[pwm_padmode + reg_read_phw_h]},
 .input_hysteresis = XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
 .output_level     = XMC_GPIO_OUTPUT_LEVEL_LOW
};
/* GPIO config Init handle for Phase W Low Pin */
const XMC_GPIO_CONFIG_t ${appInst}_PhWLoOutPinConf = 
{
 .mode             = ${gpio_mode[pwm_padmode + reg_read_phw_l]},
 .input_hysteresis = XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
 .output_level     = XMC_GPIO_OUTPUT_LEVEL_LOW
};
""");
}
if(appIns.gcombo_invlevelsel.value  != "Disabled")
{
  if(appIns.gcombo_invlevelsel.value == "Active High")
  {
    inverterpin = "PWM_SVM_IPIN_HIGH";
  }
  else
  {
    inverterpin = "PWM_SVM_IPIN_LOW";
  }
print("""
  /*inverter port & pin init structure*/
  const PWM_SVM_GPIO_t ${appInst}_InverterPin =
  {
    .port = (XMC_GPIO_PORT_t *)PORT${InverterPort}_BASE, 
    .pin = ${InverterPin}U
  };
""")
  if (daveEnv.project.selectedDevice.deviceId.family == "XMC4"){
out.print("""
  /* GPIO config Init handle for inverter Pin */
  const XMC_GPIO_CONFIG_t ${appInst}_InvPinConf = 
  {
    .mode            = ${inv_padmode},
    .output_level    = XMC_GPIO_OUTPUT_LEVEL_LOW,
    .output_strength = ${output_strength_inv}
  };
""");
  } else {
out.print("""
  /* GPIO config Init handle for inverter Pin */
  const XMC_GPIO_CONFIG_t ${appInst}_InvPinConf = 
  {
    .mode            = ${inv_padmode},
    .input_hysteresis= XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
    .output_level    = XMC_GPIO_OUTPUT_LEVEL_LOW
  };
""");
  }
} else {
  inverterpin = "PWM_SVM_IPIN_NOTREQUIRED";
}
if(appIns.gcombo_traplevelsel.value != "Disabled")
{
print("""
  /*trap port & pin init structure*/
  const PWM_SVM_GPIO_t ${appInst}_TrapPin =
  {
    .port = (XMC_GPIO_PORT_t *)PORT${TrapPort}_BASE, 
    .pin = ${TrapPin}U
  };
""");

  if (daveEnv.project.selectedDevice.deviceId.family == "XMC4"){
out.print("""
  /* GPIO config Init handle for trap Pin */
  const XMC_GPIO_CONFIG_t ${appInst}_TrapPinConf = 
  {
    .mode            = ${gpio_mode[(int)((appIns.hwres_port_pad_trap.getRegValue("IOCR","iocr_oe")) + (appIns.gcombo_inchar.options.indexOf(appIns.gcombo_inchar.value)))]},
    .output_level    = XMC_GPIO_OUTPUT_LEVEL_LOW,
    .output_strength = (XMC_GPIO_OUTPUT_STRENGTH_t)0
  };
""");
  } else {
out.print("""
  /* GPIO config Init handle for trap Pin */
  const XMC_GPIO_CONFIG_t ${appInst}_TrapPinConf = 
  {
    .mode            = ${gpio_mode[(int)((appIns.hwres_port_pad_trap.getRegValue("IOCR","iocr_oe")) + (appIns.gcombo_inchar.options.indexOf(appIns.gcombo_inchar.value)))]},
    .input_hysteresis= XMC_GPIO_INPUT_HYSTERESIS_STANDARD,
    .output_level    = XMC_GPIO_OUTPUT_LEVEL_LOW
  };
""");
  }
out.print("""
  /* External Trap event for all slices */
  const XMC_CCU8_SLICE_EVENT_CONFIG_t ${appInst}_TrapConfig =
  {
  .mapped_input  = ${if(family+series == "XMC14" ) mapped_input_CCU8V3[mapped_inp_trap] else mapped_input[mapped_inp_trap]},
  .edge          = XMC_CCU8_SLICE_EVENT_EDGE_SENSITIVITY_NONE,
  .level         = ${levelArray[appIns.gcombo_traplevelsel.options.indexOf(appIns.gcombo_traplevelsel.value)]},
  .duration      = XMC_CCU8_SLICE_EVENT_FILTER_DISABLED
  };
""");   
}
print("""
/*Slice U configuration*/
const PWM_CCU8_CC8_t ${appInst}_PhU = 
{
  .slice_ptr      = (XMC_CCU8_SLICE_t*)(void *)CCU8${kernelNo}_CC8${phaseu},
  .slice_number   = (uint8_t)${phaseu}
};
/*Slice V configuration*/
const PWM_CCU8_CC8_t ${appInst}_PhV = 
{
  .slice_ptr      = (XMC_CCU8_SLICE_t*)(void *)CCU8${kernelNo}_CC8${phasev},
  .slice_number   = (uint8_t)${phasev}
};
/*Slice W configuration*/
const PWM_CCU8_CC8_t ${appInst}_PhW = 
{
  .slice_ptr      = (XMC_CCU8_SLICE_t*)(void *)CCU8${kernelNo}_CC8${phasew},
  .slice_number   = (uint8_t)${phasew}
};
/*Current trigger configuration*/
const PWM_CCU8_CC8_t ${appInst}_CurrentTrig = 
{
  .slice_ptr      = (XMC_CCU8_SLICE_t*)(void *)CCU8${kernelNo}_CC8${currenttrig},
  .slice_number   = (uint8_t)${currenttrig}
};
/*Dead time configuration structure*/
XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t ${appInst}_DeadTimeConfig =
{
 .enable_dead_time_channel1         = 1U,
 .enable_dead_time_channel2         = 1U,
 .channel1_st_path                  = 1U,
 .channel1_inv_st_path              = 1U,
 .channel2_st_path                  = 1U,
 .channel2_inv_st_path              = 1U,  
 .div                               = ${appIns.gint_deadtimeprescaler.value}U,
 .channel1_st_rising_edge_counter   = 0x${Integer.toHexString(dead_time_count_rising_edge)}U,
 .channel1_st_falling_edge_counter  = 0x${Integer.toHexString(dead_time_count_falling_edge)}U,
 .channel2_st_rising_edge_counter   = 0x${Integer.toHexString(dead_time_count_rising_edge)}U,
 .channel2_st_falling_edge_counter  = 0x${Integer.toHexString(dead_time_count_falling_edge)}U   
};

/* External Start event for all slices */
const XMC_CCU8_SLICE_EVENT_CONFIG_t ${appInst}_StartConfig =
{
  .mapped_input  = ${if(family+series == "XMC14" ) mapped_input_CCU8V3[mapped_inp_start] else mapped_input[mapped_inp_start]},
  .edge          = XMC_CCU8_SLICE_EVENT_EDGE_SENSITIVITY_RISING_EDGE,
  .level         = XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH,
  .duration      = XMC_CCU8_SLICE_EVENT_FILTER_DISABLED
};
/* CC8 Slice configuration  for all three pwm phases*/
const XMC_CCU8_SLICE_COMPARE_CONFIG_t ${appInst}_TimerInitHandle =
{
  .timer_mode           = (uint8_t)${TimerCountArray[timer_count_mode]},
  .monoshot             = 0U,
  .shadow_xfer_clear    = 0U,
  .dither_timer_period  = 0U,
  .dither_duty_cycle    = 0U,
  .prescaler_mode       = (uint8_t)XMC_CCU8_SLICE_PRESCALER_MODE_NORMAL,
  .mcm_ch1_enable       = 0U,
  .mcm_ch2_enable       = 0U,
  .slice_status         = (uint8_t)XMC_CCU8_SLICE_STATUS_CHANNEL_1,
  .passive_level_out0   = ${passivelvl_array[appIns.gcombo_highsideswitch.options.indexOf(appIns.gcombo_highsideswitch.value)]},   
  .passive_level_out1   = ${passivelvl_array[appIns.gcombo_lowsideswitch.options.indexOf(appIns.gcombo_lowsideswitch.value)]},
  .passive_level_out2   = ${passivelvl_array[appIns.gcombo_highsideswitch.options.indexOf(appIns.gcombo_highsideswitch.value)]},
  .passive_level_out3   = ${passivelvl_array[appIns.gcombo_lowsideswitch.options.indexOf(appIns.gcombo_lowsideswitch.value)]},
  .asymmetric_pwm       = (uint8_t)${asymmetric},
#if !defined(CCU8V3) 
  .invert_out0          = 0U,
  .invert_out1          = 1U,
  .invert_out2          = 0U,
  .invert_out3          = 1U,
#else
  .selector_out0        = XMC_CCU8_SOURCE_OUT0_ST1,
  .selector_out1        = XMC_CCU8_SOURCE_OUT1_INV_ST1,
  .selector_out2        = XMC_CCU8_SOURCE_OUT2_ST2,
  .selector_out3        = XMC_CCU8_SOURCE_OUT3_INV_ST2,
#endif
  .prescaler_initval    = (uint8_t)${appIns.gint_prescaler.value},
  .float_limit          = 0U,
  .dither_limit         = 0U,
  .timer_concatenation  = 0U
};
/* CC8 Slice configuration  for current trigger slice*/
const XMC_CCU8_SLICE_COMPARE_CONFIG_t ${appInst}_TimerInit_CurrentTrig =
{
  .timer_mode           = (uint8_t)${TimerCountArray[timer_count_mode]},
  .monoshot             = 0U,
  .shadow_xfer_clear    = 0U,
  .dither_timer_period  = 0U,
  .dither_duty_cycle    = 0U,
  .prescaler_mode       = (uint8_t)XMC_CCU8_SLICE_PRESCALER_MODE_NORMAL,
  .mcm_ch1_enable       = 0U,
  .mcm_ch2_enable       = 0U,
  .slice_status         = (uint8_t)${currenttrig_cmp_status},
  .passive_level_out0   = 1U,   
  .passive_level_out1   = 1U,
  .passive_level_out2   = 1U,
  .passive_level_out3   = 1U,
  .asymmetric_pwm       = (uint8_t)${asymmetric},
#if !defined(CCU8V3) 
  .invert_out0          = 0U,
  .invert_out1          = 0U,
  .invert_out2          = 0U,
  .invert_out3          = 0U,
#else
  .selector_out0        = XMC_CCU8_SOURCE_OUT0_ST1,
  .selector_out1        = XMC_CCU8_SOURCE_OUT1_ST1,
  .selector_out2        = XMC_CCU8_SOURCE_OUT2_ST2,
  .selector_out3        = XMC_CCU8_SOURCE_OUT3_ST2,
#endif
  .prescaler_initval    = (uint8_t)${appIns.gint_prescaler.value},
  .float_limit          = 0U,
  .dither_limit         = 0U,
  .timer_concatenation  = 0U,
};
/*App configuration handle initialization*/
const PWM_SVM_Config_t ${appInst}_AppConfig =
{
  .config_phasev_crs     = (uint32_t *)&CCU8${kernelNo}_CC8${phasev}->CR${phasevCmpCh}S,
  .config_phasew_crs     = (uint32_t *)&CCU8${kernelNo}_CC8${phasew}->CR${phasewCmpCh}S,
  .pwm_frequency         = ${appIns.gint_pwmfreq.value}U,
  .module_freq           = ${(Integer)(appIns.gint_frequency.value)}U, 
  .sync_start_mask       = 0x${Long.toHexString(1 << (Integer.parseInt(kernelNo) + 8))}U,
  .shadow_transfer_mask  = 0x${Long.toHexString(shadowtransfer)}U,
  .event_sr_selector     = {
                              0x${Long.toHexString(event_sr[0])}U, 0x${Long.toHexString(event_sr[1])}U, 
                              0x${Long.toHexString(event_sr[2])}U, 0x${Long.toHexString(event_sr[3])}U,
                           },
  .period_max            = (uint32_t)${appIns.gint_pwmfreq.maxValue},
  .period_min            = (uint32_t)${appIns.gint_pwmfreq.minValue},
  .phase_cmpch_map       = {
                             XMC_CCU8_SLICE_COMPARE_CHANNEL_${phaseuCmpCh},
                             XMC_CCU8_SLICE_COMPARE_CHANNEL_${phasevCmpCh},
                             XMC_CCU8_SLICE_COMPARE_CHANNEL_${phasewCmpCh},
                             ${currenttrig_cmp_channel}
                           },
  .phase_st_map          = {
                             ${phu_st},
                             ${phv_st},
                             ${phw_st}
                            },
  .segment_time_calc     = ${SegTimeCalcArray[(appIns.gcombo_segmenttimecalculation.options.indexOf(appIns.gcombo_segmenttimecalculation.value))]},
  .current_measurement   = ${CurrentMeasArray[appIns.gcombo_externaltrigger.options.indexOf(appIns.gcombo_externaltrigger.value)]},
  .trap_exit_mode        = ${trapexitArray[appIns.gcombo_trapexitcontrol.options.indexOf(appIns.gcombo_trapexitcontrol.value)]},
""");
if(appIns.gcombo_traplevelsel.value != "Disabled")
{
out.println("""
  .trap_hwsel            = ${["XMC_GPIO_HWCTRL_DISABLED","XMC_GPIO_HWCTRL_PERIPHERAL1","XMC_GPIO_HWCTRL_PERIPHERAL2"][(int)(appIns.hwres_port_pad_trap.getRegValue("","hwsel_hw"))]},
  .enable_trap           = (uint8_t)true,
""")
}else
{
  out.println("""
  .trap_hwsel            = XMC_GPIO_HWCTRL_DISABLED,
  .enable_trap           = (uint8_t)false,
""")
}
out.println("""
  .inverter_pin          = ${inverterpin},
  .phase_u_out0          = ${phaseu_out0},
  .phase_v_out0          = ${phasev_out0},
  .phase_w_out0          = ${phasew_out0},
  .current_offset        = (uint16_t)${appIns.gint_current_offset.value},
  .amplitude_scale       = (uint16_t)${(int)amplitude_scale},
  .enable_periodmatch    = (uint8_t)${appIns.gcheck_periodmatchintenable.value},
  .enable_trapevent      = (uint8_t)${appIns.gcheck_trapintenable.value},
  .enable_optimized_slice= (uint8_t)${appIns.gcheck_optimization.value},
  .trap_sync_pwm         = (uint8_t)${appIns.gcombo_trapsyncenable.options.indexOf(appIns.gcombo_trapsyncenable.value)}
};
/*App handle structure initialization*/
PWM_SVM_t ${appInst} =
{
  .confighandle_ptr       = (PWM_SVM_Config_t*)(void*)&${appInst}_AppConfig,
  .global_ptr             = (XMC_CCU8_MODULE_t *)(void*)CCU8${kernelNo}_BASE,
  .phase_ptr              = { 
                             (PWM_CCU8_CC8_t*)(void*)&${appInst}_PhU,
                             (PWM_CCU8_CC8_t*)(void*)&${appInst}_PhV,
                             (PWM_CCU8_CC8_t*)(void*)&${appInst}_PhW,
                             (PWM_CCU8_CC8_t*)(void*)&${appInst}_CurrentTrig,
                            },
  .phase_configinit_ptr   = (XMC_CCU8_SLICE_COMPARE_CONFIG_t*)(void*)&${appInst}_TimerInitHandle,
  .current_configinit_ptr = (XMC_CCU8_SLICE_COMPARE_CONFIG_t*)(void*)&${appInst}_TimerInit_CurrentTrig, 
  .pwmoutpin_ptr          =
                            {
                              (PWM_SVM_GPIO_t*)(void*)&${appInst}_PhUHighPin,
                              (PWM_SVM_GPIO_t*)(void*)&${appInst}_PhULowPin,
                              (PWM_SVM_GPIO_t*)(void*)&${appInst}_PhVHighPin,
                              (PWM_SVM_GPIO_t*)(void*)&${appInst}_PhVLowPin,
                              (PWM_SVM_GPIO_t*)(void*)&${appInst}_PhWHighPin,
                              (PWM_SVM_GPIO_t*)(void*)&${appInst}_PhWLowPin,
                            },
  .pwmoutconfig_ptr       = 
                            {
                             (XMC_GPIO_CONFIG_t*)(void*)&${appInst}_PhUHiOutPinConf,
                             (XMC_GPIO_CONFIG_t*)(void*)&${appInst}_PhULoOutPinConf,
                             (XMC_GPIO_CONFIG_t*)(void*)&${appInst}_PhVHiOutPinConf,
                             (XMC_GPIO_CONFIG_t*)(void*)&${appInst}_PhVLoOutPinConf,
                             (XMC_GPIO_CONFIG_t*)(void*)&${appInst}_PhWHiOutPinConf,
                             (XMC_GPIO_CONFIG_t*)(void*)&${appInst}_PhWLoOutPinConf,
                            },
  .phaseu_crs            = (uint32_t *)&CCU8${kernelNo}_CC8${phaseu}->CR${phaseuCmpCh}S,
  .phasev_crs            = (uint32_t *)&CCU8${kernelNo}_CC8${phasev}->CR${phasevCmpCh}S,
  .phasew_crs            = (uint32_t *)&CCU8${kernelNo}_CC8${phasew}->CR${phasewCmpCh}S,
""");
if(appIns.gint_index.value > 1)
{
out.println("""
  .phaseu_cr2s            = (uint32_t *)&CCU8${kernelNo}_CC8${phaseu}->CR2S,
  .phasev_cr2s            = (uint32_t *)&CCU8${kernelNo}_CC8${phasev}->CR2S,
  .phasew_cr2s            = (uint32_t *)&CCU8${kernelNo}_CC8${phasew}->CR2S,
""")
}
  if(appIns.gcombo_traplevelsel.value != "Disabled"){
out.print("""
  .trappin_ptr            = (PWM_SVM_GPIO_t*)(void*)&${appInst}_TrapPin,
  .trapinconfig_ptr       = (XMC_GPIO_CONFIG_t*)(void*)&${appInst}_TrapPinConf,
  .trapconfig_ptr         = (XMC_CCU8_SLICE_EVENT_CONFIG_t*)(void*)&${appInst}_TrapConfig,
""");
  }else{
out.print("""
  .trappin_ptr            = NULL,
  .trapinconfig_ptr       = NULL,
  .trapconfig_ptr         = NULL,
""");
  } 
  if(appIns.gcombo_invlevelsel.value != "Disabled")
  {
out.print("""
  .inverterpin_ptr        = (PWM_SVM_GPIO_t*)(void*)&${appInst}_InverterPin,
  .inverterpinconfig_ptr  = (XMC_GPIO_CONFIG_t*)(void*)&${appInst}_InvPinConf,
""");
  } else {
out.print("""
  .inverterpin_ptr        = NULL,
  .inverterpinconfig_ptr  = NULL,
""");
  }    
out.print("""
  .startconfig_ptr        = (XMC_CCU8_SLICE_EVENT_CONFIG_t*)(void*)&${appInst}_StartConfig,
  .globalccu8_handle_ptr  = (GLOBAL_CCU8_t*)(void*)&${appIns.appres_global_ccu8_app0.getInstanceLabel()},
  .deadtimeconfig_ptr     = (XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t*)(void*)&${appInst}_DeadTimeConfig,
  .svm_schemesel_ptr      = (PWM_SVM_SVMSCHEME_PTR_t)${svm_scheme},
  .seg_time_calc_ptr      = (PWM_SVM_SEGCALC_PTR_t)${seg_time_calc},
  .period                 = ${appIns.gint_periodreg.value}U,
  .state                  = PWM_SVM_UNINITIALIZED,
  .svm_config             = (PWM_SVM_SVMCONFIG_t)${SVMConfigarray[(int)(appIns.gint_index.value)]}, 
  .tmin                   = ${appIns.gint_tmincount.value}U,
  .tmin_14                = ${(int)tmin_14}U,
  .max_amplitude          = ${max_amplitude_t}U,
  .over_modulation_enable = ${ov_mod}U,
  .over_modulation_scale  = ${(int)overmodscale}U,
  .max_amplitude_overmod  = ${(int)(16384 * 1.15)}U, 
  .t0                     = ${appIns.gint_periodreg.value}U
};
""");
} else {
out.print("""
  /*CCU8 resource is not mapped for PWM_SVM app instant: ${appInst} */
""");
  }
  
  
}
